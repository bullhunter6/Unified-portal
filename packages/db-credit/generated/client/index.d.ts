
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activity_logs
 * 
 */
export type activity_logs = $Result.DefaultSelection<Prisma.$activity_logsPayload>
/**
 * Model activitylog
 * 
 */
export type activitylog = $Result.DefaultSelection<Prisma.$activitylogPayload>
/**
 * Model ai_assistant_config
 * 
 */
export type ai_assistant_config = $Result.DefaultSelection<Prisma.$ai_assistant_configPayload>
/**
 * Model ai_conversations
 * 
 */
export type ai_conversations = $Result.DefaultSelection<Prisma.$ai_conversationsPayload>
/**
 * Model ai_entity_memory
 * 
 */
export type ai_entity_memory = $Result.DefaultSelection<Prisma.$ai_entity_memoryPayload>
/**
 * Model ai_knowledge_base
 * 
 */
export type ai_knowledge_base = $Result.DefaultSelection<Prisma.$ai_knowledge_basePayload>
/**
 * Model ai_session_memory
 * 
 */
export type ai_session_memory = $Result.DefaultSelection<Prisma.$ai_session_memoryPayload>
/**
 * Model article
 * 
 */
export type article = $Result.DefaultSelection<Prisma.$articlePayload>
/**
 * Model article_tags
 * 
 */
export type article_tags = $Result.DefaultSelection<Prisma.$article_tagsPayload>
/**
 * Model articlestar
 * 
 */
export type articlestar = $Result.DefaultSelection<Prisma.$articlestarPayload>
/**
 * Model articleview
 * 
 */
export type articleview = $Result.DefaultSelection<Prisma.$articleviewPayload>
/**
 * Model credit_articles
 * 
 */
export type credit_articles = $Result.DefaultSelection<Prisma.$credit_articlesPayload>
/**
 * Model email_alerts
 * 
 */
export type email_alerts = $Result.DefaultSelection<Prisma.$email_alertsPayload>
/**
 * Model event
 * 
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>
/**
 * Model eventregistration
 * 
 */
export type eventregistration = $Result.DefaultSelection<Prisma.$eventregistrationPayload>
/**
 * Model events
 * 
 */
export type events = $Result.DefaultSelection<Prisma.$eventsPayload>
/**
 * Model methodologies
 * 
 */
export type methodologies = $Result.DefaultSelection<Prisma.$methodologiesPayload>
/**
 * Model newsletter_logs
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type newsletter_logs = $Result.DefaultSelection<Prisma.$newsletter_logsPayload>
/**
 * Model newsletter_preferences
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type newsletter_preferences = $Result.DefaultSelection<Prisma.$newsletter_preferencesPayload>
/**
 * Model newsletter_subscriptions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type newsletter_subscriptions = $Result.DefaultSelection<Prisma.$newsletter_subscriptionsPayload>
/**
 * Model permission
 * 
 */
export type permission = $Result.DefaultSelection<Prisma.$permissionPayload>
/**
 * Model publications
 * 
 */
export type publications = $Result.DefaultSelection<Prisma.$publicationsPayload>
/**
 * Model refreshtoken
 * 
 */
export type refreshtoken = $Result.DefaultSelection<Prisma.$refreshtokenPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model tag
 * 
 */
export type tag = $Result.DefaultSelection<Prisma.$tagPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model user_activity
 * 
 */
export type user_activity = $Result.DefaultSelection<Prisma.$user_activityPayload>
/**
 * Model user_alerts
 * 
 */
export type user_alerts = $Result.DefaultSelection<Prisma.$user_alertsPayload>
/**
 * Model user_article_stars
 * 
 */
export type user_article_stars = $Result.DefaultSelection<Prisma.$user_article_starsPayload>
/**
 * Model user_events
 * 
 */
export type user_events = $Result.DefaultSelection<Prisma.$user_eventsPayload>
/**
 * Model user_permissions
 * 
 */
export type user_permissions = $Result.DefaultSelection<Prisma.$user_permissionsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model usersession
 * 
 */
export type usersession = $Result.DefaultSelection<Prisma.$usersessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const permissiontype: {
  USER_CREATE: 'USER_CREATE',
  USER_READ: 'USER_READ',
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  ARTICLE_CREATE: 'ARTICLE_CREATE',
  ARTICLE_READ: 'ARTICLE_READ',
  ARTICLE_UPDATE: 'ARTICLE_UPDATE',
  ARTICLE_DELETE: 'ARTICLE_DELETE',
  ARTICLE_PUBLISH: 'ARTICLE_PUBLISH',
  EVENT_CREATE: 'EVENT_CREATE',
  EVENT_READ: 'EVENT_READ',
  EVENT_UPDATE: 'EVENT_UPDATE',
  EVENT_DELETE: 'EVENT_DELETE',
  ADMIN_ACCESS: 'ADMIN_ACCESS',
  ADMIN_USERS: 'ADMIN_USERS',
  ADMIN_CONTENT: 'ADMIN_CONTENT',
  ADMIN_SETTINGS: 'ADMIN_SETTINGS',
  ADMIN_LOGS: 'ADMIN_LOGS',
  SYSTEM_CONFIG: 'SYSTEM_CONFIG',
  SYSTEM_BACKUP: 'SYSTEM_BACKUP',
  SYSTEM_MAINTENANCE: 'SYSTEM_MAINTENANCE'
};

export type permissiontype = (typeof permissiontype)[keyof typeof permissiontype]


export const userrole: {
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  USER: 'USER',
  GUEST: 'GUEST'
};

export type userrole = (typeof userrole)[keyof typeof userrole]

}

export type permissiontype = $Enums.permissiontype

export const permissiontype: typeof $Enums.permissiontype

export type userrole = $Enums.userrole

export const userrole: typeof $Enums.userrole

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activity_logs
 * const activity_logs = await prisma.activity_logs.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activity_logs
   * const activity_logs = await prisma.activity_logs.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.activity_logs`: Exposes CRUD operations for the **activity_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activity_logs
    * const activity_logs = await prisma.activity_logs.findMany()
    * ```
    */
  get activity_logs(): Prisma.activity_logsDelegate<ExtArgs>;

  /**
   * `prisma.activitylog`: Exposes CRUD operations for the **activitylog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activitylogs
    * const activitylogs = await prisma.activitylog.findMany()
    * ```
    */
  get activitylog(): Prisma.activitylogDelegate<ExtArgs>;

  /**
   * `prisma.ai_assistant_config`: Exposes CRUD operations for the **ai_assistant_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_assistant_configs
    * const ai_assistant_configs = await prisma.ai_assistant_config.findMany()
    * ```
    */
  get ai_assistant_config(): Prisma.ai_assistant_configDelegate<ExtArgs>;

  /**
   * `prisma.ai_conversations`: Exposes CRUD operations for the **ai_conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_conversations
    * const ai_conversations = await prisma.ai_conversations.findMany()
    * ```
    */
  get ai_conversations(): Prisma.ai_conversationsDelegate<ExtArgs>;

  /**
   * `prisma.ai_entity_memory`: Exposes CRUD operations for the **ai_entity_memory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_entity_memories
    * const ai_entity_memories = await prisma.ai_entity_memory.findMany()
    * ```
    */
  get ai_entity_memory(): Prisma.ai_entity_memoryDelegate<ExtArgs>;

  /**
   * `prisma.ai_knowledge_base`: Exposes CRUD operations for the **ai_knowledge_base** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_knowledge_bases
    * const ai_knowledge_bases = await prisma.ai_knowledge_base.findMany()
    * ```
    */
  get ai_knowledge_base(): Prisma.ai_knowledge_baseDelegate<ExtArgs>;

  /**
   * `prisma.ai_session_memory`: Exposes CRUD operations for the **ai_session_memory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ai_session_memories
    * const ai_session_memories = await prisma.ai_session_memory.findMany()
    * ```
    */
  get ai_session_memory(): Prisma.ai_session_memoryDelegate<ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.articleDelegate<ExtArgs>;

  /**
   * `prisma.article_tags`: Exposes CRUD operations for the **article_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Article_tags
    * const article_tags = await prisma.article_tags.findMany()
    * ```
    */
  get article_tags(): Prisma.article_tagsDelegate<ExtArgs>;

  /**
   * `prisma.articlestar`: Exposes CRUD operations for the **articlestar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articlestars
    * const articlestars = await prisma.articlestar.findMany()
    * ```
    */
  get articlestar(): Prisma.articlestarDelegate<ExtArgs>;

  /**
   * `prisma.articleview`: Exposes CRUD operations for the **articleview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articleviews
    * const articleviews = await prisma.articleview.findMany()
    * ```
    */
  get articleview(): Prisma.articleviewDelegate<ExtArgs>;

  /**
   * `prisma.credit_articles`: Exposes CRUD operations for the **credit_articles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credit_articles
    * const credit_articles = await prisma.credit_articles.findMany()
    * ```
    */
  get credit_articles(): Prisma.credit_articlesDelegate<ExtArgs>;

  /**
   * `prisma.email_alerts`: Exposes CRUD operations for the **email_alerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_alerts
    * const email_alerts = await prisma.email_alerts.findMany()
    * ```
    */
  get email_alerts(): Prisma.email_alertsDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.eventDelegate<ExtArgs>;

  /**
   * `prisma.eventregistration`: Exposes CRUD operations for the **eventregistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventregistrations
    * const eventregistrations = await prisma.eventregistration.findMany()
    * ```
    */
  get eventregistration(): Prisma.eventregistrationDelegate<ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.eventsDelegate<ExtArgs>;

  /**
   * `prisma.methodologies`: Exposes CRUD operations for the **methodologies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Methodologies
    * const methodologies = await prisma.methodologies.findMany()
    * ```
    */
  get methodologies(): Prisma.methodologiesDelegate<ExtArgs>;

  /**
   * `prisma.newsletter_logs`: Exposes CRUD operations for the **newsletter_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletter_logs
    * const newsletter_logs = await prisma.newsletter_logs.findMany()
    * ```
    */
  get newsletter_logs(): Prisma.newsletter_logsDelegate<ExtArgs>;

  /**
   * `prisma.newsletter_preferences`: Exposes CRUD operations for the **newsletter_preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletter_preferences
    * const newsletter_preferences = await prisma.newsletter_preferences.findMany()
    * ```
    */
  get newsletter_preferences(): Prisma.newsletter_preferencesDelegate<ExtArgs>;

  /**
   * `prisma.newsletter_subscriptions`: Exposes CRUD operations for the **newsletter_subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletter_subscriptions
    * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findMany()
    * ```
    */
  get newsletter_subscriptions(): Prisma.newsletter_subscriptionsDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs>;

  /**
   * `prisma.publications`: Exposes CRUD operations for the **publications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publications.findMany()
    * ```
    */
  get publications(): Prisma.publicationsDelegate<ExtArgs>;

  /**
   * `prisma.refreshtoken`: Exposes CRUD operations for the **refreshtoken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refreshtokens
    * const refreshtokens = await prisma.refreshtoken.findMany()
    * ```
    */
  get refreshtoken(): Prisma.refreshtokenDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.tagDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.user_activity`: Exposes CRUD operations for the **user_activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_activities
    * const user_activities = await prisma.user_activity.findMany()
    * ```
    */
  get user_activity(): Prisma.user_activityDelegate<ExtArgs>;

  /**
   * `prisma.user_alerts`: Exposes CRUD operations for the **user_alerts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_alerts
    * const user_alerts = await prisma.user_alerts.findMany()
    * ```
    */
  get user_alerts(): Prisma.user_alertsDelegate<ExtArgs>;

  /**
   * `prisma.user_article_stars`: Exposes CRUD operations for the **user_article_stars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_article_stars
    * const user_article_stars = await prisma.user_article_stars.findMany()
    * ```
    */
  get user_article_stars(): Prisma.user_article_starsDelegate<ExtArgs>;

  /**
   * `prisma.user_events`: Exposes CRUD operations for the **user_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_events
    * const user_events = await prisma.user_events.findMany()
    * ```
    */
  get user_events(): Prisma.user_eventsDelegate<ExtArgs>;

  /**
   * `prisma.user_permissions`: Exposes CRUD operations for the **user_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_permissions
    * const user_permissions = await prisma.user_permissions.findMany()
    * ```
    */
  get user_permissions(): Prisma.user_permissionsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.usersession`: Exposes CRUD operations for the **usersession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usersessions
    * const usersessions = await prisma.usersession.findMany()
    * ```
    */
  get usersession(): Prisma.usersessionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activity_logs: 'activity_logs',
    activitylog: 'activitylog',
    ai_assistant_config: 'ai_assistant_config',
    ai_conversations: 'ai_conversations',
    ai_entity_memory: 'ai_entity_memory',
    ai_knowledge_base: 'ai_knowledge_base',
    ai_session_memory: 'ai_session_memory',
    article: 'article',
    article_tags: 'article_tags',
    articlestar: 'articlestar',
    articleview: 'articleview',
    credit_articles: 'credit_articles',
    email_alerts: 'email_alerts',
    event: 'event',
    eventregistration: 'eventregistration',
    events: 'events',
    methodologies: 'methodologies',
    newsletter_logs: 'newsletter_logs',
    newsletter_preferences: 'newsletter_preferences',
    newsletter_subscriptions: 'newsletter_subscriptions',
    permission: 'permission',
    publications: 'publications',
    refreshtoken: 'refreshtoken',
    roles: 'roles',
    tag: 'tag',
    user: 'user',
    user_activity: 'user_activity',
    user_alerts: 'user_alerts',
    user_article_stars: 'user_article_stars',
    user_events: 'user_events',
    user_permissions: 'user_permissions',
    users: 'users',
    usersession: 'usersession'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "activity_logs" | "activitylog" | "ai_assistant_config" | "ai_conversations" | "ai_entity_memory" | "ai_knowledge_base" | "ai_session_memory" | "article" | "article_tags" | "articlestar" | "articleview" | "credit_articles" | "email_alerts" | "event" | "eventregistration" | "events" | "methodologies" | "newsletter_logs" | "newsletter_preferences" | "newsletter_subscriptions" | "permission" | "publications" | "refreshtoken" | "roles" | "tag" | "user" | "user_activity" | "user_alerts" | "user_article_stars" | "user_events" | "user_permissions" | "users" | "usersession"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activity_logs: {
        payload: Prisma.$activity_logsPayload<ExtArgs>
        fields: Prisma.activity_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activity_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activity_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          findFirst: {
            args: Prisma.activity_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activity_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          findMany: {
            args: Prisma.activity_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>[]
          }
          create: {
            args: Prisma.activity_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          createMany: {
            args: Prisma.activity_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activity_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>[]
          }
          delete: {
            args: Prisma.activity_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          update: {
            args: Prisma.activity_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          deleteMany: {
            args: Prisma.activity_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activity_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.activity_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activity_logsPayload>
          }
          aggregate: {
            args: Prisma.Activity_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity_logs>
          }
          groupBy: {
            args: Prisma.activity_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Activity_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.activity_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Activity_logsCountAggregateOutputType> | number
          }
        }
      }
      activitylog: {
        payload: Prisma.$activitylogPayload<ExtArgs>
        fields: Prisma.activitylogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activitylogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activitylogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          findFirst: {
            args: Prisma.activitylogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activitylogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          findMany: {
            args: Prisma.activitylogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>[]
          }
          create: {
            args: Prisma.activitylogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          createMany: {
            args: Prisma.activitylogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activitylogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>[]
          }
          delete: {
            args: Prisma.activitylogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          update: {
            args: Prisma.activitylogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          deleteMany: {
            args: Prisma.activitylogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activitylogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.activitylogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          aggregate: {
            args: Prisma.ActivitylogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivitylog>
          }
          groupBy: {
            args: Prisma.activitylogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivitylogGroupByOutputType>[]
          }
          count: {
            args: Prisma.activitylogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivitylogCountAggregateOutputType> | number
          }
        }
      }
      ai_assistant_config: {
        payload: Prisma.$ai_assistant_configPayload<ExtArgs>
        fields: Prisma.ai_assistant_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_assistant_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_assistant_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          findFirst: {
            args: Prisma.ai_assistant_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_assistant_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          findMany: {
            args: Prisma.ai_assistant_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>[]
          }
          create: {
            args: Prisma.ai_assistant_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          createMany: {
            args: Prisma.ai_assistant_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_assistant_configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>[]
          }
          delete: {
            args: Prisma.ai_assistant_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          update: {
            args: Prisma.ai_assistant_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          deleteMany: {
            args: Prisma.ai_assistant_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_assistant_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_assistant_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_assistant_configPayload>
          }
          aggregate: {
            args: Prisma.Ai_assistant_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_assistant_config>
          }
          groupBy: {
            args: Prisma.ai_assistant_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_assistant_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_assistant_configCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_assistant_configCountAggregateOutputType> | number
          }
        }
      }
      ai_conversations: {
        payload: Prisma.$ai_conversationsPayload<ExtArgs>
        fields: Prisma.ai_conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          findFirst: {
            args: Prisma.ai_conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          findMany: {
            args: Prisma.ai_conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>[]
          }
          create: {
            args: Prisma.ai_conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          createMany: {
            args: Prisma.ai_conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>[]
          }
          delete: {
            args: Prisma.ai_conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          update: {
            args: Prisma.ai_conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          deleteMany: {
            args: Prisma.ai_conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_conversationsPayload>
          }
          aggregate: {
            args: Prisma.Ai_conversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_conversations>
          }
          groupBy: {
            args: Prisma.ai_conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_conversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_conversationsCountAggregateOutputType> | number
          }
        }
      }
      ai_entity_memory: {
        payload: Prisma.$ai_entity_memoryPayload<ExtArgs>
        fields: Prisma.ai_entity_memoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_entity_memoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_entity_memoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          findFirst: {
            args: Prisma.ai_entity_memoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_entity_memoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          findMany: {
            args: Prisma.ai_entity_memoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>[]
          }
          create: {
            args: Prisma.ai_entity_memoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          createMany: {
            args: Prisma.ai_entity_memoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_entity_memoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>[]
          }
          delete: {
            args: Prisma.ai_entity_memoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          update: {
            args: Prisma.ai_entity_memoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          deleteMany: {
            args: Prisma.ai_entity_memoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_entity_memoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_entity_memoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_entity_memoryPayload>
          }
          aggregate: {
            args: Prisma.Ai_entity_memoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_entity_memory>
          }
          groupBy: {
            args: Prisma.ai_entity_memoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_entity_memoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_entity_memoryCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_entity_memoryCountAggregateOutputType> | number
          }
        }
      }
      ai_knowledge_base: {
        payload: Prisma.$ai_knowledge_basePayload<ExtArgs>
        fields: Prisma.ai_knowledge_baseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_knowledge_baseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_knowledge_baseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          findFirst: {
            args: Prisma.ai_knowledge_baseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_knowledge_baseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          findMany: {
            args: Prisma.ai_knowledge_baseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>[]
          }
          create: {
            args: Prisma.ai_knowledge_baseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          createMany: {
            args: Prisma.ai_knowledge_baseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_knowledge_baseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>[]
          }
          delete: {
            args: Prisma.ai_knowledge_baseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          update: {
            args: Prisma.ai_knowledge_baseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          deleteMany: {
            args: Prisma.ai_knowledge_baseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_knowledge_baseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_knowledge_baseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_knowledge_basePayload>
          }
          aggregate: {
            args: Prisma.Ai_knowledge_baseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_knowledge_base>
          }
          groupBy: {
            args: Prisma.ai_knowledge_baseGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_knowledge_baseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_knowledge_baseCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_knowledge_baseCountAggregateOutputType> | number
          }
        }
      }
      ai_session_memory: {
        payload: Prisma.$ai_session_memoryPayload<ExtArgs>
        fields: Prisma.ai_session_memoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ai_session_memoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ai_session_memoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          findFirst: {
            args: Prisma.ai_session_memoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ai_session_memoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          findMany: {
            args: Prisma.ai_session_memoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>[]
          }
          create: {
            args: Prisma.ai_session_memoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          createMany: {
            args: Prisma.ai_session_memoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ai_session_memoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>[]
          }
          delete: {
            args: Prisma.ai_session_memoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          update: {
            args: Prisma.ai_session_memoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          deleteMany: {
            args: Prisma.ai_session_memoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ai_session_memoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ai_session_memoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ai_session_memoryPayload>
          }
          aggregate: {
            args: Prisma.Ai_session_memoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAi_session_memory>
          }
          groupBy: {
            args: Prisma.ai_session_memoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ai_session_memoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ai_session_memoryCountArgs<ExtArgs>
            result: $Utils.Optional<Ai_session_memoryCountAggregateOutputType> | number
          }
        }
      }
      article: {
        payload: Prisma.$articlePayload<ExtArgs>
        fields: Prisma.articleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.articleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.articleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          findFirst: {
            args: Prisma.articleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.articleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          findMany: {
            args: Prisma.articleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>[]
          }
          create: {
            args: Prisma.articleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          createMany: {
            args: Prisma.articleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.articleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>[]
          }
          delete: {
            args: Prisma.articleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          update: {
            args: Prisma.articleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          deleteMany: {
            args: Prisma.articleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.articleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.articleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.articleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.articleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      article_tags: {
        payload: Prisma.$article_tagsPayload<ExtArgs>
        fields: Prisma.article_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.article_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.article_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          findFirst: {
            args: Prisma.article_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.article_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          findMany: {
            args: Prisma.article_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>[]
          }
          create: {
            args: Prisma.article_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          createMany: {
            args: Prisma.article_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.article_tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>[]
          }
          delete: {
            args: Prisma.article_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          update: {
            args: Prisma.article_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          deleteMany: {
            args: Prisma.article_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.article_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.article_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$article_tagsPayload>
          }
          aggregate: {
            args: Prisma.Article_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle_tags>
          }
          groupBy: {
            args: Prisma.article_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Article_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.article_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Article_tagsCountAggregateOutputType> | number
          }
        }
      }
      articlestar: {
        payload: Prisma.$articlestarPayload<ExtArgs>
        fields: Prisma.articlestarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.articlestarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.articlestarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          findFirst: {
            args: Prisma.articlestarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.articlestarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          findMany: {
            args: Prisma.articlestarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>[]
          }
          create: {
            args: Prisma.articlestarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          createMany: {
            args: Prisma.articlestarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.articlestarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>[]
          }
          delete: {
            args: Prisma.articlestarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          update: {
            args: Prisma.articlestarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          deleteMany: {
            args: Prisma.articlestarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.articlestarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.articlestarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articlestarPayload>
          }
          aggregate: {
            args: Prisma.ArticlestarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticlestar>
          }
          groupBy: {
            args: Prisma.articlestarGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticlestarGroupByOutputType>[]
          }
          count: {
            args: Prisma.articlestarCountArgs<ExtArgs>
            result: $Utils.Optional<ArticlestarCountAggregateOutputType> | number
          }
        }
      }
      articleview: {
        payload: Prisma.$articleviewPayload<ExtArgs>
        fields: Prisma.articleviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.articleviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.articleviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          findFirst: {
            args: Prisma.articleviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.articleviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          findMany: {
            args: Prisma.articleviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>[]
          }
          create: {
            args: Prisma.articleviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          createMany: {
            args: Prisma.articleviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.articleviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>[]
          }
          delete: {
            args: Prisma.articleviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          update: {
            args: Prisma.articleviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          deleteMany: {
            args: Prisma.articleviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.articleviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.articleviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$articleviewPayload>
          }
          aggregate: {
            args: Prisma.ArticleviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleview>
          }
          groupBy: {
            args: Prisma.articleviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.articleviewCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleviewCountAggregateOutputType> | number
          }
        }
      }
      credit_articles: {
        payload: Prisma.$credit_articlesPayload<ExtArgs>
        fields: Prisma.credit_articlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credit_articlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credit_articlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          findFirst: {
            args: Prisma.credit_articlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credit_articlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          findMany: {
            args: Prisma.credit_articlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>[]
          }
          create: {
            args: Prisma.credit_articlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          createMany: {
            args: Prisma.credit_articlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credit_articlesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>[]
          }
          delete: {
            args: Prisma.credit_articlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          update: {
            args: Prisma.credit_articlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          deleteMany: {
            args: Prisma.credit_articlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credit_articlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.credit_articlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_articlesPayload>
          }
          aggregate: {
            args: Prisma.Credit_articlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredit_articles>
          }
          groupBy: {
            args: Prisma.credit_articlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credit_articlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.credit_articlesCountArgs<ExtArgs>
            result: $Utils.Optional<Credit_articlesCountAggregateOutputType> | number
          }
        }
      }
      email_alerts: {
        payload: Prisma.$email_alertsPayload<ExtArgs>
        fields: Prisma.email_alertsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_alertsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_alertsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          findFirst: {
            args: Prisma.email_alertsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_alertsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          findMany: {
            args: Prisma.email_alertsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>[]
          }
          create: {
            args: Prisma.email_alertsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          createMany: {
            args: Prisma.email_alertsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_alertsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>[]
          }
          delete: {
            args: Prisma.email_alertsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          update: {
            args: Prisma.email_alertsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          deleteMany: {
            args: Prisma.email_alertsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_alertsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.email_alertsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_alertsPayload>
          }
          aggregate: {
            args: Prisma.Email_alertsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_alerts>
          }
          groupBy: {
            args: Prisma.email_alertsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_alertsGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_alertsCountArgs<ExtArgs>
            result: $Utils.Optional<Email_alertsCountAggregateOutputType> | number
          }
        }
      }
      event: {
        payload: Prisma.$eventPayload<ExtArgs>
        fields: Prisma.eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.eventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[]
          }
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      eventregistration: {
        payload: Prisma.$eventregistrationPayload<ExtArgs>
        fields: Prisma.eventregistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventregistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventregistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          findFirst: {
            args: Prisma.eventregistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventregistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          findMany: {
            args: Prisma.eventregistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>[]
          }
          create: {
            args: Prisma.eventregistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          createMany: {
            args: Prisma.eventregistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.eventregistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>[]
          }
          delete: {
            args: Prisma.eventregistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          update: {
            args: Prisma.eventregistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          deleteMany: {
            args: Prisma.eventregistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventregistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventregistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventregistrationPayload>
          }
          aggregate: {
            args: Prisma.EventregistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventregistration>
          }
          groupBy: {
            args: Prisma.eventregistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventregistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventregistrationCountArgs<ExtArgs>
            result: $Utils.Optional<EventregistrationCountAggregateOutputType> | number
          }
        }
      }
      events: {
        payload: Prisma.$eventsPayload<ExtArgs>
        fields: Prisma.eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          findFirst: {
            args: Prisma.eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          findMany: {
            args: Prisma.eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>[]
          }
          create: {
            args: Prisma.eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          createMany: {
            args: Prisma.eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.eventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>[]
          }
          delete: {
            args: Prisma.eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          update: {
            args: Prisma.eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          deleteMany: {
            args: Prisma.eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      methodologies: {
        payload: Prisma.$methodologiesPayload<ExtArgs>
        fields: Prisma.methodologiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.methodologiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.methodologiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          findFirst: {
            args: Prisma.methodologiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.methodologiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          findMany: {
            args: Prisma.methodologiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>[]
          }
          create: {
            args: Prisma.methodologiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          createMany: {
            args: Prisma.methodologiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.methodologiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>[]
          }
          delete: {
            args: Prisma.methodologiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          update: {
            args: Prisma.methodologiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          deleteMany: {
            args: Prisma.methodologiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.methodologiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.methodologiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$methodologiesPayload>
          }
          aggregate: {
            args: Prisma.MethodologiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMethodologies>
          }
          groupBy: {
            args: Prisma.methodologiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MethodologiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.methodologiesCountArgs<ExtArgs>
            result: $Utils.Optional<MethodologiesCountAggregateOutputType> | number
          }
        }
      }
      newsletter_logs: {
        payload: Prisma.$newsletter_logsPayload<ExtArgs>
        fields: Prisma.newsletter_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletter_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletter_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          findFirst: {
            args: Prisma.newsletter_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletter_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          findMany: {
            args: Prisma.newsletter_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>[]
          }
          create: {
            args: Prisma.newsletter_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          createMany: {
            args: Prisma.newsletter_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.newsletter_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>[]
          }
          delete: {
            args: Prisma.newsletter_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          update: {
            args: Prisma.newsletter_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          deleteMany: {
            args: Prisma.newsletter_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletter_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletter_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_logsPayload>
          }
          aggregate: {
            args: Prisma.Newsletter_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter_logs>
          }
          groupBy: {
            args: Prisma.newsletter_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletter_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_logsCountAggregateOutputType> | number
          }
        }
      }
      newsletter_preferences: {
        payload: Prisma.$newsletter_preferencesPayload<ExtArgs>
        fields: Prisma.newsletter_preferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletter_preferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletter_preferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          findFirst: {
            args: Prisma.newsletter_preferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletter_preferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          findMany: {
            args: Prisma.newsletter_preferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>[]
          }
          create: {
            args: Prisma.newsletter_preferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          createMany: {
            args: Prisma.newsletter_preferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.newsletter_preferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>[]
          }
          delete: {
            args: Prisma.newsletter_preferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          update: {
            args: Prisma.newsletter_preferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          deleteMany: {
            args: Prisma.newsletter_preferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletter_preferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletter_preferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_preferencesPayload>
          }
          aggregate: {
            args: Prisma.Newsletter_preferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter_preferences>
          }
          groupBy: {
            args: Prisma.newsletter_preferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_preferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletter_preferencesCountArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_preferencesCountAggregateOutputType> | number
          }
        }
      }
      newsletter_subscriptions: {
        payload: Prisma.$newsletter_subscriptionsPayload<ExtArgs>
        fields: Prisma.newsletter_subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsletter_subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsletter_subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.newsletter_subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsletter_subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          findMany: {
            args: Prisma.newsletter_subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>[]
          }
          create: {
            args: Prisma.newsletter_subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          createMany: {
            args: Prisma.newsletter_subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.newsletter_subscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>[]
          }
          delete: {
            args: Prisma.newsletter_subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          update: {
            args: Prisma.newsletter_subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.newsletter_subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsletter_subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsletter_subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsletter_subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.Newsletter_subscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter_subscriptions>
          }
          groupBy: {
            args: Prisma.newsletter_subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_subscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsletter_subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<Newsletter_subscriptionsCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: Prisma.$permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      publications: {
        payload: Prisma.$publicationsPayload<ExtArgs>
        fields: Prisma.publicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          findFirst: {
            args: Prisma.publicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          findMany: {
            args: Prisma.publicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>[]
          }
          create: {
            args: Prisma.publicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          createMany: {
            args: Prisma.publicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>[]
          }
          delete: {
            args: Prisma.publicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          update: {
            args: Prisma.publicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          deleteMany: {
            args: Prisma.publicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.publicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          aggregate: {
            args: Prisma.PublicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublications>
          }
          groupBy: {
            args: Prisma.publicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.publicationsCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationsCountAggregateOutputType> | number
          }
        }
      }
      refreshtoken: {
        payload: Prisma.$refreshtokenPayload<ExtArgs>
        fields: Prisma.refreshtokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refreshtokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refreshtokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findFirst: {
            args: Prisma.refreshtokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refreshtokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findMany: {
            args: Prisma.refreshtokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          create: {
            args: Prisma.refreshtokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          createMany: {
            args: Prisma.refreshtokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.refreshtokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          delete: {
            args: Prisma.refreshtokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          update: {
            args: Prisma.refreshtokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          deleteMany: {
            args: Prisma.refreshtokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refreshtokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refreshtokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshtokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshtoken>
          }
          groupBy: {
            args: Prisma.refreshtokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.refreshtokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      tag: {
        payload: Prisma.$tagPayload<ExtArgs>
        fields: Prisma.tagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findFirst: {
            args: Prisma.tagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          findMany: {
            args: Prisma.tagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          create: {
            args: Prisma.tagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          createMany: {
            args: Prisma.tagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>[]
          }
          delete: {
            args: Prisma.tagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          update: {
            args: Prisma.tagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          deleteMany: {
            args: Prisma.tagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.tagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user_activity: {
        payload: Prisma.$user_activityPayload<ExtArgs>
        fields: Prisma.user_activityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_activityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_activityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          findFirst: {
            args: Prisma.user_activityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_activityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          findMany: {
            args: Prisma.user_activityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>[]
          }
          create: {
            args: Prisma.user_activityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          createMany: {
            args: Prisma.user_activityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_activityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>[]
          }
          delete: {
            args: Prisma.user_activityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          update: {
            args: Prisma.user_activityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          deleteMany: {
            args: Prisma.user_activityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_activityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_activityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_activityPayload>
          }
          aggregate: {
            args: Prisma.User_activityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_activity>
          }
          groupBy: {
            args: Prisma.user_activityGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_activityGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_activityCountArgs<ExtArgs>
            result: $Utils.Optional<User_activityCountAggregateOutputType> | number
          }
        }
      }
      user_alerts: {
        payload: Prisma.$user_alertsPayload<ExtArgs>
        fields: Prisma.user_alertsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_alertsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_alertsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          findFirst: {
            args: Prisma.user_alertsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_alertsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          findMany: {
            args: Prisma.user_alertsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>[]
          }
          create: {
            args: Prisma.user_alertsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          createMany: {
            args: Prisma.user_alertsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_alertsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>[]
          }
          delete: {
            args: Prisma.user_alertsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          update: {
            args: Prisma.user_alertsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          deleteMany: {
            args: Prisma.user_alertsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_alertsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_alertsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_alertsPayload>
          }
          aggregate: {
            args: Prisma.User_alertsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_alerts>
          }
          groupBy: {
            args: Prisma.user_alertsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_alertsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_alertsCountArgs<ExtArgs>
            result: $Utils.Optional<User_alertsCountAggregateOutputType> | number
          }
        }
      }
      user_article_stars: {
        payload: Prisma.$user_article_starsPayload<ExtArgs>
        fields: Prisma.user_article_starsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_article_starsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_article_starsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          findFirst: {
            args: Prisma.user_article_starsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_article_starsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          findMany: {
            args: Prisma.user_article_starsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>[]
          }
          create: {
            args: Prisma.user_article_starsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          createMany: {
            args: Prisma.user_article_starsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_article_starsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>[]
          }
          delete: {
            args: Prisma.user_article_starsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          update: {
            args: Prisma.user_article_starsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          deleteMany: {
            args: Prisma.user_article_starsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_article_starsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_article_starsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_article_starsPayload>
          }
          aggregate: {
            args: Prisma.User_article_starsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_article_stars>
          }
          groupBy: {
            args: Prisma.user_article_starsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_article_starsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_article_starsCountArgs<ExtArgs>
            result: $Utils.Optional<User_article_starsCountAggregateOutputType> | number
          }
        }
      }
      user_events: {
        payload: Prisma.$user_eventsPayload<ExtArgs>
        fields: Prisma.user_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          findFirst: {
            args: Prisma.user_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          findMany: {
            args: Prisma.user_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>[]
          }
          create: {
            args: Prisma.user_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          createMany: {
            args: Prisma.user_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_eventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>[]
          }
          delete: {
            args: Prisma.user_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          update: {
            args: Prisma.user_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          deleteMany: {
            args: Prisma.user_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_eventsPayload>
          }
          aggregate: {
            args: Prisma.User_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_events>
          }
          groupBy: {
            args: Prisma.user_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<User_eventsCountAggregateOutputType> | number
          }
        }
      }
      user_permissions: {
        payload: Prisma.$user_permissionsPayload<ExtArgs>
        fields: Prisma.user_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          findFirst: {
            args: Prisma.user_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          findMany: {
            args: Prisma.user_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>[]
          }
          create: {
            args: Prisma.user_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          createMany: {
            args: Prisma.user_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>[]
          }
          delete: {
            args: Prisma.user_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          update: {
            args: Prisma.user_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.user_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_permissionsPayload>
          }
          aggregate: {
            args: Prisma.User_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_permissions>
          }
          groupBy: {
            args: Prisma.user_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<User_permissionsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      usersession: {
        payload: Prisma.$usersessionPayload<ExtArgs>
        fields: Prisma.usersessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          findFirst: {
            args: Prisma.usersessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          findMany: {
            args: Prisma.usersessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>[]
          }
          create: {
            args: Prisma.usersessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          createMany: {
            args: Prisma.usersessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>[]
          }
          delete: {
            args: Prisma.usersessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          update: {
            args: Prisma.usersessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          deleteMany: {
            args: Prisma.usersessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersessionPayload>
          }
          aggregate: {
            args: Prisma.UsersessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersession>
          }
          groupBy: {
            args: Prisma.usersessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersessionCountArgs<ExtArgs>
            result: $Utils.Optional<UsersessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    article_tags: number
    articlestar: number
    articleview: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article_tags?: boolean | ArticleCountOutputTypeCountArticle_tagsArgs
    articlestar?: boolean | ArticleCountOutputTypeCountArticlestarArgs
    articleview?: boolean | ArticleCountOutputTypeCountArticleviewArgs
  }

  // Custom InputTypes
  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountArticle_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: article_tagsWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountArticlestarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articlestarWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountArticleviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articleviewWhereInput
  }


  /**
   * Count Type Credit_articlesCountOutputType
   */

  export type Credit_articlesCountOutputType = {
    user_article_stars: number
  }

  export type Credit_articlesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_article_stars?: boolean | Credit_articlesCountOutputTypeCountUser_article_starsArgs
  }

  // Custom InputTypes
  /**
   * Credit_articlesCountOutputType without action
   */
  export type Credit_articlesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit_articlesCountOutputType
     */
    select?: Credit_articlesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Credit_articlesCountOutputType without action
   */
  export type Credit_articlesCountOutputTypeCountUser_article_starsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_article_starsWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    eventregistration: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventregistration?: boolean | EventCountOutputTypeCountEventregistrationArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventregistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventregistrationWhereInput
  }


  /**
   * Count Type Newsletter_subscriptionsCountOutputType
   */

  export type Newsletter_subscriptionsCountOutputType = {
    newsletter_logs: number
    newsletter_preferences: number
  }

  export type Newsletter_subscriptionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_logs?: boolean | Newsletter_subscriptionsCountOutputTypeCountNewsletter_logsArgs
    newsletter_preferences?: boolean | Newsletter_subscriptionsCountOutputTypeCountNewsletter_preferencesArgs
  }

  // Custom InputTypes
  /**
   * Newsletter_subscriptionsCountOutputType without action
   */
  export type Newsletter_subscriptionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter_subscriptionsCountOutputType
     */
    select?: Newsletter_subscriptionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Newsletter_subscriptionsCountOutputType without action
   */
  export type Newsletter_subscriptionsCountOutputTypeCountNewsletter_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_logsWhereInput
  }

  /**
   * Newsletter_subscriptionsCountOutputType without action
   */
  export type Newsletter_subscriptionsCountOutputTypeCountNewsletter_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_preferencesWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    user_permissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_permissions?: boolean | PermissionCountOutputTypeCountUser_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountUser_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    article_tags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article_tags?: boolean | TagCountOutputTypeCountArticle_tagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountArticle_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: article_tagsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activitylog: number
    article: number
    articlestar: number
    articleview: number
    event: number
    eventregistration: number
    refreshtoken: number
    user_permissions: number
    usersession: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitylog?: boolean | UserCountOutputTypeCountActivitylogArgs
    article?: boolean | UserCountOutputTypeCountArticleArgs
    articlestar?: boolean | UserCountOutputTypeCountArticlestarArgs
    articleview?: boolean | UserCountOutputTypeCountArticleviewArgs
    event?: boolean | UserCountOutputTypeCountEventArgs
    eventregistration?: boolean | UserCountOutputTypeCountEventregistrationArgs
    refreshtoken?: boolean | UserCountOutputTypeCountRefreshtokenArgs
    user_permissions?: boolean | UserCountOutputTypeCountUser_permissionsArgs
    usersession?: boolean | UserCountOutputTypeCountUsersessionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitylogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlestarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articlestarWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticleviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articleviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventregistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventregistrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsersessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersessionWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    activity_logs: number
    ai_assistant_config: number
    ai_conversations: number
    ai_entity_memory: number
    ai_session_memory: number
    newsletter_subscriptions: number
    user_activity: number
    user_article_stars: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_logs?: boolean | UsersCountOutputTypeCountActivity_logsArgs
    ai_assistant_config?: boolean | UsersCountOutputTypeCountAi_assistant_configArgs
    ai_conversations?: boolean | UsersCountOutputTypeCountAi_conversationsArgs
    ai_entity_memory?: boolean | UsersCountOutputTypeCountAi_entity_memoryArgs
    ai_session_memory?: boolean | UsersCountOutputTypeCountAi_session_memoryArgs
    newsletter_subscriptions?: boolean | UsersCountOutputTypeCountNewsletter_subscriptionsArgs
    user_activity?: boolean | UsersCountOutputTypeCountUser_activityArgs
    user_article_stars?: boolean | UsersCountOutputTypeCountUser_article_starsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountActivity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activity_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_assistant_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_assistant_configWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_conversationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_entity_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_entity_memoryWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAi_session_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_session_memoryWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNewsletter_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_subscriptionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_activityWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_article_starsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_article_starsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activity_logs
   */

  export type AggregateActivity_logs = {
    _count: Activity_logsCountAggregateOutputType | null
    _avg: Activity_logsAvgAggregateOutputType | null
    _sum: Activity_logsSumAggregateOutputType | null
    _min: Activity_logsMinAggregateOutputType | null
    _max: Activity_logsMaxAggregateOutputType | null
  }

  export type Activity_logsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Activity_logsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Activity_logsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    details: string | null
    ip_address: string | null
    timestamp: Date | null
  }

  export type Activity_logsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    details: string | null
    ip_address: string | null
    timestamp: Date | null
  }

  export type Activity_logsCountAggregateOutputType = {
    id: number
    user_id: number
    action: number
    details: number
    ip_address: number
    timestamp: number
    _all: number
  }


  export type Activity_logsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Activity_logsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Activity_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    details?: true
    ip_address?: true
    timestamp?: true
  }

  export type Activity_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    details?: true
    ip_address?: true
    timestamp?: true
  }

  export type Activity_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    details?: true
    ip_address?: true
    timestamp?: true
    _all?: true
  }

  export type Activity_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity_logs to aggregate.
     */
    where?: activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logsOrderByWithRelationInput | activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activity_logs
    **/
    _count?: true | Activity_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Activity_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Activity_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Activity_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Activity_logsMaxAggregateInputType
  }

  export type GetActivity_logsAggregateType<T extends Activity_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity_logs[P]>
      : GetScalarType<T[P], AggregateActivity_logs[P]>
  }




  export type activity_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activity_logsWhereInput
    orderBy?: activity_logsOrderByWithAggregationInput | activity_logsOrderByWithAggregationInput[]
    by: Activity_logsScalarFieldEnum[] | Activity_logsScalarFieldEnum
    having?: activity_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Activity_logsCountAggregateInputType | true
    _avg?: Activity_logsAvgAggregateInputType
    _sum?: Activity_logsSumAggregateInputType
    _min?: Activity_logsMinAggregateInputType
    _max?: Activity_logsMaxAggregateInputType
  }

  export type Activity_logsGroupByOutputType = {
    id: number
    user_id: number | null
    action: string
    details: string | null
    ip_address: string | null
    timestamp: Date | null
    _count: Activity_logsCountAggregateOutputType | null
    _avg: Activity_logsAvgAggregateOutputType | null
    _sum: Activity_logsSumAggregateOutputType | null
    _min: Activity_logsMinAggregateOutputType | null
    _max: Activity_logsMaxAggregateOutputType | null
  }

  type GetActivity_logsGroupByPayload<T extends activity_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Activity_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Activity_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Activity_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Activity_logsGroupByOutputType[P]>
        }
      >
    >


  export type activity_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    details?: boolean
    ip_address?: boolean
    timestamp?: boolean
    users?: boolean | activity_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["activity_logs"]>

  export type activity_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    details?: boolean
    ip_address?: boolean
    timestamp?: boolean
    users?: boolean | activity_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["activity_logs"]>

  export type activity_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    action?: boolean
    details?: boolean
    ip_address?: boolean
    timestamp?: boolean
  }

  export type activity_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | activity_logs$usersArgs<ExtArgs>
  }
  export type activity_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | activity_logs$usersArgs<ExtArgs>
  }

  export type $activity_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activity_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      action: string
      details: string | null
      ip_address: string | null
      timestamp: Date | null
    }, ExtArgs["result"]["activity_logs"]>
    composites: {}
  }

  type activity_logsGetPayload<S extends boolean | null | undefined | activity_logsDefaultArgs> = $Result.GetResult<Prisma.$activity_logsPayload, S>

  type activity_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<activity_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Activity_logsCountAggregateInputType | true
    }

  export interface activity_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activity_logs'], meta: { name: 'activity_logs' } }
    /**
     * Find zero or one Activity_logs that matches the filter.
     * @param {activity_logsFindUniqueArgs} args - Arguments to find a Activity_logs
     * @example
     * // Get one Activity_logs
     * const activity_logs = await prisma.activity_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activity_logsFindUniqueArgs>(args: SelectSubset<T, activity_logsFindUniqueArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {activity_logsFindUniqueOrThrowArgs} args - Arguments to find a Activity_logs
     * @example
     * // Get one Activity_logs
     * const activity_logs = await prisma.activity_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activity_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, activity_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsFindFirstArgs} args - Arguments to find a Activity_logs
     * @example
     * // Get one Activity_logs
     * const activity_logs = await prisma.activity_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activity_logsFindFirstArgs>(args?: SelectSubset<T, activity_logsFindFirstArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsFindFirstOrThrowArgs} args - Arguments to find a Activity_logs
     * @example
     * // Get one Activity_logs
     * const activity_logs = await prisma.activity_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activity_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, activity_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activity_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activity_logs
     * const activity_logs = await prisma.activity_logs.findMany()
     * 
     * // Get first 10 Activity_logs
     * const activity_logs = await prisma.activity_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activity_logsWithIdOnly = await prisma.activity_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activity_logsFindManyArgs>(args?: SelectSubset<T, activity_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity_logs.
     * @param {activity_logsCreateArgs} args - Arguments to create a Activity_logs.
     * @example
     * // Create one Activity_logs
     * const Activity_logs = await prisma.activity_logs.create({
     *   data: {
     *     // ... data to create a Activity_logs
     *   }
     * })
     * 
     */
    create<T extends activity_logsCreateArgs>(args: SelectSubset<T, activity_logsCreateArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activity_logs.
     * @param {activity_logsCreateManyArgs} args - Arguments to create many Activity_logs.
     * @example
     * // Create many Activity_logs
     * const activity_logs = await prisma.activity_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activity_logsCreateManyArgs>(args?: SelectSubset<T, activity_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activity_logs and returns the data saved in the database.
     * @param {activity_logsCreateManyAndReturnArgs} args - Arguments to create many Activity_logs.
     * @example
     * // Create many Activity_logs
     * const activity_logs = await prisma.activity_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activity_logs and only return the `id`
     * const activity_logsWithIdOnly = await prisma.activity_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activity_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, activity_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity_logs.
     * @param {activity_logsDeleteArgs} args - Arguments to delete one Activity_logs.
     * @example
     * // Delete one Activity_logs
     * const Activity_logs = await prisma.activity_logs.delete({
     *   where: {
     *     // ... filter to delete one Activity_logs
     *   }
     * })
     * 
     */
    delete<T extends activity_logsDeleteArgs>(args: SelectSubset<T, activity_logsDeleteArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity_logs.
     * @param {activity_logsUpdateArgs} args - Arguments to update one Activity_logs.
     * @example
     * // Update one Activity_logs
     * const activity_logs = await prisma.activity_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activity_logsUpdateArgs>(args: SelectSubset<T, activity_logsUpdateArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activity_logs.
     * @param {activity_logsDeleteManyArgs} args - Arguments to filter Activity_logs to delete.
     * @example
     * // Delete a few Activity_logs
     * const { count } = await prisma.activity_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activity_logsDeleteManyArgs>(args?: SelectSubset<T, activity_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activity_logs
     * const activity_logs = await prisma.activity_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activity_logsUpdateManyArgs>(args: SelectSubset<T, activity_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity_logs.
     * @param {activity_logsUpsertArgs} args - Arguments to update or create a Activity_logs.
     * @example
     * // Update or create a Activity_logs
     * const activity_logs = await prisma.activity_logs.upsert({
     *   create: {
     *     // ... data to create a Activity_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity_logs we want to update
     *   }
     * })
     */
    upsert<T extends activity_logsUpsertArgs>(args: SelectSubset<T, activity_logsUpsertArgs<ExtArgs>>): Prisma__activity_logsClient<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsCountArgs} args - Arguments to filter Activity_logs to count.
     * @example
     * // Count the number of Activity_logs
     * const count = await prisma.activity_logs.count({
     *   where: {
     *     // ... the filter for the Activity_logs we want to count
     *   }
     * })
    **/
    count<T extends activity_logsCountArgs>(
      args?: Subset<T, activity_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Activity_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Activity_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Activity_logsAggregateArgs>(args: Subset<T, Activity_logsAggregateArgs>): Prisma.PrismaPromise<GetActivity_logsAggregateType<T>>

    /**
     * Group by Activity_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activity_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activity_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activity_logsGroupByArgs['orderBy'] }
        : { orderBy?: activity_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activity_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivity_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activity_logs model
   */
  readonly fields: activity_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activity_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activity_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends activity_logs$usersArgs<ExtArgs> = {}>(args?: Subset<T, activity_logs$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activity_logs model
   */ 
  interface activity_logsFieldRefs {
    readonly id: FieldRef<"activity_logs", 'Int'>
    readonly user_id: FieldRef<"activity_logs", 'Int'>
    readonly action: FieldRef<"activity_logs", 'String'>
    readonly details: FieldRef<"activity_logs", 'String'>
    readonly ip_address: FieldRef<"activity_logs", 'String'>
    readonly timestamp: FieldRef<"activity_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activity_logs findUnique
   */
  export type activity_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where: activity_logsWhereUniqueInput
  }

  /**
   * activity_logs findUniqueOrThrow
   */
  export type activity_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where: activity_logsWhereUniqueInput
  }

  /**
   * activity_logs findFirst
   */
  export type activity_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where?: activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logsOrderByWithRelationInput | activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Activity_logsScalarFieldEnum | Activity_logsScalarFieldEnum[]
  }

  /**
   * activity_logs findFirstOrThrow
   */
  export type activity_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where?: activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logsOrderByWithRelationInput | activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activity_logs.
     */
    cursor?: activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activity_logs.
     */
    distinct?: Activity_logsScalarFieldEnum | Activity_logsScalarFieldEnum[]
  }

  /**
   * activity_logs findMany
   */
  export type activity_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter, which activity_logs to fetch.
     */
    where?: activity_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activity_logs to fetch.
     */
    orderBy?: activity_logsOrderByWithRelationInput | activity_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activity_logs.
     */
    cursor?: activity_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activity_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activity_logs.
     */
    skip?: number
    distinct?: Activity_logsScalarFieldEnum | Activity_logsScalarFieldEnum[]
  }

  /**
   * activity_logs create
   */
  export type activity_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a activity_logs.
     */
    data: XOR<activity_logsCreateInput, activity_logsUncheckedCreateInput>
  }

  /**
   * activity_logs createMany
   */
  export type activity_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activity_logs.
     */
    data: activity_logsCreateManyInput | activity_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activity_logs createManyAndReturn
   */
  export type activity_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many activity_logs.
     */
    data: activity_logsCreateManyInput | activity_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activity_logs update
   */
  export type activity_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a activity_logs.
     */
    data: XOR<activity_logsUpdateInput, activity_logsUncheckedUpdateInput>
    /**
     * Choose, which activity_logs to update.
     */
    where: activity_logsWhereUniqueInput
  }

  /**
   * activity_logs updateMany
   */
  export type activity_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activity_logs.
     */
    data: XOR<activity_logsUpdateManyMutationInput, activity_logsUncheckedUpdateManyInput>
    /**
     * Filter which activity_logs to update
     */
    where?: activity_logsWhereInput
  }

  /**
   * activity_logs upsert
   */
  export type activity_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the activity_logs to update in case it exists.
     */
    where: activity_logsWhereUniqueInput
    /**
     * In case the activity_logs found by the `where` argument doesn't exist, create a new activity_logs with this data.
     */
    create: XOR<activity_logsCreateInput, activity_logsUncheckedCreateInput>
    /**
     * In case the activity_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activity_logsUpdateInput, activity_logsUncheckedUpdateInput>
  }

  /**
   * activity_logs delete
   */
  export type activity_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    /**
     * Filter which activity_logs to delete.
     */
    where: activity_logsWhereUniqueInput
  }

  /**
   * activity_logs deleteMany
   */
  export type activity_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity_logs to delete
     */
    where?: activity_logsWhereInput
  }

  /**
   * activity_logs.users
   */
  export type activity_logs$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * activity_logs without action
   */
  export type activity_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
  }


  /**
   * Model activitylog
   */

  export type AggregateActivitylog = {
    _count: ActivitylogCountAggregateOutputType | null
    _avg: ActivitylogAvgAggregateOutputType | null
    _sum: ActivitylogSumAggregateOutputType | null
    _min: ActivitylogMinAggregateOutputType | null
    _max: ActivitylogMaxAggregateOutputType | null
  }

  export type ActivitylogAvgAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type ActivitylogSumAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type ActivitylogMinAggregateOutputType = {
    user_id: number | null
    action: string | null
    resource: string | null
    resource_id: string | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    status: string | null
    error: string | null
    request_id: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitylogMaxAggregateOutputType = {
    user_id: number | null
    action: string | null
    resource: string | null
    resource_id: string | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    status: string | null
    error: string | null
    request_id: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivitylogCountAggregateOutputType = {
    user_id: number
    action: number
    resource: number
    resource_id: number
    details: number
    ip_address: number
    user_agent: number
    status: number
    error: number
    request_id: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivitylogAvgAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type ActivitylogSumAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type ActivitylogMinAggregateInputType = {
    user_id?: true
    action?: true
    resource?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    status?: true
    error?: true
    request_id?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitylogMaxAggregateInputType = {
    user_id?: true
    action?: true
    resource?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    status?: true
    error?: true
    request_id?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivitylogCountAggregateInputType = {
    user_id?: true
    action?: true
    resource?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    status?: true
    error?: true
    request_id?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivitylogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitylog to aggregate.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activitylogs
    **/
    _count?: true | ActivitylogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivitylogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitylogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitylogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitylogMaxAggregateInputType
  }

  export type GetActivitylogAggregateType<T extends ActivitylogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivitylog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivitylog[P]>
      : GetScalarType<T[P], AggregateActivitylog[P]>
  }




  export type activitylogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitylogWhereInput
    orderBy?: activitylogOrderByWithAggregationInput | activitylogOrderByWithAggregationInput[]
    by: ActivitylogScalarFieldEnum[] | ActivitylogScalarFieldEnum
    having?: activitylogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitylogCountAggregateInputType | true
    _avg?: ActivitylogAvgAggregateInputType
    _sum?: ActivitylogSumAggregateInputType
    _min?: ActivitylogMinAggregateInputType
    _max?: ActivitylogMaxAggregateInputType
  }

  export type ActivitylogGroupByOutputType = {
    user_id: number | null
    action: string
    resource: string | null
    resource_id: string | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    status: string
    error: string | null
    request_id: string | null
    id: number
    created_at: Date
    updated_at: Date
    _count: ActivitylogCountAggregateOutputType | null
    _avg: ActivitylogAvgAggregateOutputType | null
    _sum: ActivitylogSumAggregateOutputType | null
    _min: ActivitylogMinAggregateOutputType | null
    _max: ActivitylogMaxAggregateOutputType | null
  }

  type GetActivitylogGroupByPayload<T extends activitylogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivitylogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitylogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitylogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitylogGroupByOutputType[P]>
        }
      >
    >


  export type activitylogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    action?: boolean
    resource?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    error?: boolean
    request_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | activitylog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activitylog"]>

  export type activitylogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    action?: boolean
    resource?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    error?: boolean
    request_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | activitylog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activitylog"]>

  export type activitylogSelectScalar = {
    user_id?: boolean
    action?: boolean
    resource?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status?: boolean
    error?: boolean
    request_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type activitylogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activitylog$userArgs<ExtArgs>
  }
  export type activitylogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | activitylog$userArgs<ExtArgs>
  }

  export type $activitylogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activitylog"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number | null
      action: string
      resource: string | null
      resource_id: string | null
      details: string | null
      ip_address: string | null
      user_agent: string | null
      status: string
      error: string | null
      request_id: string | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activitylog"]>
    composites: {}
  }

  type activitylogGetPayload<S extends boolean | null | undefined | activitylogDefaultArgs> = $Result.GetResult<Prisma.$activitylogPayload, S>

  type activitylogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<activitylogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivitylogCountAggregateInputType | true
    }

  export interface activitylogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activitylog'], meta: { name: 'activitylog' } }
    /**
     * Find zero or one Activitylog that matches the filter.
     * @param {activitylogFindUniqueArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activitylogFindUniqueArgs>(args: SelectSubset<T, activitylogFindUniqueArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activitylog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {activitylogFindUniqueOrThrowArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activitylogFindUniqueOrThrowArgs>(args: SelectSubset<T, activitylogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activitylog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindFirstArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activitylogFindFirstArgs>(args?: SelectSubset<T, activitylogFindFirstArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activitylog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindFirstOrThrowArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activitylogFindFirstOrThrowArgs>(args?: SelectSubset<T, activitylogFindFirstOrThrowArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activitylogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activitylogs
     * const activitylogs = await prisma.activitylog.findMany()
     * 
     * // Get first 10 Activitylogs
     * const activitylogs = await prisma.activitylog.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const activitylogWithUser_idOnly = await prisma.activitylog.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends activitylogFindManyArgs>(args?: SelectSubset<T, activitylogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activitylog.
     * @param {activitylogCreateArgs} args - Arguments to create a Activitylog.
     * @example
     * // Create one Activitylog
     * const Activitylog = await prisma.activitylog.create({
     *   data: {
     *     // ... data to create a Activitylog
     *   }
     * })
     * 
     */
    create<T extends activitylogCreateArgs>(args: SelectSubset<T, activitylogCreateArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activitylogs.
     * @param {activitylogCreateManyArgs} args - Arguments to create many Activitylogs.
     * @example
     * // Create many Activitylogs
     * const activitylog = await prisma.activitylog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activitylogCreateManyArgs>(args?: SelectSubset<T, activitylogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activitylogs and returns the data saved in the database.
     * @param {activitylogCreateManyAndReturnArgs} args - Arguments to create many Activitylogs.
     * @example
     * // Create many Activitylogs
     * const activitylog = await prisma.activitylog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activitylogs and only return the `user_id`
     * const activitylogWithUser_idOnly = await prisma.activitylog.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activitylogCreateManyAndReturnArgs>(args?: SelectSubset<T, activitylogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activitylog.
     * @param {activitylogDeleteArgs} args - Arguments to delete one Activitylog.
     * @example
     * // Delete one Activitylog
     * const Activitylog = await prisma.activitylog.delete({
     *   where: {
     *     // ... filter to delete one Activitylog
     *   }
     * })
     * 
     */
    delete<T extends activitylogDeleteArgs>(args: SelectSubset<T, activitylogDeleteArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activitylog.
     * @param {activitylogUpdateArgs} args - Arguments to update one Activitylog.
     * @example
     * // Update one Activitylog
     * const activitylog = await prisma.activitylog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activitylogUpdateArgs>(args: SelectSubset<T, activitylogUpdateArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activitylogs.
     * @param {activitylogDeleteManyArgs} args - Arguments to filter Activitylogs to delete.
     * @example
     * // Delete a few Activitylogs
     * const { count } = await prisma.activitylog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activitylogDeleteManyArgs>(args?: SelectSubset<T, activitylogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activitylogs
     * const activitylog = await prisma.activitylog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activitylogUpdateManyArgs>(args: SelectSubset<T, activitylogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activitylog.
     * @param {activitylogUpsertArgs} args - Arguments to update or create a Activitylog.
     * @example
     * // Update or create a Activitylog
     * const activitylog = await prisma.activitylog.upsert({
     *   create: {
     *     // ... data to create a Activitylog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activitylog we want to update
     *   }
     * })
     */
    upsert<T extends activitylogUpsertArgs>(args: SelectSubset<T, activitylogUpsertArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogCountArgs} args - Arguments to filter Activitylogs to count.
     * @example
     * // Count the number of Activitylogs
     * const count = await prisma.activitylog.count({
     *   where: {
     *     // ... the filter for the Activitylogs we want to count
     *   }
     * })
    **/
    count<T extends activitylogCountArgs>(
      args?: Subset<T, activitylogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitylogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitylogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitylogAggregateArgs>(args: Subset<T, ActivitylogAggregateArgs>): Prisma.PrismaPromise<GetActivitylogAggregateType<T>>

    /**
     * Group by Activitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activitylogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activitylogGroupByArgs['orderBy'] }
        : { orderBy?: activitylogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activitylogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitylogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activitylog model
   */
  readonly fields: activitylogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activitylog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activitylogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends activitylog$userArgs<ExtArgs> = {}>(args?: Subset<T, activitylog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activitylog model
   */ 
  interface activitylogFieldRefs {
    readonly user_id: FieldRef<"activitylog", 'Int'>
    readonly action: FieldRef<"activitylog", 'String'>
    readonly resource: FieldRef<"activitylog", 'String'>
    readonly resource_id: FieldRef<"activitylog", 'String'>
    readonly details: FieldRef<"activitylog", 'String'>
    readonly ip_address: FieldRef<"activitylog", 'String'>
    readonly user_agent: FieldRef<"activitylog", 'String'>
    readonly status: FieldRef<"activitylog", 'String'>
    readonly error: FieldRef<"activitylog", 'String'>
    readonly request_id: FieldRef<"activitylog", 'String'>
    readonly id: FieldRef<"activitylog", 'Int'>
    readonly created_at: FieldRef<"activitylog", 'DateTime'>
    readonly updated_at: FieldRef<"activitylog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activitylog findUnique
   */
  export type activitylogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog findUniqueOrThrow
   */
  export type activitylogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog findFirst
   */
  export type activitylogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitylogs.
     */
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog findFirstOrThrow
   */
  export type activitylogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitylogs.
     */
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog findMany
   */
  export type activitylogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylogs to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog create
   */
  export type activitylogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The data needed to create a activitylog.
     */
    data: XOR<activitylogCreateInput, activitylogUncheckedCreateInput>
  }

  /**
   * activitylog createMany
   */
  export type activitylogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activitylogs.
     */
    data: activitylogCreateManyInput | activitylogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activitylog createManyAndReturn
   */
  export type activitylogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many activitylogs.
     */
    data: activitylogCreateManyInput | activitylogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activitylog update
   */
  export type activitylogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The data needed to update a activitylog.
     */
    data: XOR<activitylogUpdateInput, activitylogUncheckedUpdateInput>
    /**
     * Choose, which activitylog to update.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog updateMany
   */
  export type activitylogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activitylogs.
     */
    data: XOR<activitylogUpdateManyMutationInput, activitylogUncheckedUpdateManyInput>
    /**
     * Filter which activitylogs to update
     */
    where?: activitylogWhereInput
  }

  /**
   * activitylog upsert
   */
  export type activitylogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The filter to search for the activitylog to update in case it exists.
     */
    where: activitylogWhereUniqueInput
    /**
     * In case the activitylog found by the `where` argument doesn't exist, create a new activitylog with this data.
     */
    create: XOR<activitylogCreateInput, activitylogUncheckedCreateInput>
    /**
     * In case the activitylog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activitylogUpdateInput, activitylogUncheckedUpdateInput>
  }

  /**
   * activitylog delete
   */
  export type activitylogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter which activitylog to delete.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog deleteMany
   */
  export type activitylogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitylogs to delete
     */
    where?: activitylogWhereInput
  }

  /**
   * activitylog.user
   */
  export type activitylog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * activitylog without action
   */
  export type activitylogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
  }


  /**
   * Model ai_assistant_config
   */

  export type AggregateAi_assistant_config = {
    _count: Ai_assistant_configCountAggregateOutputType | null
    _avg: Ai_assistant_configAvgAggregateOutputType | null
    _sum: Ai_assistant_configSumAggregateOutputType | null
    _min: Ai_assistant_configMinAggregateOutputType | null
    _max: Ai_assistant_configMaxAggregateOutputType | null
  }

  export type Ai_assistant_configAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Ai_assistant_configSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Ai_assistant_configMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    config_key: string | null
    config_value: string | null
    updated_at: Date | null
  }

  export type Ai_assistant_configMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    config_key: string | null
    config_value: string | null
    updated_at: Date | null
  }

  export type Ai_assistant_configCountAggregateOutputType = {
    id: number
    user_id: number
    config_key: number
    config_value: number
    updated_at: number
    _all: number
  }


  export type Ai_assistant_configAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Ai_assistant_configSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Ai_assistant_configMinAggregateInputType = {
    id?: true
    user_id?: true
    config_key?: true
    config_value?: true
    updated_at?: true
  }

  export type Ai_assistant_configMaxAggregateInputType = {
    id?: true
    user_id?: true
    config_key?: true
    config_value?: true
    updated_at?: true
  }

  export type Ai_assistant_configCountAggregateInputType = {
    id?: true
    user_id?: true
    config_key?: true
    config_value?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_assistant_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_assistant_config to aggregate.
     */
    where?: ai_assistant_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assistant_configs to fetch.
     */
    orderBy?: ai_assistant_configOrderByWithRelationInput | ai_assistant_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_assistant_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assistant_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assistant_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_assistant_configs
    **/
    _count?: true | Ai_assistant_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_assistant_configAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_assistant_configSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_assistant_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_assistant_configMaxAggregateInputType
  }

  export type GetAi_assistant_configAggregateType<T extends Ai_assistant_configAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_assistant_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_assistant_config[P]>
      : GetScalarType<T[P], AggregateAi_assistant_config[P]>
  }




  export type ai_assistant_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_assistant_configWhereInput
    orderBy?: ai_assistant_configOrderByWithAggregationInput | ai_assistant_configOrderByWithAggregationInput[]
    by: Ai_assistant_configScalarFieldEnum[] | Ai_assistant_configScalarFieldEnum
    having?: ai_assistant_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_assistant_configCountAggregateInputType | true
    _avg?: Ai_assistant_configAvgAggregateInputType
    _sum?: Ai_assistant_configSumAggregateInputType
    _min?: Ai_assistant_configMinAggregateInputType
    _max?: Ai_assistant_configMaxAggregateInputType
  }

  export type Ai_assistant_configGroupByOutputType = {
    id: number
    user_id: number | null
    config_key: string
    config_value: string
    updated_at: Date | null
    _count: Ai_assistant_configCountAggregateOutputType | null
    _avg: Ai_assistant_configAvgAggregateOutputType | null
    _sum: Ai_assistant_configSumAggregateOutputType | null
    _min: Ai_assistant_configMinAggregateOutputType | null
    _max: Ai_assistant_configMaxAggregateOutputType | null
  }

  type GetAi_assistant_configGroupByPayload<T extends ai_assistant_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_assistant_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_assistant_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_assistant_configGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_assistant_configGroupByOutputType[P]>
        }
      >
    >


  export type ai_assistant_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    config_key?: boolean
    config_value?: boolean
    updated_at?: boolean
    users?: boolean | ai_assistant_config$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_assistant_config"]>

  export type ai_assistant_configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    config_key?: boolean
    config_value?: boolean
    updated_at?: boolean
    users?: boolean | ai_assistant_config$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_assistant_config"]>

  export type ai_assistant_configSelectScalar = {
    id?: boolean
    user_id?: boolean
    config_key?: boolean
    config_value?: boolean
    updated_at?: boolean
  }

  export type ai_assistant_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_assistant_config$usersArgs<ExtArgs>
  }
  export type ai_assistant_configIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_assistant_config$usersArgs<ExtArgs>
  }

  export type $ai_assistant_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_assistant_config"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      config_key: string
      config_value: string
      updated_at: Date | null
    }, ExtArgs["result"]["ai_assistant_config"]>
    composites: {}
  }

  type ai_assistant_configGetPayload<S extends boolean | null | undefined | ai_assistant_configDefaultArgs> = $Result.GetResult<Prisma.$ai_assistant_configPayload, S>

  type ai_assistant_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ai_assistant_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ai_assistant_configCountAggregateInputType | true
    }

  export interface ai_assistant_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_assistant_config'], meta: { name: 'ai_assistant_config' } }
    /**
     * Find zero or one Ai_assistant_config that matches the filter.
     * @param {ai_assistant_configFindUniqueArgs} args - Arguments to find a Ai_assistant_config
     * @example
     * // Get one Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_assistant_configFindUniqueArgs>(args: SelectSubset<T, ai_assistant_configFindUniqueArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ai_assistant_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ai_assistant_configFindUniqueOrThrowArgs} args - Arguments to find a Ai_assistant_config
     * @example
     * // Get one Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_assistant_configFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_assistant_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ai_assistant_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configFindFirstArgs} args - Arguments to find a Ai_assistant_config
     * @example
     * // Get one Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_assistant_configFindFirstArgs>(args?: SelectSubset<T, ai_assistant_configFindFirstArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ai_assistant_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configFindFirstOrThrowArgs} args - Arguments to find a Ai_assistant_config
     * @example
     * // Get one Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_assistant_configFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_assistant_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ai_assistant_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_assistant_configs
     * const ai_assistant_configs = await prisma.ai_assistant_config.findMany()
     * 
     * // Get first 10 Ai_assistant_configs
     * const ai_assistant_configs = await prisma.ai_assistant_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_assistant_configWithIdOnly = await prisma.ai_assistant_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_assistant_configFindManyArgs>(args?: SelectSubset<T, ai_assistant_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ai_assistant_config.
     * @param {ai_assistant_configCreateArgs} args - Arguments to create a Ai_assistant_config.
     * @example
     * // Create one Ai_assistant_config
     * const Ai_assistant_config = await prisma.ai_assistant_config.create({
     *   data: {
     *     // ... data to create a Ai_assistant_config
     *   }
     * })
     * 
     */
    create<T extends ai_assistant_configCreateArgs>(args: SelectSubset<T, ai_assistant_configCreateArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ai_assistant_configs.
     * @param {ai_assistant_configCreateManyArgs} args - Arguments to create many Ai_assistant_configs.
     * @example
     * // Create many Ai_assistant_configs
     * const ai_assistant_config = await prisma.ai_assistant_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_assistant_configCreateManyArgs>(args?: SelectSubset<T, ai_assistant_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_assistant_configs and returns the data saved in the database.
     * @param {ai_assistant_configCreateManyAndReturnArgs} args - Arguments to create many Ai_assistant_configs.
     * @example
     * // Create many Ai_assistant_configs
     * const ai_assistant_config = await prisma.ai_assistant_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_assistant_configs and only return the `id`
     * const ai_assistant_configWithIdOnly = await prisma.ai_assistant_config.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_assistant_configCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_assistant_configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ai_assistant_config.
     * @param {ai_assistant_configDeleteArgs} args - Arguments to delete one Ai_assistant_config.
     * @example
     * // Delete one Ai_assistant_config
     * const Ai_assistant_config = await prisma.ai_assistant_config.delete({
     *   where: {
     *     // ... filter to delete one Ai_assistant_config
     *   }
     * })
     * 
     */
    delete<T extends ai_assistant_configDeleteArgs>(args: SelectSubset<T, ai_assistant_configDeleteArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ai_assistant_config.
     * @param {ai_assistant_configUpdateArgs} args - Arguments to update one Ai_assistant_config.
     * @example
     * // Update one Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_assistant_configUpdateArgs>(args: SelectSubset<T, ai_assistant_configUpdateArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ai_assistant_configs.
     * @param {ai_assistant_configDeleteManyArgs} args - Arguments to filter Ai_assistant_configs to delete.
     * @example
     * // Delete a few Ai_assistant_configs
     * const { count } = await prisma.ai_assistant_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_assistant_configDeleteManyArgs>(args?: SelectSubset<T, ai_assistant_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_assistant_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_assistant_configs
     * const ai_assistant_config = await prisma.ai_assistant_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_assistant_configUpdateManyArgs>(args: SelectSubset<T, ai_assistant_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_assistant_config.
     * @param {ai_assistant_configUpsertArgs} args - Arguments to update or create a Ai_assistant_config.
     * @example
     * // Update or create a Ai_assistant_config
     * const ai_assistant_config = await prisma.ai_assistant_config.upsert({
     *   create: {
     *     // ... data to create a Ai_assistant_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_assistant_config we want to update
     *   }
     * })
     */
    upsert<T extends ai_assistant_configUpsertArgs>(args: SelectSubset<T, ai_assistant_configUpsertArgs<ExtArgs>>): Prisma__ai_assistant_configClient<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ai_assistant_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configCountArgs} args - Arguments to filter Ai_assistant_configs to count.
     * @example
     * // Count the number of Ai_assistant_configs
     * const count = await prisma.ai_assistant_config.count({
     *   where: {
     *     // ... the filter for the Ai_assistant_configs we want to count
     *   }
     * })
    **/
    count<T extends ai_assistant_configCountArgs>(
      args?: Subset<T, ai_assistant_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_assistant_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_assistant_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_assistant_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_assistant_configAggregateArgs>(args: Subset<T, Ai_assistant_configAggregateArgs>): Prisma.PrismaPromise<GetAi_assistant_configAggregateType<T>>

    /**
     * Group by Ai_assistant_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_assistant_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_assistant_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_assistant_configGroupByArgs['orderBy'] }
        : { orderBy?: ai_assistant_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_assistant_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_assistant_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_assistant_config model
   */
  readonly fields: ai_assistant_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_assistant_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_assistant_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ai_assistant_config$usersArgs<ExtArgs> = {}>(args?: Subset<T, ai_assistant_config$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_assistant_config model
   */ 
  interface ai_assistant_configFieldRefs {
    readonly id: FieldRef<"ai_assistant_config", 'Int'>
    readonly user_id: FieldRef<"ai_assistant_config", 'Int'>
    readonly config_key: FieldRef<"ai_assistant_config", 'String'>
    readonly config_value: FieldRef<"ai_assistant_config", 'String'>
    readonly updated_at: FieldRef<"ai_assistant_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_assistant_config findUnique
   */
  export type ai_assistant_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter, which ai_assistant_config to fetch.
     */
    where: ai_assistant_configWhereUniqueInput
  }

  /**
   * ai_assistant_config findUniqueOrThrow
   */
  export type ai_assistant_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter, which ai_assistant_config to fetch.
     */
    where: ai_assistant_configWhereUniqueInput
  }

  /**
   * ai_assistant_config findFirst
   */
  export type ai_assistant_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter, which ai_assistant_config to fetch.
     */
    where?: ai_assistant_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assistant_configs to fetch.
     */
    orderBy?: ai_assistant_configOrderByWithRelationInput | ai_assistant_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_assistant_configs.
     */
    cursor?: ai_assistant_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assistant_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assistant_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_assistant_configs.
     */
    distinct?: Ai_assistant_configScalarFieldEnum | Ai_assistant_configScalarFieldEnum[]
  }

  /**
   * ai_assistant_config findFirstOrThrow
   */
  export type ai_assistant_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter, which ai_assistant_config to fetch.
     */
    where?: ai_assistant_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assistant_configs to fetch.
     */
    orderBy?: ai_assistant_configOrderByWithRelationInput | ai_assistant_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_assistant_configs.
     */
    cursor?: ai_assistant_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assistant_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assistant_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_assistant_configs.
     */
    distinct?: Ai_assistant_configScalarFieldEnum | Ai_assistant_configScalarFieldEnum[]
  }

  /**
   * ai_assistant_config findMany
   */
  export type ai_assistant_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter, which ai_assistant_configs to fetch.
     */
    where?: ai_assistant_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_assistant_configs to fetch.
     */
    orderBy?: ai_assistant_configOrderByWithRelationInput | ai_assistant_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_assistant_configs.
     */
    cursor?: ai_assistant_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_assistant_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_assistant_configs.
     */
    skip?: number
    distinct?: Ai_assistant_configScalarFieldEnum | Ai_assistant_configScalarFieldEnum[]
  }

  /**
   * ai_assistant_config create
   */
  export type ai_assistant_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_assistant_config.
     */
    data: XOR<ai_assistant_configCreateInput, ai_assistant_configUncheckedCreateInput>
  }

  /**
   * ai_assistant_config createMany
   */
  export type ai_assistant_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_assistant_configs.
     */
    data: ai_assistant_configCreateManyInput | ai_assistant_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_assistant_config createManyAndReturn
   */
  export type ai_assistant_configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ai_assistant_configs.
     */
    data: ai_assistant_configCreateManyInput | ai_assistant_configCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_assistant_config update
   */
  export type ai_assistant_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_assistant_config.
     */
    data: XOR<ai_assistant_configUpdateInput, ai_assistant_configUncheckedUpdateInput>
    /**
     * Choose, which ai_assistant_config to update.
     */
    where: ai_assistant_configWhereUniqueInput
  }

  /**
   * ai_assistant_config updateMany
   */
  export type ai_assistant_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_assistant_configs.
     */
    data: XOR<ai_assistant_configUpdateManyMutationInput, ai_assistant_configUncheckedUpdateManyInput>
    /**
     * Filter which ai_assistant_configs to update
     */
    where?: ai_assistant_configWhereInput
  }

  /**
   * ai_assistant_config upsert
   */
  export type ai_assistant_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_assistant_config to update in case it exists.
     */
    where: ai_assistant_configWhereUniqueInput
    /**
     * In case the ai_assistant_config found by the `where` argument doesn't exist, create a new ai_assistant_config with this data.
     */
    create: XOR<ai_assistant_configCreateInput, ai_assistant_configUncheckedCreateInput>
    /**
     * In case the ai_assistant_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_assistant_configUpdateInput, ai_assistant_configUncheckedUpdateInput>
  }

  /**
   * ai_assistant_config delete
   */
  export type ai_assistant_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    /**
     * Filter which ai_assistant_config to delete.
     */
    where: ai_assistant_configWhereUniqueInput
  }

  /**
   * ai_assistant_config deleteMany
   */
  export type ai_assistant_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_assistant_configs to delete
     */
    where?: ai_assistant_configWhereInput
  }

  /**
   * ai_assistant_config.users
   */
  export type ai_assistant_config$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * ai_assistant_config without action
   */
  export type ai_assistant_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
  }


  /**
   * Model ai_conversations
   */

  export type AggregateAi_conversations = {
    _count: Ai_conversationsCountAggregateOutputType | null
    _avg: Ai_conversationsAvgAggregateOutputType | null
    _sum: Ai_conversationsSumAggregateOutputType | null
    _min: Ai_conversationsMinAggregateOutputType | null
    _max: Ai_conversationsMaxAggregateOutputType | null
  }

  export type Ai_conversationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    total_messages: number | null
    tokens_used: number | null
    cost_usd: Decimal | null
  }

  export type Ai_conversationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    total_messages: number | null
    tokens_used: number | null
    cost_usd: Decimal | null
  }

  export type Ai_conversationsMinAggregateOutputType = {
    id: number | null
    session_id: string | null
    user_id: number | null
    title: string | null
    summary: string | null
    total_messages: number | null
    tokens_used: number | null
    cost_usd: Decimal | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_conversationsMaxAggregateOutputType = {
    id: number | null
    session_id: string | null
    user_id: number | null
    title: string | null
    summary: string | null
    total_messages: number | null
    tokens_used: number | null
    cost_usd: Decimal | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_conversationsCountAggregateOutputType = {
    id: number
    session_id: number
    user_id: number
    title: number
    summary: number
    total_messages: number
    tokens_used: number
    cost_usd: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_conversationsAvgAggregateInputType = {
    id?: true
    user_id?: true
    total_messages?: true
    tokens_used?: true
    cost_usd?: true
  }

  export type Ai_conversationsSumAggregateInputType = {
    id?: true
    user_id?: true
    total_messages?: true
    tokens_used?: true
    cost_usd?: true
  }

  export type Ai_conversationsMinAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    title?: true
    summary?: true
    total_messages?: true
    tokens_used?: true
    cost_usd?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_conversationsMaxAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    title?: true
    summary?: true
    total_messages?: true
    tokens_used?: true
    cost_usd?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_conversationsCountAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    title?: true
    summary?: true
    total_messages?: true
    tokens_used?: true
    cost_usd?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_conversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_conversations to aggregate.
     */
    where?: ai_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_conversations to fetch.
     */
    orderBy?: ai_conversationsOrderByWithRelationInput | ai_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_conversations
    **/
    _count?: true | Ai_conversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_conversationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_conversationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_conversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_conversationsMaxAggregateInputType
  }

  export type GetAi_conversationsAggregateType<T extends Ai_conversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_conversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_conversations[P]>
      : GetScalarType<T[P], AggregateAi_conversations[P]>
  }




  export type ai_conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_conversationsWhereInput
    orderBy?: ai_conversationsOrderByWithAggregationInput | ai_conversationsOrderByWithAggregationInput[]
    by: Ai_conversationsScalarFieldEnum[] | Ai_conversationsScalarFieldEnum
    having?: ai_conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_conversationsCountAggregateInputType | true
    _avg?: Ai_conversationsAvgAggregateInputType
    _sum?: Ai_conversationsSumAggregateInputType
    _min?: Ai_conversationsMinAggregateInputType
    _max?: Ai_conversationsMaxAggregateInputType
  }

  export type Ai_conversationsGroupByOutputType = {
    id: number
    session_id: string
    user_id: number | null
    title: string | null
    summary: string | null
    total_messages: number | null
    tokens_used: number | null
    cost_usd: Decimal | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ai_conversationsCountAggregateOutputType | null
    _avg: Ai_conversationsAvgAggregateOutputType | null
    _sum: Ai_conversationsSumAggregateOutputType | null
    _min: Ai_conversationsMinAggregateOutputType | null
    _max: Ai_conversationsMaxAggregateOutputType | null
  }

  type GetAi_conversationsGroupByPayload<T extends ai_conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_conversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_conversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_conversationsGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_conversationsGroupByOutputType[P]>
        }
      >
    >


  export type ai_conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    title?: boolean
    summary?: boolean
    total_messages?: boolean
    tokens_used?: boolean
    cost_usd?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | ai_conversations$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_conversations"]>

  export type ai_conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    title?: boolean
    summary?: boolean
    total_messages?: boolean
    tokens_used?: boolean
    cost_usd?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | ai_conversations$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_conversations"]>

  export type ai_conversationsSelectScalar = {
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    title?: boolean
    summary?: boolean
    total_messages?: boolean
    tokens_used?: boolean
    cost_usd?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ai_conversationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_conversations$usersArgs<ExtArgs>
  }
  export type ai_conversationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_conversations$usersArgs<ExtArgs>
  }

  export type $ai_conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_conversations"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: string
      user_id: number | null
      title: string | null
      summary: string | null
      total_messages: number | null
      tokens_used: number | null
      cost_usd: Prisma.Decimal | null
      status: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ai_conversations"]>
    composites: {}
  }

  type ai_conversationsGetPayload<S extends boolean | null | undefined | ai_conversationsDefaultArgs> = $Result.GetResult<Prisma.$ai_conversationsPayload, S>

  type ai_conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ai_conversationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ai_conversationsCountAggregateInputType | true
    }

  export interface ai_conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_conversations'], meta: { name: 'ai_conversations' } }
    /**
     * Find zero or one Ai_conversations that matches the filter.
     * @param {ai_conversationsFindUniqueArgs} args - Arguments to find a Ai_conversations
     * @example
     * // Get one Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_conversationsFindUniqueArgs>(args: SelectSubset<T, ai_conversationsFindUniqueArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ai_conversations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ai_conversationsFindUniqueOrThrowArgs} args - Arguments to find a Ai_conversations
     * @example
     * // Get one Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ai_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsFindFirstArgs} args - Arguments to find a Ai_conversations
     * @example
     * // Get one Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_conversationsFindFirstArgs>(args?: SelectSubset<T, ai_conversationsFindFirstArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ai_conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsFindFirstOrThrowArgs} args - Arguments to find a Ai_conversations
     * @example
     * // Get one Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ai_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findMany()
     * 
     * // Get first 10 Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_conversationsWithIdOnly = await prisma.ai_conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_conversationsFindManyArgs>(args?: SelectSubset<T, ai_conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ai_conversations.
     * @param {ai_conversationsCreateArgs} args - Arguments to create a Ai_conversations.
     * @example
     * // Create one Ai_conversations
     * const Ai_conversations = await prisma.ai_conversations.create({
     *   data: {
     *     // ... data to create a Ai_conversations
     *   }
     * })
     * 
     */
    create<T extends ai_conversationsCreateArgs>(args: SelectSubset<T, ai_conversationsCreateArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ai_conversations.
     * @param {ai_conversationsCreateManyArgs} args - Arguments to create many Ai_conversations.
     * @example
     * // Create many Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_conversationsCreateManyArgs>(args?: SelectSubset<T, ai_conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_conversations and returns the data saved in the database.
     * @param {ai_conversationsCreateManyAndReturnArgs} args - Arguments to create many Ai_conversations.
     * @example
     * // Create many Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_conversations and only return the `id`
     * const ai_conversationsWithIdOnly = await prisma.ai_conversations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ai_conversations.
     * @param {ai_conversationsDeleteArgs} args - Arguments to delete one Ai_conversations.
     * @example
     * // Delete one Ai_conversations
     * const Ai_conversations = await prisma.ai_conversations.delete({
     *   where: {
     *     // ... filter to delete one Ai_conversations
     *   }
     * })
     * 
     */
    delete<T extends ai_conversationsDeleteArgs>(args: SelectSubset<T, ai_conversationsDeleteArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ai_conversations.
     * @param {ai_conversationsUpdateArgs} args - Arguments to update one Ai_conversations.
     * @example
     * // Update one Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_conversationsUpdateArgs>(args: SelectSubset<T, ai_conversationsUpdateArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ai_conversations.
     * @param {ai_conversationsDeleteManyArgs} args - Arguments to filter Ai_conversations to delete.
     * @example
     * // Delete a few Ai_conversations
     * const { count } = await prisma.ai_conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_conversationsDeleteManyArgs>(args?: SelectSubset<T, ai_conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_conversationsUpdateManyArgs>(args: SelectSubset<T, ai_conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_conversations.
     * @param {ai_conversationsUpsertArgs} args - Arguments to update or create a Ai_conversations.
     * @example
     * // Update or create a Ai_conversations
     * const ai_conversations = await prisma.ai_conversations.upsert({
     *   create: {
     *     // ... data to create a Ai_conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_conversations we want to update
     *   }
     * })
     */
    upsert<T extends ai_conversationsUpsertArgs>(args: SelectSubset<T, ai_conversationsUpsertArgs<ExtArgs>>): Prisma__ai_conversationsClient<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ai_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsCountArgs} args - Arguments to filter Ai_conversations to count.
     * @example
     * // Count the number of Ai_conversations
     * const count = await prisma.ai_conversations.count({
     *   where: {
     *     // ... the filter for the Ai_conversations we want to count
     *   }
     * })
    **/
    count<T extends ai_conversationsCountArgs>(
      args?: Subset<T, ai_conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_conversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_conversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_conversationsAggregateArgs>(args: Subset<T, Ai_conversationsAggregateArgs>): Prisma.PrismaPromise<GetAi_conversationsAggregateType<T>>

    /**
     * Group by Ai_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_conversationsGroupByArgs['orderBy'] }
        : { orderBy?: ai_conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_conversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_conversations model
   */
  readonly fields: ai_conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ai_conversations$usersArgs<ExtArgs> = {}>(args?: Subset<T, ai_conversations$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_conversations model
   */ 
  interface ai_conversationsFieldRefs {
    readonly id: FieldRef<"ai_conversations", 'Int'>
    readonly session_id: FieldRef<"ai_conversations", 'String'>
    readonly user_id: FieldRef<"ai_conversations", 'Int'>
    readonly title: FieldRef<"ai_conversations", 'String'>
    readonly summary: FieldRef<"ai_conversations", 'String'>
    readonly total_messages: FieldRef<"ai_conversations", 'Int'>
    readonly tokens_used: FieldRef<"ai_conversations", 'Int'>
    readonly cost_usd: FieldRef<"ai_conversations", 'Decimal'>
    readonly status: FieldRef<"ai_conversations", 'String'>
    readonly created_at: FieldRef<"ai_conversations", 'DateTime'>
    readonly updated_at: FieldRef<"ai_conversations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_conversations findUnique
   */
  export type ai_conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which ai_conversations to fetch.
     */
    where: ai_conversationsWhereUniqueInput
  }

  /**
   * ai_conversations findUniqueOrThrow
   */
  export type ai_conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which ai_conversations to fetch.
     */
    where: ai_conversationsWhereUniqueInput
  }

  /**
   * ai_conversations findFirst
   */
  export type ai_conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which ai_conversations to fetch.
     */
    where?: ai_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_conversations to fetch.
     */
    orderBy?: ai_conversationsOrderByWithRelationInput | ai_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_conversations.
     */
    cursor?: ai_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_conversations.
     */
    distinct?: Ai_conversationsScalarFieldEnum | Ai_conversationsScalarFieldEnum[]
  }

  /**
   * ai_conversations findFirstOrThrow
   */
  export type ai_conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which ai_conversations to fetch.
     */
    where?: ai_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_conversations to fetch.
     */
    orderBy?: ai_conversationsOrderByWithRelationInput | ai_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_conversations.
     */
    cursor?: ai_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_conversations.
     */
    distinct?: Ai_conversationsScalarFieldEnum | Ai_conversationsScalarFieldEnum[]
  }

  /**
   * ai_conversations findMany
   */
  export type ai_conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which ai_conversations to fetch.
     */
    where?: ai_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_conversations to fetch.
     */
    orderBy?: ai_conversationsOrderByWithRelationInput | ai_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_conversations.
     */
    cursor?: ai_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_conversations.
     */
    skip?: number
    distinct?: Ai_conversationsScalarFieldEnum | Ai_conversationsScalarFieldEnum[]
  }

  /**
   * ai_conversations create
   */
  export type ai_conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_conversations.
     */
    data: XOR<ai_conversationsCreateInput, ai_conversationsUncheckedCreateInput>
  }

  /**
   * ai_conversations createMany
   */
  export type ai_conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_conversations.
     */
    data: ai_conversationsCreateManyInput | ai_conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_conversations createManyAndReturn
   */
  export type ai_conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ai_conversations.
     */
    data: ai_conversationsCreateManyInput | ai_conversationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_conversations update
   */
  export type ai_conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_conversations.
     */
    data: XOR<ai_conversationsUpdateInput, ai_conversationsUncheckedUpdateInput>
    /**
     * Choose, which ai_conversations to update.
     */
    where: ai_conversationsWhereUniqueInput
  }

  /**
   * ai_conversations updateMany
   */
  export type ai_conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_conversations.
     */
    data: XOR<ai_conversationsUpdateManyMutationInput, ai_conversationsUncheckedUpdateManyInput>
    /**
     * Filter which ai_conversations to update
     */
    where?: ai_conversationsWhereInput
  }

  /**
   * ai_conversations upsert
   */
  export type ai_conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_conversations to update in case it exists.
     */
    where: ai_conversationsWhereUniqueInput
    /**
     * In case the ai_conversations found by the `where` argument doesn't exist, create a new ai_conversations with this data.
     */
    create: XOR<ai_conversationsCreateInput, ai_conversationsUncheckedCreateInput>
    /**
     * In case the ai_conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_conversationsUpdateInput, ai_conversationsUncheckedUpdateInput>
  }

  /**
   * ai_conversations delete
   */
  export type ai_conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    /**
     * Filter which ai_conversations to delete.
     */
    where: ai_conversationsWhereUniqueInput
  }

  /**
   * ai_conversations deleteMany
   */
  export type ai_conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_conversations to delete
     */
    where?: ai_conversationsWhereInput
  }

  /**
   * ai_conversations.users
   */
  export type ai_conversations$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * ai_conversations without action
   */
  export type ai_conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
  }


  /**
   * Model ai_entity_memory
   */

  export type AggregateAi_entity_memory = {
    _count: Ai_entity_memoryCountAggregateOutputType | null
    _avg: Ai_entity_memoryAvgAggregateOutputType | null
    _sum: Ai_entity_memorySumAggregateOutputType | null
    _min: Ai_entity_memoryMinAggregateOutputType | null
    _max: Ai_entity_memoryMaxAggregateOutputType | null
  }

  export type Ai_entity_memoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    confidence_score: Decimal | null
  }

  export type Ai_entity_memorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    confidence_score: Decimal | null
  }

  export type Ai_entity_memoryMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    entity_type: string | null
    entity_key: string | null
    confidence_score: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_entity_memoryMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    entity_type: string | null
    entity_key: string | null
    confidence_score: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_entity_memoryCountAggregateOutputType = {
    id: number
    user_id: number
    entity_type: number
    entity_key: number
    entity_data: number
    confidence_score: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_entity_memoryAvgAggregateInputType = {
    id?: true
    user_id?: true
    confidence_score?: true
  }

  export type Ai_entity_memorySumAggregateInputType = {
    id?: true
    user_id?: true
    confidence_score?: true
  }

  export type Ai_entity_memoryMinAggregateInputType = {
    id?: true
    user_id?: true
    entity_type?: true
    entity_key?: true
    confidence_score?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_entity_memoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    entity_type?: true
    entity_key?: true
    confidence_score?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_entity_memoryCountAggregateInputType = {
    id?: true
    user_id?: true
    entity_type?: true
    entity_key?: true
    entity_data?: true
    confidence_score?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_entity_memoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_entity_memory to aggregate.
     */
    where?: ai_entity_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_entity_memories to fetch.
     */
    orderBy?: ai_entity_memoryOrderByWithRelationInput | ai_entity_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_entity_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_entity_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_entity_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_entity_memories
    **/
    _count?: true | Ai_entity_memoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_entity_memoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_entity_memorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_entity_memoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_entity_memoryMaxAggregateInputType
  }

  export type GetAi_entity_memoryAggregateType<T extends Ai_entity_memoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_entity_memory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_entity_memory[P]>
      : GetScalarType<T[P], AggregateAi_entity_memory[P]>
  }




  export type ai_entity_memoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_entity_memoryWhereInput
    orderBy?: ai_entity_memoryOrderByWithAggregationInput | ai_entity_memoryOrderByWithAggregationInput[]
    by: Ai_entity_memoryScalarFieldEnum[] | Ai_entity_memoryScalarFieldEnum
    having?: ai_entity_memoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_entity_memoryCountAggregateInputType | true
    _avg?: Ai_entity_memoryAvgAggregateInputType
    _sum?: Ai_entity_memorySumAggregateInputType
    _min?: Ai_entity_memoryMinAggregateInputType
    _max?: Ai_entity_memoryMaxAggregateInputType
  }

  export type Ai_entity_memoryGroupByOutputType = {
    id: number
    user_id: number | null
    entity_type: string
    entity_key: string
    entity_data: JsonValue
    confidence_score: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ai_entity_memoryCountAggregateOutputType | null
    _avg: Ai_entity_memoryAvgAggregateOutputType | null
    _sum: Ai_entity_memorySumAggregateOutputType | null
    _min: Ai_entity_memoryMinAggregateOutputType | null
    _max: Ai_entity_memoryMaxAggregateOutputType | null
  }

  type GetAi_entity_memoryGroupByPayload<T extends ai_entity_memoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_entity_memoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_entity_memoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_entity_memoryGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_entity_memoryGroupByOutputType[P]>
        }
      >
    >


  export type ai_entity_memorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    entity_type?: boolean
    entity_key?: boolean
    entity_data?: boolean
    confidence_score?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | ai_entity_memory$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_entity_memory"]>

  export type ai_entity_memorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    entity_type?: boolean
    entity_key?: boolean
    entity_data?: boolean
    confidence_score?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | ai_entity_memory$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_entity_memory"]>

  export type ai_entity_memorySelectScalar = {
    id?: boolean
    user_id?: boolean
    entity_type?: boolean
    entity_key?: boolean
    entity_data?: boolean
    confidence_score?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ai_entity_memoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_entity_memory$usersArgs<ExtArgs>
  }
  export type ai_entity_memoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_entity_memory$usersArgs<ExtArgs>
  }

  export type $ai_entity_memoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_entity_memory"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      entity_type: string
      entity_key: string
      entity_data: Prisma.JsonValue
      confidence_score: Prisma.Decimal | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ai_entity_memory"]>
    composites: {}
  }

  type ai_entity_memoryGetPayload<S extends boolean | null | undefined | ai_entity_memoryDefaultArgs> = $Result.GetResult<Prisma.$ai_entity_memoryPayload, S>

  type ai_entity_memoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ai_entity_memoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ai_entity_memoryCountAggregateInputType | true
    }

  export interface ai_entity_memoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_entity_memory'], meta: { name: 'ai_entity_memory' } }
    /**
     * Find zero or one Ai_entity_memory that matches the filter.
     * @param {ai_entity_memoryFindUniqueArgs} args - Arguments to find a Ai_entity_memory
     * @example
     * // Get one Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_entity_memoryFindUniqueArgs>(args: SelectSubset<T, ai_entity_memoryFindUniqueArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ai_entity_memory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ai_entity_memoryFindUniqueOrThrowArgs} args - Arguments to find a Ai_entity_memory
     * @example
     * // Get one Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_entity_memoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_entity_memoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ai_entity_memory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryFindFirstArgs} args - Arguments to find a Ai_entity_memory
     * @example
     * // Get one Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_entity_memoryFindFirstArgs>(args?: SelectSubset<T, ai_entity_memoryFindFirstArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ai_entity_memory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryFindFirstOrThrowArgs} args - Arguments to find a Ai_entity_memory
     * @example
     * // Get one Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_entity_memoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_entity_memoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ai_entity_memories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_entity_memories
     * const ai_entity_memories = await prisma.ai_entity_memory.findMany()
     * 
     * // Get first 10 Ai_entity_memories
     * const ai_entity_memories = await prisma.ai_entity_memory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_entity_memoryWithIdOnly = await prisma.ai_entity_memory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_entity_memoryFindManyArgs>(args?: SelectSubset<T, ai_entity_memoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ai_entity_memory.
     * @param {ai_entity_memoryCreateArgs} args - Arguments to create a Ai_entity_memory.
     * @example
     * // Create one Ai_entity_memory
     * const Ai_entity_memory = await prisma.ai_entity_memory.create({
     *   data: {
     *     // ... data to create a Ai_entity_memory
     *   }
     * })
     * 
     */
    create<T extends ai_entity_memoryCreateArgs>(args: SelectSubset<T, ai_entity_memoryCreateArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ai_entity_memories.
     * @param {ai_entity_memoryCreateManyArgs} args - Arguments to create many Ai_entity_memories.
     * @example
     * // Create many Ai_entity_memories
     * const ai_entity_memory = await prisma.ai_entity_memory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_entity_memoryCreateManyArgs>(args?: SelectSubset<T, ai_entity_memoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_entity_memories and returns the data saved in the database.
     * @param {ai_entity_memoryCreateManyAndReturnArgs} args - Arguments to create many Ai_entity_memories.
     * @example
     * // Create many Ai_entity_memories
     * const ai_entity_memory = await prisma.ai_entity_memory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_entity_memories and only return the `id`
     * const ai_entity_memoryWithIdOnly = await prisma.ai_entity_memory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_entity_memoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_entity_memoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ai_entity_memory.
     * @param {ai_entity_memoryDeleteArgs} args - Arguments to delete one Ai_entity_memory.
     * @example
     * // Delete one Ai_entity_memory
     * const Ai_entity_memory = await prisma.ai_entity_memory.delete({
     *   where: {
     *     // ... filter to delete one Ai_entity_memory
     *   }
     * })
     * 
     */
    delete<T extends ai_entity_memoryDeleteArgs>(args: SelectSubset<T, ai_entity_memoryDeleteArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ai_entity_memory.
     * @param {ai_entity_memoryUpdateArgs} args - Arguments to update one Ai_entity_memory.
     * @example
     * // Update one Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_entity_memoryUpdateArgs>(args: SelectSubset<T, ai_entity_memoryUpdateArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ai_entity_memories.
     * @param {ai_entity_memoryDeleteManyArgs} args - Arguments to filter Ai_entity_memories to delete.
     * @example
     * // Delete a few Ai_entity_memories
     * const { count } = await prisma.ai_entity_memory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_entity_memoryDeleteManyArgs>(args?: SelectSubset<T, ai_entity_memoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_entity_memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_entity_memories
     * const ai_entity_memory = await prisma.ai_entity_memory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_entity_memoryUpdateManyArgs>(args: SelectSubset<T, ai_entity_memoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_entity_memory.
     * @param {ai_entity_memoryUpsertArgs} args - Arguments to update or create a Ai_entity_memory.
     * @example
     * // Update or create a Ai_entity_memory
     * const ai_entity_memory = await prisma.ai_entity_memory.upsert({
     *   create: {
     *     // ... data to create a Ai_entity_memory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_entity_memory we want to update
     *   }
     * })
     */
    upsert<T extends ai_entity_memoryUpsertArgs>(args: SelectSubset<T, ai_entity_memoryUpsertArgs<ExtArgs>>): Prisma__ai_entity_memoryClient<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ai_entity_memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryCountArgs} args - Arguments to filter Ai_entity_memories to count.
     * @example
     * // Count the number of Ai_entity_memories
     * const count = await prisma.ai_entity_memory.count({
     *   where: {
     *     // ... the filter for the Ai_entity_memories we want to count
     *   }
     * })
    **/
    count<T extends ai_entity_memoryCountArgs>(
      args?: Subset<T, ai_entity_memoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_entity_memoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_entity_memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_entity_memoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_entity_memoryAggregateArgs>(args: Subset<T, Ai_entity_memoryAggregateArgs>): Prisma.PrismaPromise<GetAi_entity_memoryAggregateType<T>>

    /**
     * Group by Ai_entity_memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_entity_memoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_entity_memoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_entity_memoryGroupByArgs['orderBy'] }
        : { orderBy?: ai_entity_memoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_entity_memoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_entity_memoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_entity_memory model
   */
  readonly fields: ai_entity_memoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_entity_memory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_entity_memoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ai_entity_memory$usersArgs<ExtArgs> = {}>(args?: Subset<T, ai_entity_memory$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_entity_memory model
   */ 
  interface ai_entity_memoryFieldRefs {
    readonly id: FieldRef<"ai_entity_memory", 'Int'>
    readonly user_id: FieldRef<"ai_entity_memory", 'Int'>
    readonly entity_type: FieldRef<"ai_entity_memory", 'String'>
    readonly entity_key: FieldRef<"ai_entity_memory", 'String'>
    readonly entity_data: FieldRef<"ai_entity_memory", 'Json'>
    readonly confidence_score: FieldRef<"ai_entity_memory", 'Decimal'>
    readonly created_at: FieldRef<"ai_entity_memory", 'DateTime'>
    readonly updated_at: FieldRef<"ai_entity_memory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_entity_memory findUnique
   */
  export type ai_entity_memoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_entity_memory to fetch.
     */
    where: ai_entity_memoryWhereUniqueInput
  }

  /**
   * ai_entity_memory findUniqueOrThrow
   */
  export type ai_entity_memoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_entity_memory to fetch.
     */
    where: ai_entity_memoryWhereUniqueInput
  }

  /**
   * ai_entity_memory findFirst
   */
  export type ai_entity_memoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_entity_memory to fetch.
     */
    where?: ai_entity_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_entity_memories to fetch.
     */
    orderBy?: ai_entity_memoryOrderByWithRelationInput | ai_entity_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_entity_memories.
     */
    cursor?: ai_entity_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_entity_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_entity_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_entity_memories.
     */
    distinct?: Ai_entity_memoryScalarFieldEnum | Ai_entity_memoryScalarFieldEnum[]
  }

  /**
   * ai_entity_memory findFirstOrThrow
   */
  export type ai_entity_memoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_entity_memory to fetch.
     */
    where?: ai_entity_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_entity_memories to fetch.
     */
    orderBy?: ai_entity_memoryOrderByWithRelationInput | ai_entity_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_entity_memories.
     */
    cursor?: ai_entity_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_entity_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_entity_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_entity_memories.
     */
    distinct?: Ai_entity_memoryScalarFieldEnum | Ai_entity_memoryScalarFieldEnum[]
  }

  /**
   * ai_entity_memory findMany
   */
  export type ai_entity_memoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_entity_memories to fetch.
     */
    where?: ai_entity_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_entity_memories to fetch.
     */
    orderBy?: ai_entity_memoryOrderByWithRelationInput | ai_entity_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_entity_memories.
     */
    cursor?: ai_entity_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_entity_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_entity_memories.
     */
    skip?: number
    distinct?: Ai_entity_memoryScalarFieldEnum | Ai_entity_memoryScalarFieldEnum[]
  }

  /**
   * ai_entity_memory create
   */
  export type ai_entity_memoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_entity_memory.
     */
    data: XOR<ai_entity_memoryCreateInput, ai_entity_memoryUncheckedCreateInput>
  }

  /**
   * ai_entity_memory createMany
   */
  export type ai_entity_memoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_entity_memories.
     */
    data: ai_entity_memoryCreateManyInput | ai_entity_memoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_entity_memory createManyAndReturn
   */
  export type ai_entity_memoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ai_entity_memories.
     */
    data: ai_entity_memoryCreateManyInput | ai_entity_memoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_entity_memory update
   */
  export type ai_entity_memoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_entity_memory.
     */
    data: XOR<ai_entity_memoryUpdateInput, ai_entity_memoryUncheckedUpdateInput>
    /**
     * Choose, which ai_entity_memory to update.
     */
    where: ai_entity_memoryWhereUniqueInput
  }

  /**
   * ai_entity_memory updateMany
   */
  export type ai_entity_memoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_entity_memories.
     */
    data: XOR<ai_entity_memoryUpdateManyMutationInput, ai_entity_memoryUncheckedUpdateManyInput>
    /**
     * Filter which ai_entity_memories to update
     */
    where?: ai_entity_memoryWhereInput
  }

  /**
   * ai_entity_memory upsert
   */
  export type ai_entity_memoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_entity_memory to update in case it exists.
     */
    where: ai_entity_memoryWhereUniqueInput
    /**
     * In case the ai_entity_memory found by the `where` argument doesn't exist, create a new ai_entity_memory with this data.
     */
    create: XOR<ai_entity_memoryCreateInput, ai_entity_memoryUncheckedCreateInput>
    /**
     * In case the ai_entity_memory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_entity_memoryUpdateInput, ai_entity_memoryUncheckedUpdateInput>
  }

  /**
   * ai_entity_memory delete
   */
  export type ai_entity_memoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    /**
     * Filter which ai_entity_memory to delete.
     */
    where: ai_entity_memoryWhereUniqueInput
  }

  /**
   * ai_entity_memory deleteMany
   */
  export type ai_entity_memoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_entity_memories to delete
     */
    where?: ai_entity_memoryWhereInput
  }

  /**
   * ai_entity_memory.users
   */
  export type ai_entity_memory$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * ai_entity_memory without action
   */
  export type ai_entity_memoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
  }


  /**
   * Model ai_knowledge_base
   */

  export type AggregateAi_knowledge_base = {
    _count: Ai_knowledge_baseCountAggregateOutputType | null
    _avg: Ai_knowledge_baseAvgAggregateOutputType | null
    _sum: Ai_knowledge_baseSumAggregateOutputType | null
    _min: Ai_knowledge_baseMinAggregateOutputType | null
    _max: Ai_knowledge_baseMaxAggregateOutputType | null
  }

  export type Ai_knowledge_baseAvgAggregateOutputType = {
    id: number | null
    confidence_score: Decimal | null
    usage_count: number | null
  }

  export type Ai_knowledge_baseSumAggregateOutputType = {
    id: number | null
    confidence_score: Decimal | null
    usage_count: number | null
  }

  export type Ai_knowledge_baseMinAggregateOutputType = {
    id: number | null
    knowledge_type: string | null
    topic: string | null
    title: string | null
    content: string | null
    source: string | null
    confidence_score: Decimal | null
    usage_count: number | null
    last_used: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_knowledge_baseMaxAggregateOutputType = {
    id: number | null
    knowledge_type: string | null
    topic: string | null
    title: string | null
    content: string | null
    source: string | null
    confidence_score: Decimal | null
    usage_count: number | null
    last_used: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ai_knowledge_baseCountAggregateOutputType = {
    id: number
    knowledge_type: number
    topic: number
    title: number
    content: number
    source: number
    confidence_score: number
    usage_count: number
    last_used: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ai_knowledge_baseAvgAggregateInputType = {
    id?: true
    confidence_score?: true
    usage_count?: true
  }

  export type Ai_knowledge_baseSumAggregateInputType = {
    id?: true
    confidence_score?: true
    usage_count?: true
  }

  export type Ai_knowledge_baseMinAggregateInputType = {
    id?: true
    knowledge_type?: true
    topic?: true
    title?: true
    content?: true
    source?: true
    confidence_score?: true
    usage_count?: true
    last_used?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_knowledge_baseMaxAggregateInputType = {
    id?: true
    knowledge_type?: true
    topic?: true
    title?: true
    content?: true
    source?: true
    confidence_score?: true
    usage_count?: true
    last_used?: true
    created_at?: true
    updated_at?: true
  }

  export type Ai_knowledge_baseCountAggregateInputType = {
    id?: true
    knowledge_type?: true
    topic?: true
    title?: true
    content?: true
    source?: true
    confidence_score?: true
    usage_count?: true
    last_used?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ai_knowledge_baseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_knowledge_base to aggregate.
     */
    where?: ai_knowledge_baseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_knowledge_bases to fetch.
     */
    orderBy?: ai_knowledge_baseOrderByWithRelationInput | ai_knowledge_baseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_knowledge_baseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_knowledge_bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_knowledge_bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_knowledge_bases
    **/
    _count?: true | Ai_knowledge_baseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_knowledge_baseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_knowledge_baseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_knowledge_baseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_knowledge_baseMaxAggregateInputType
  }

  export type GetAi_knowledge_baseAggregateType<T extends Ai_knowledge_baseAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_knowledge_base]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_knowledge_base[P]>
      : GetScalarType<T[P], AggregateAi_knowledge_base[P]>
  }




  export type ai_knowledge_baseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_knowledge_baseWhereInput
    orderBy?: ai_knowledge_baseOrderByWithAggregationInput | ai_knowledge_baseOrderByWithAggregationInput[]
    by: Ai_knowledge_baseScalarFieldEnum[] | Ai_knowledge_baseScalarFieldEnum
    having?: ai_knowledge_baseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_knowledge_baseCountAggregateInputType | true
    _avg?: Ai_knowledge_baseAvgAggregateInputType
    _sum?: Ai_knowledge_baseSumAggregateInputType
    _min?: Ai_knowledge_baseMinAggregateInputType
    _max?: Ai_knowledge_baseMaxAggregateInputType
  }

  export type Ai_knowledge_baseGroupByOutputType = {
    id: number
    knowledge_type: string
    topic: string
    title: string
    content: string
    source: string | null
    confidence_score: Decimal | null
    usage_count: number | null
    last_used: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ai_knowledge_baseCountAggregateOutputType | null
    _avg: Ai_knowledge_baseAvgAggregateOutputType | null
    _sum: Ai_knowledge_baseSumAggregateOutputType | null
    _min: Ai_knowledge_baseMinAggregateOutputType | null
    _max: Ai_knowledge_baseMaxAggregateOutputType | null
  }

  type GetAi_knowledge_baseGroupByPayload<T extends ai_knowledge_baseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_knowledge_baseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_knowledge_baseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_knowledge_baseGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_knowledge_baseGroupByOutputType[P]>
        }
      >
    >


  export type ai_knowledge_baseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledge_type?: boolean
    topic?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    confidence_score?: boolean
    usage_count?: boolean
    last_used?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_knowledge_base"]>

  export type ai_knowledge_baseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledge_type?: boolean
    topic?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    confidence_score?: boolean
    usage_count?: boolean
    last_used?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ai_knowledge_base"]>

  export type ai_knowledge_baseSelectScalar = {
    id?: boolean
    knowledge_type?: boolean
    topic?: boolean
    title?: boolean
    content?: boolean
    source?: boolean
    confidence_score?: boolean
    usage_count?: boolean
    last_used?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $ai_knowledge_basePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_knowledge_base"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      knowledge_type: string
      topic: string
      title: string
      content: string
      source: string | null
      confidence_score: Prisma.Decimal | null
      usage_count: number | null
      last_used: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ai_knowledge_base"]>
    composites: {}
  }

  type ai_knowledge_baseGetPayload<S extends boolean | null | undefined | ai_knowledge_baseDefaultArgs> = $Result.GetResult<Prisma.$ai_knowledge_basePayload, S>

  type ai_knowledge_baseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ai_knowledge_baseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ai_knowledge_baseCountAggregateInputType | true
    }

  export interface ai_knowledge_baseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_knowledge_base'], meta: { name: 'ai_knowledge_base' } }
    /**
     * Find zero or one Ai_knowledge_base that matches the filter.
     * @param {ai_knowledge_baseFindUniqueArgs} args - Arguments to find a Ai_knowledge_base
     * @example
     * // Get one Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_knowledge_baseFindUniqueArgs>(args: SelectSubset<T, ai_knowledge_baseFindUniqueArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ai_knowledge_base that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ai_knowledge_baseFindUniqueOrThrowArgs} args - Arguments to find a Ai_knowledge_base
     * @example
     * // Get one Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_knowledge_baseFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_knowledge_baseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ai_knowledge_base that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseFindFirstArgs} args - Arguments to find a Ai_knowledge_base
     * @example
     * // Get one Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_knowledge_baseFindFirstArgs>(args?: SelectSubset<T, ai_knowledge_baseFindFirstArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ai_knowledge_base that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseFindFirstOrThrowArgs} args - Arguments to find a Ai_knowledge_base
     * @example
     * // Get one Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_knowledge_baseFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_knowledge_baseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ai_knowledge_bases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_knowledge_bases
     * const ai_knowledge_bases = await prisma.ai_knowledge_base.findMany()
     * 
     * // Get first 10 Ai_knowledge_bases
     * const ai_knowledge_bases = await prisma.ai_knowledge_base.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_knowledge_baseWithIdOnly = await prisma.ai_knowledge_base.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_knowledge_baseFindManyArgs>(args?: SelectSubset<T, ai_knowledge_baseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ai_knowledge_base.
     * @param {ai_knowledge_baseCreateArgs} args - Arguments to create a Ai_knowledge_base.
     * @example
     * // Create one Ai_knowledge_base
     * const Ai_knowledge_base = await prisma.ai_knowledge_base.create({
     *   data: {
     *     // ... data to create a Ai_knowledge_base
     *   }
     * })
     * 
     */
    create<T extends ai_knowledge_baseCreateArgs>(args: SelectSubset<T, ai_knowledge_baseCreateArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ai_knowledge_bases.
     * @param {ai_knowledge_baseCreateManyArgs} args - Arguments to create many Ai_knowledge_bases.
     * @example
     * // Create many Ai_knowledge_bases
     * const ai_knowledge_base = await prisma.ai_knowledge_base.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_knowledge_baseCreateManyArgs>(args?: SelectSubset<T, ai_knowledge_baseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_knowledge_bases and returns the data saved in the database.
     * @param {ai_knowledge_baseCreateManyAndReturnArgs} args - Arguments to create many Ai_knowledge_bases.
     * @example
     * // Create many Ai_knowledge_bases
     * const ai_knowledge_base = await prisma.ai_knowledge_base.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_knowledge_bases and only return the `id`
     * const ai_knowledge_baseWithIdOnly = await prisma.ai_knowledge_base.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_knowledge_baseCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_knowledge_baseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ai_knowledge_base.
     * @param {ai_knowledge_baseDeleteArgs} args - Arguments to delete one Ai_knowledge_base.
     * @example
     * // Delete one Ai_knowledge_base
     * const Ai_knowledge_base = await prisma.ai_knowledge_base.delete({
     *   where: {
     *     // ... filter to delete one Ai_knowledge_base
     *   }
     * })
     * 
     */
    delete<T extends ai_knowledge_baseDeleteArgs>(args: SelectSubset<T, ai_knowledge_baseDeleteArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ai_knowledge_base.
     * @param {ai_knowledge_baseUpdateArgs} args - Arguments to update one Ai_knowledge_base.
     * @example
     * // Update one Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_knowledge_baseUpdateArgs>(args: SelectSubset<T, ai_knowledge_baseUpdateArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ai_knowledge_bases.
     * @param {ai_knowledge_baseDeleteManyArgs} args - Arguments to filter Ai_knowledge_bases to delete.
     * @example
     * // Delete a few Ai_knowledge_bases
     * const { count } = await prisma.ai_knowledge_base.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_knowledge_baseDeleteManyArgs>(args?: SelectSubset<T, ai_knowledge_baseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_knowledge_bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_knowledge_bases
     * const ai_knowledge_base = await prisma.ai_knowledge_base.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_knowledge_baseUpdateManyArgs>(args: SelectSubset<T, ai_knowledge_baseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_knowledge_base.
     * @param {ai_knowledge_baseUpsertArgs} args - Arguments to update or create a Ai_knowledge_base.
     * @example
     * // Update or create a Ai_knowledge_base
     * const ai_knowledge_base = await prisma.ai_knowledge_base.upsert({
     *   create: {
     *     // ... data to create a Ai_knowledge_base
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_knowledge_base we want to update
     *   }
     * })
     */
    upsert<T extends ai_knowledge_baseUpsertArgs>(args: SelectSubset<T, ai_knowledge_baseUpsertArgs<ExtArgs>>): Prisma__ai_knowledge_baseClient<$Result.GetResult<Prisma.$ai_knowledge_basePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ai_knowledge_bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseCountArgs} args - Arguments to filter Ai_knowledge_bases to count.
     * @example
     * // Count the number of Ai_knowledge_bases
     * const count = await prisma.ai_knowledge_base.count({
     *   where: {
     *     // ... the filter for the Ai_knowledge_bases we want to count
     *   }
     * })
    **/
    count<T extends ai_knowledge_baseCountArgs>(
      args?: Subset<T, ai_knowledge_baseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_knowledge_baseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_knowledge_base.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_knowledge_baseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_knowledge_baseAggregateArgs>(args: Subset<T, Ai_knowledge_baseAggregateArgs>): Prisma.PrismaPromise<GetAi_knowledge_baseAggregateType<T>>

    /**
     * Group by Ai_knowledge_base.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_knowledge_baseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_knowledge_baseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_knowledge_baseGroupByArgs['orderBy'] }
        : { orderBy?: ai_knowledge_baseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_knowledge_baseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_knowledge_baseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_knowledge_base model
   */
  readonly fields: ai_knowledge_baseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_knowledge_base.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_knowledge_baseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_knowledge_base model
   */ 
  interface ai_knowledge_baseFieldRefs {
    readonly id: FieldRef<"ai_knowledge_base", 'Int'>
    readonly knowledge_type: FieldRef<"ai_knowledge_base", 'String'>
    readonly topic: FieldRef<"ai_knowledge_base", 'String'>
    readonly title: FieldRef<"ai_knowledge_base", 'String'>
    readonly content: FieldRef<"ai_knowledge_base", 'String'>
    readonly source: FieldRef<"ai_knowledge_base", 'String'>
    readonly confidence_score: FieldRef<"ai_knowledge_base", 'Decimal'>
    readonly usage_count: FieldRef<"ai_knowledge_base", 'Int'>
    readonly last_used: FieldRef<"ai_knowledge_base", 'DateTime'>
    readonly created_at: FieldRef<"ai_knowledge_base", 'DateTime'>
    readonly updated_at: FieldRef<"ai_knowledge_base", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_knowledge_base findUnique
   */
  export type ai_knowledge_baseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter, which ai_knowledge_base to fetch.
     */
    where: ai_knowledge_baseWhereUniqueInput
  }

  /**
   * ai_knowledge_base findUniqueOrThrow
   */
  export type ai_knowledge_baseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter, which ai_knowledge_base to fetch.
     */
    where: ai_knowledge_baseWhereUniqueInput
  }

  /**
   * ai_knowledge_base findFirst
   */
  export type ai_knowledge_baseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter, which ai_knowledge_base to fetch.
     */
    where?: ai_knowledge_baseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_knowledge_bases to fetch.
     */
    orderBy?: ai_knowledge_baseOrderByWithRelationInput | ai_knowledge_baseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_knowledge_bases.
     */
    cursor?: ai_knowledge_baseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_knowledge_bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_knowledge_bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_knowledge_bases.
     */
    distinct?: Ai_knowledge_baseScalarFieldEnum | Ai_knowledge_baseScalarFieldEnum[]
  }

  /**
   * ai_knowledge_base findFirstOrThrow
   */
  export type ai_knowledge_baseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter, which ai_knowledge_base to fetch.
     */
    where?: ai_knowledge_baseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_knowledge_bases to fetch.
     */
    orderBy?: ai_knowledge_baseOrderByWithRelationInput | ai_knowledge_baseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_knowledge_bases.
     */
    cursor?: ai_knowledge_baseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_knowledge_bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_knowledge_bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_knowledge_bases.
     */
    distinct?: Ai_knowledge_baseScalarFieldEnum | Ai_knowledge_baseScalarFieldEnum[]
  }

  /**
   * ai_knowledge_base findMany
   */
  export type ai_knowledge_baseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter, which ai_knowledge_bases to fetch.
     */
    where?: ai_knowledge_baseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_knowledge_bases to fetch.
     */
    orderBy?: ai_knowledge_baseOrderByWithRelationInput | ai_knowledge_baseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_knowledge_bases.
     */
    cursor?: ai_knowledge_baseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_knowledge_bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_knowledge_bases.
     */
    skip?: number
    distinct?: Ai_knowledge_baseScalarFieldEnum | Ai_knowledge_baseScalarFieldEnum[]
  }

  /**
   * ai_knowledge_base create
   */
  export type ai_knowledge_baseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * The data needed to create a ai_knowledge_base.
     */
    data: XOR<ai_knowledge_baseCreateInput, ai_knowledge_baseUncheckedCreateInput>
  }

  /**
   * ai_knowledge_base createMany
   */
  export type ai_knowledge_baseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_knowledge_bases.
     */
    data: ai_knowledge_baseCreateManyInput | ai_knowledge_baseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_knowledge_base createManyAndReturn
   */
  export type ai_knowledge_baseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ai_knowledge_bases.
     */
    data: ai_knowledge_baseCreateManyInput | ai_knowledge_baseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_knowledge_base update
   */
  export type ai_knowledge_baseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * The data needed to update a ai_knowledge_base.
     */
    data: XOR<ai_knowledge_baseUpdateInput, ai_knowledge_baseUncheckedUpdateInput>
    /**
     * Choose, which ai_knowledge_base to update.
     */
    where: ai_knowledge_baseWhereUniqueInput
  }

  /**
   * ai_knowledge_base updateMany
   */
  export type ai_knowledge_baseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_knowledge_bases.
     */
    data: XOR<ai_knowledge_baseUpdateManyMutationInput, ai_knowledge_baseUncheckedUpdateManyInput>
    /**
     * Filter which ai_knowledge_bases to update
     */
    where?: ai_knowledge_baseWhereInput
  }

  /**
   * ai_knowledge_base upsert
   */
  export type ai_knowledge_baseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * The filter to search for the ai_knowledge_base to update in case it exists.
     */
    where: ai_knowledge_baseWhereUniqueInput
    /**
     * In case the ai_knowledge_base found by the `where` argument doesn't exist, create a new ai_knowledge_base with this data.
     */
    create: XOR<ai_knowledge_baseCreateInput, ai_knowledge_baseUncheckedCreateInput>
    /**
     * In case the ai_knowledge_base was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_knowledge_baseUpdateInput, ai_knowledge_baseUncheckedUpdateInput>
  }

  /**
   * ai_knowledge_base delete
   */
  export type ai_knowledge_baseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
    /**
     * Filter which ai_knowledge_base to delete.
     */
    where: ai_knowledge_baseWhereUniqueInput
  }

  /**
   * ai_knowledge_base deleteMany
   */
  export type ai_knowledge_baseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_knowledge_bases to delete
     */
    where?: ai_knowledge_baseWhereInput
  }

  /**
   * ai_knowledge_base without action
   */
  export type ai_knowledge_baseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_knowledge_base
     */
    select?: ai_knowledge_baseSelect<ExtArgs> | null
  }


  /**
   * Model ai_session_memory
   */

  export type AggregateAi_session_memory = {
    _count: Ai_session_memoryCountAggregateOutputType | null
    _avg: Ai_session_memoryAvgAggregateOutputType | null
    _sum: Ai_session_memorySumAggregateOutputType | null
    _min: Ai_session_memoryMinAggregateOutputType | null
    _max: Ai_session_memoryMaxAggregateOutputType | null
  }

  export type Ai_session_memoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    message_index: number | null
  }

  export type Ai_session_memorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    message_index: number | null
  }

  export type Ai_session_memoryMinAggregateOutputType = {
    id: number | null
    session_id: string | null
    user_id: number | null
    message_index: number | null
    role: string | null
    content: string | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_session_memoryMaxAggregateOutputType = {
    id: number | null
    session_id: string | null
    user_id: number | null
    message_index: number | null
    role: string | null
    content: string | null
    created_at: Date | null
    expires_at: Date | null
  }

  export type Ai_session_memoryCountAggregateOutputType = {
    id: number
    session_id: number
    user_id: number
    message_index: number
    role: number
    content: number
    metadata: number
    created_at: number
    expires_at: number
    _all: number
  }


  export type Ai_session_memoryAvgAggregateInputType = {
    id?: true
    user_id?: true
    message_index?: true
  }

  export type Ai_session_memorySumAggregateInputType = {
    id?: true
    user_id?: true
    message_index?: true
  }

  export type Ai_session_memoryMinAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    message_index?: true
    role?: true
    content?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_session_memoryMaxAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    message_index?: true
    role?: true
    content?: true
    created_at?: true
    expires_at?: true
  }

  export type Ai_session_memoryCountAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
    message_index?: true
    role?: true
    content?: true
    metadata?: true
    created_at?: true
    expires_at?: true
    _all?: true
  }

  export type Ai_session_memoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_session_memory to aggregate.
     */
    where?: ai_session_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_session_memories to fetch.
     */
    orderBy?: ai_session_memoryOrderByWithRelationInput | ai_session_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ai_session_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_session_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_session_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ai_session_memories
    **/
    _count?: true | Ai_session_memoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ai_session_memoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ai_session_memorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ai_session_memoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ai_session_memoryMaxAggregateInputType
  }

  export type GetAi_session_memoryAggregateType<T extends Ai_session_memoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAi_session_memory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAi_session_memory[P]>
      : GetScalarType<T[P], AggregateAi_session_memory[P]>
  }




  export type ai_session_memoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ai_session_memoryWhereInput
    orderBy?: ai_session_memoryOrderByWithAggregationInput | ai_session_memoryOrderByWithAggregationInput[]
    by: Ai_session_memoryScalarFieldEnum[] | Ai_session_memoryScalarFieldEnum
    having?: ai_session_memoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ai_session_memoryCountAggregateInputType | true
    _avg?: Ai_session_memoryAvgAggregateInputType
    _sum?: Ai_session_memorySumAggregateInputType
    _min?: Ai_session_memoryMinAggregateInputType
    _max?: Ai_session_memoryMaxAggregateInputType
  }

  export type Ai_session_memoryGroupByOutputType = {
    id: number
    session_id: string
    user_id: number | null
    message_index: number
    role: string
    content: string
    metadata: JsonValue | null
    created_at: Date | null
    expires_at: Date | null
    _count: Ai_session_memoryCountAggregateOutputType | null
    _avg: Ai_session_memoryAvgAggregateOutputType | null
    _sum: Ai_session_memorySumAggregateOutputType | null
    _min: Ai_session_memoryMinAggregateOutputType | null
    _max: Ai_session_memoryMaxAggregateOutputType | null
  }

  type GetAi_session_memoryGroupByPayload<T extends ai_session_memoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ai_session_memoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ai_session_memoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ai_session_memoryGroupByOutputType[P]>
            : GetScalarType<T[P], Ai_session_memoryGroupByOutputType[P]>
        }
      >
    >


  export type ai_session_memorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    message_index?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    created_at?: boolean
    expires_at?: boolean
    users?: boolean | ai_session_memory$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_session_memory"]>

  export type ai_session_memorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    message_index?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    created_at?: boolean
    expires_at?: boolean
    users?: boolean | ai_session_memory$usersArgs<ExtArgs>
  }, ExtArgs["result"]["ai_session_memory"]>

  export type ai_session_memorySelectScalar = {
    id?: boolean
    session_id?: boolean
    user_id?: boolean
    message_index?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    created_at?: boolean
    expires_at?: boolean
  }

  export type ai_session_memoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_session_memory$usersArgs<ExtArgs>
  }
  export type ai_session_memoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ai_session_memory$usersArgs<ExtArgs>
  }

  export type $ai_session_memoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ai_session_memory"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: string
      user_id: number | null
      message_index: number
      role: string
      content: string
      metadata: Prisma.JsonValue | null
      created_at: Date | null
      expires_at: Date | null
    }, ExtArgs["result"]["ai_session_memory"]>
    composites: {}
  }

  type ai_session_memoryGetPayload<S extends boolean | null | undefined | ai_session_memoryDefaultArgs> = $Result.GetResult<Prisma.$ai_session_memoryPayload, S>

  type ai_session_memoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ai_session_memoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ai_session_memoryCountAggregateInputType | true
    }

  export interface ai_session_memoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ai_session_memory'], meta: { name: 'ai_session_memory' } }
    /**
     * Find zero or one Ai_session_memory that matches the filter.
     * @param {ai_session_memoryFindUniqueArgs} args - Arguments to find a Ai_session_memory
     * @example
     * // Get one Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ai_session_memoryFindUniqueArgs>(args: SelectSubset<T, ai_session_memoryFindUniqueArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ai_session_memory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ai_session_memoryFindUniqueOrThrowArgs} args - Arguments to find a Ai_session_memory
     * @example
     * // Get one Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ai_session_memoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ai_session_memoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ai_session_memory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryFindFirstArgs} args - Arguments to find a Ai_session_memory
     * @example
     * // Get one Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ai_session_memoryFindFirstArgs>(args?: SelectSubset<T, ai_session_memoryFindFirstArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ai_session_memory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryFindFirstOrThrowArgs} args - Arguments to find a Ai_session_memory
     * @example
     * // Get one Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ai_session_memoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ai_session_memoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ai_session_memories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ai_session_memories
     * const ai_session_memories = await prisma.ai_session_memory.findMany()
     * 
     * // Get first 10 Ai_session_memories
     * const ai_session_memories = await prisma.ai_session_memory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ai_session_memoryWithIdOnly = await prisma.ai_session_memory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ai_session_memoryFindManyArgs>(args?: SelectSubset<T, ai_session_memoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ai_session_memory.
     * @param {ai_session_memoryCreateArgs} args - Arguments to create a Ai_session_memory.
     * @example
     * // Create one Ai_session_memory
     * const Ai_session_memory = await prisma.ai_session_memory.create({
     *   data: {
     *     // ... data to create a Ai_session_memory
     *   }
     * })
     * 
     */
    create<T extends ai_session_memoryCreateArgs>(args: SelectSubset<T, ai_session_memoryCreateArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ai_session_memories.
     * @param {ai_session_memoryCreateManyArgs} args - Arguments to create many Ai_session_memories.
     * @example
     * // Create many Ai_session_memories
     * const ai_session_memory = await prisma.ai_session_memory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ai_session_memoryCreateManyArgs>(args?: SelectSubset<T, ai_session_memoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ai_session_memories and returns the data saved in the database.
     * @param {ai_session_memoryCreateManyAndReturnArgs} args - Arguments to create many Ai_session_memories.
     * @example
     * // Create many Ai_session_memories
     * const ai_session_memory = await prisma.ai_session_memory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ai_session_memories and only return the `id`
     * const ai_session_memoryWithIdOnly = await prisma.ai_session_memory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ai_session_memoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ai_session_memoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ai_session_memory.
     * @param {ai_session_memoryDeleteArgs} args - Arguments to delete one Ai_session_memory.
     * @example
     * // Delete one Ai_session_memory
     * const Ai_session_memory = await prisma.ai_session_memory.delete({
     *   where: {
     *     // ... filter to delete one Ai_session_memory
     *   }
     * })
     * 
     */
    delete<T extends ai_session_memoryDeleteArgs>(args: SelectSubset<T, ai_session_memoryDeleteArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ai_session_memory.
     * @param {ai_session_memoryUpdateArgs} args - Arguments to update one Ai_session_memory.
     * @example
     * // Update one Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ai_session_memoryUpdateArgs>(args: SelectSubset<T, ai_session_memoryUpdateArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ai_session_memories.
     * @param {ai_session_memoryDeleteManyArgs} args - Arguments to filter Ai_session_memories to delete.
     * @example
     * // Delete a few Ai_session_memories
     * const { count } = await prisma.ai_session_memory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ai_session_memoryDeleteManyArgs>(args?: SelectSubset<T, ai_session_memoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ai_session_memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ai_session_memories
     * const ai_session_memory = await prisma.ai_session_memory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ai_session_memoryUpdateManyArgs>(args: SelectSubset<T, ai_session_memoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ai_session_memory.
     * @param {ai_session_memoryUpsertArgs} args - Arguments to update or create a Ai_session_memory.
     * @example
     * // Update or create a Ai_session_memory
     * const ai_session_memory = await prisma.ai_session_memory.upsert({
     *   create: {
     *     // ... data to create a Ai_session_memory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ai_session_memory we want to update
     *   }
     * })
     */
    upsert<T extends ai_session_memoryUpsertArgs>(args: SelectSubset<T, ai_session_memoryUpsertArgs<ExtArgs>>): Prisma__ai_session_memoryClient<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ai_session_memories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryCountArgs} args - Arguments to filter Ai_session_memories to count.
     * @example
     * // Count the number of Ai_session_memories
     * const count = await prisma.ai_session_memory.count({
     *   where: {
     *     // ... the filter for the Ai_session_memories we want to count
     *   }
     * })
    **/
    count<T extends ai_session_memoryCountArgs>(
      args?: Subset<T, ai_session_memoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ai_session_memoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ai_session_memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ai_session_memoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ai_session_memoryAggregateArgs>(args: Subset<T, Ai_session_memoryAggregateArgs>): Prisma.PrismaPromise<GetAi_session_memoryAggregateType<T>>

    /**
     * Group by Ai_session_memory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ai_session_memoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ai_session_memoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ai_session_memoryGroupByArgs['orderBy'] }
        : { orderBy?: ai_session_memoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ai_session_memoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAi_session_memoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ai_session_memory model
   */
  readonly fields: ai_session_memoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ai_session_memory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ai_session_memoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ai_session_memory$usersArgs<ExtArgs> = {}>(args?: Subset<T, ai_session_memory$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ai_session_memory model
   */ 
  interface ai_session_memoryFieldRefs {
    readonly id: FieldRef<"ai_session_memory", 'Int'>
    readonly session_id: FieldRef<"ai_session_memory", 'String'>
    readonly user_id: FieldRef<"ai_session_memory", 'Int'>
    readonly message_index: FieldRef<"ai_session_memory", 'Int'>
    readonly role: FieldRef<"ai_session_memory", 'String'>
    readonly content: FieldRef<"ai_session_memory", 'String'>
    readonly metadata: FieldRef<"ai_session_memory", 'Json'>
    readonly created_at: FieldRef<"ai_session_memory", 'DateTime'>
    readonly expires_at: FieldRef<"ai_session_memory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ai_session_memory findUnique
   */
  export type ai_session_memoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_session_memory to fetch.
     */
    where: ai_session_memoryWhereUniqueInput
  }

  /**
   * ai_session_memory findUniqueOrThrow
   */
  export type ai_session_memoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_session_memory to fetch.
     */
    where: ai_session_memoryWhereUniqueInput
  }

  /**
   * ai_session_memory findFirst
   */
  export type ai_session_memoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_session_memory to fetch.
     */
    where?: ai_session_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_session_memories to fetch.
     */
    orderBy?: ai_session_memoryOrderByWithRelationInput | ai_session_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_session_memories.
     */
    cursor?: ai_session_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_session_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_session_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_session_memories.
     */
    distinct?: Ai_session_memoryScalarFieldEnum | Ai_session_memoryScalarFieldEnum[]
  }

  /**
   * ai_session_memory findFirstOrThrow
   */
  export type ai_session_memoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_session_memory to fetch.
     */
    where?: ai_session_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_session_memories to fetch.
     */
    orderBy?: ai_session_memoryOrderByWithRelationInput | ai_session_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ai_session_memories.
     */
    cursor?: ai_session_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_session_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_session_memories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ai_session_memories.
     */
    distinct?: Ai_session_memoryScalarFieldEnum | Ai_session_memoryScalarFieldEnum[]
  }

  /**
   * ai_session_memory findMany
   */
  export type ai_session_memoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter, which ai_session_memories to fetch.
     */
    where?: ai_session_memoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ai_session_memories to fetch.
     */
    orderBy?: ai_session_memoryOrderByWithRelationInput | ai_session_memoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ai_session_memories.
     */
    cursor?: ai_session_memoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ai_session_memories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ai_session_memories.
     */
    skip?: number
    distinct?: Ai_session_memoryScalarFieldEnum | Ai_session_memoryScalarFieldEnum[]
  }

  /**
   * ai_session_memory create
   */
  export type ai_session_memoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ai_session_memory.
     */
    data: XOR<ai_session_memoryCreateInput, ai_session_memoryUncheckedCreateInput>
  }

  /**
   * ai_session_memory createMany
   */
  export type ai_session_memoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ai_session_memories.
     */
    data: ai_session_memoryCreateManyInput | ai_session_memoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ai_session_memory createManyAndReturn
   */
  export type ai_session_memoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ai_session_memories.
     */
    data: ai_session_memoryCreateManyInput | ai_session_memoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ai_session_memory update
   */
  export type ai_session_memoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ai_session_memory.
     */
    data: XOR<ai_session_memoryUpdateInput, ai_session_memoryUncheckedUpdateInput>
    /**
     * Choose, which ai_session_memory to update.
     */
    where: ai_session_memoryWhereUniqueInput
  }

  /**
   * ai_session_memory updateMany
   */
  export type ai_session_memoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ai_session_memories.
     */
    data: XOR<ai_session_memoryUpdateManyMutationInput, ai_session_memoryUncheckedUpdateManyInput>
    /**
     * Filter which ai_session_memories to update
     */
    where?: ai_session_memoryWhereInput
  }

  /**
   * ai_session_memory upsert
   */
  export type ai_session_memoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ai_session_memory to update in case it exists.
     */
    where: ai_session_memoryWhereUniqueInput
    /**
     * In case the ai_session_memory found by the `where` argument doesn't exist, create a new ai_session_memory with this data.
     */
    create: XOR<ai_session_memoryCreateInput, ai_session_memoryUncheckedCreateInput>
    /**
     * In case the ai_session_memory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ai_session_memoryUpdateInput, ai_session_memoryUncheckedUpdateInput>
  }

  /**
   * ai_session_memory delete
   */
  export type ai_session_memoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    /**
     * Filter which ai_session_memory to delete.
     */
    where: ai_session_memoryWhereUniqueInput
  }

  /**
   * ai_session_memory deleteMany
   */
  export type ai_session_memoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ai_session_memories to delete
     */
    where?: ai_session_memoryWhereInput
  }

  /**
   * ai_session_memory.users
   */
  export type ai_session_memory$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * ai_session_memory without action
   */
  export type ai_session_memoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
  }


  /**
   * Model article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    sentiment_score: number | null
    relevance_score: number | null
    author_id: number | null
    view_count: number | null
    unique_viewers: number | null
    id: number | null
  }

  export type ArticleSumAggregateOutputType = {
    sentiment_score: number | null
    relevance_score: number | null
    author_id: number | null
    view_count: number | null
    unique_viewers: number | null
    id: number | null
  }

  export type ArticleMinAggregateOutputType = {
    title: string | null
    slug: string | null
    summary: string | null
    content: string | null
    source: string | null
    source_url: string | null
    published_at: Date | null
    category: string | null
    region: string | null
    sector: string | null
    sentiment_score: number | null
    relevance_score: number | null
    author_id: number | null
    author_name: string | null
    is_published: boolean | null
    is_featured: boolean | null
    view_count: number | null
    unique_viewers: number | null
    ai_summary: string | null
    ai_summary_provider: string | null
    ai_summary_generated_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    title: string | null
    slug: string | null
    summary: string | null
    content: string | null
    source: string | null
    source_url: string | null
    published_at: Date | null
    category: string | null
    region: string | null
    sector: string | null
    sentiment_score: number | null
    relevance_score: number | null
    author_id: number | null
    author_name: string | null
    is_published: boolean | null
    is_featured: boolean | null
    view_count: number | null
    unique_viewers: number | null
    ai_summary: string | null
    ai_summary_provider: string | null
    ai_summary_generated_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    title: number
    slug: number
    summary: number
    content: number
    source: number
    source_url: number
    published_at: number
    category: number
    region: number
    sector: number
    keywords: number
    sentiment_score: number
    relevance_score: number
    author_id: number
    author_name: number
    is_published: number
    is_featured: number
    view_count: number
    unique_viewers: number
    ai_summary: number
    ai_summary_provider: number
    ai_summary_generated_at: number
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    sentiment_score?: true
    relevance_score?: true
    author_id?: true
    view_count?: true
    unique_viewers?: true
    id?: true
  }

  export type ArticleSumAggregateInputType = {
    sentiment_score?: true
    relevance_score?: true
    author_id?: true
    view_count?: true
    unique_viewers?: true
    id?: true
  }

  export type ArticleMinAggregateInputType = {
    title?: true
    slug?: true
    summary?: true
    content?: true
    source?: true
    source_url?: true
    published_at?: true
    category?: true
    region?: true
    sector?: true
    sentiment_score?: true
    relevance_score?: true
    author_id?: true
    author_name?: true
    is_published?: true
    is_featured?: true
    view_count?: true
    unique_viewers?: true
    ai_summary?: true
    ai_summary_provider?: true
    ai_summary_generated_at?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type ArticleMaxAggregateInputType = {
    title?: true
    slug?: true
    summary?: true
    content?: true
    source?: true
    source_url?: true
    published_at?: true
    category?: true
    region?: true
    sector?: true
    sentiment_score?: true
    relevance_score?: true
    author_id?: true
    author_name?: true
    is_published?: true
    is_featured?: true
    view_count?: true
    unique_viewers?: true
    ai_summary?: true
    ai_summary_provider?: true
    ai_summary_generated_at?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type ArticleCountAggregateInputType = {
    title?: true
    slug?: true
    summary?: true
    content?: true
    source?: true
    source_url?: true
    published_at?: true
    category?: true
    region?: true
    sector?: true
    keywords?: true
    sentiment_score?: true
    relevance_score?: true
    author_id?: true
    author_name?: true
    is_published?: true
    is_featured?: true
    view_count?: true
    unique_viewers?: true
    ai_summary?: true
    ai_summary_provider?: true
    ai_summary_generated_at?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which article to aggregate.
     */
    where?: articleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articleOrderByWithRelationInput | articleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: articleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type articleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articleWhereInput
    orderBy?: articleOrderByWithAggregationInput | articleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: articleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    title: string
    slug: string
    summary: string | null
    content: string | null
    source: string | null
    source_url: string | null
    published_at: Date | null
    category: string | null
    region: string | null
    sector: string | null
    keywords: JsonValue | null
    sentiment_score: number | null
    relevance_score: number | null
    author_id: number | null
    author_name: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary: string | null
    ai_summary_provider: string | null
    ai_summary_generated_at: Date | null
    id: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends articleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type articleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    slug?: boolean
    summary?: boolean
    content?: boolean
    source?: boolean
    source_url?: boolean
    published_at?: boolean
    category?: boolean
    region?: boolean
    sector?: boolean
    keywords?: boolean
    sentiment_score?: boolean
    relevance_score?: boolean
    author_id?: boolean
    author_name?: boolean
    is_published?: boolean
    is_featured?: boolean
    view_count?: boolean
    unique_viewers?: boolean
    ai_summary?: boolean
    ai_summary_provider?: boolean
    ai_summary_generated_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user?: boolean | article$userArgs<ExtArgs>
    article_tags?: boolean | article$article_tagsArgs<ExtArgs>
    articlestar?: boolean | article$articlestarArgs<ExtArgs>
    articleview?: boolean | article$articleviewArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type articleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    slug?: boolean
    summary?: boolean
    content?: boolean
    source?: boolean
    source_url?: boolean
    published_at?: boolean
    category?: boolean
    region?: boolean
    sector?: boolean
    keywords?: boolean
    sentiment_score?: boolean
    relevance_score?: boolean
    author_id?: boolean
    author_name?: boolean
    is_published?: boolean
    is_featured?: boolean
    view_count?: boolean
    unique_viewers?: boolean
    ai_summary?: boolean
    ai_summary_provider?: boolean
    ai_summary_generated_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user?: boolean | article$userArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type articleSelectScalar = {
    title?: boolean
    slug?: boolean
    summary?: boolean
    content?: boolean
    source?: boolean
    source_url?: boolean
    published_at?: boolean
    category?: boolean
    region?: boolean
    sector?: boolean
    keywords?: boolean
    sentiment_score?: boolean
    relevance_score?: boolean
    author_id?: boolean
    author_name?: boolean
    is_published?: boolean
    is_featured?: boolean
    view_count?: boolean
    unique_viewers?: boolean
    ai_summary?: boolean
    ai_summary_provider?: boolean
    ai_summary_generated_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
  }

  export type articleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | article$userArgs<ExtArgs>
    article_tags?: boolean | article$article_tagsArgs<ExtArgs>
    articlestar?: boolean | article$articlestarArgs<ExtArgs>
    articleview?: boolean | article$articleviewArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type articleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | article$userArgs<ExtArgs>
  }

  export type $articlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "article"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      article_tags: Prisma.$article_tagsPayload<ExtArgs>[]
      articlestar: Prisma.$articlestarPayload<ExtArgs>[]
      articleview: Prisma.$articleviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      title: string
      slug: string
      summary: string | null
      content: string | null
      source: string | null
      source_url: string | null
      published_at: Date | null
      category: string | null
      region: string | null
      sector: string | null
      keywords: Prisma.JsonValue | null
      sentiment_score: number | null
      relevance_score: number | null
      author_id: number | null
      author_name: string | null
      is_published: boolean
      is_featured: boolean
      view_count: number
      unique_viewers: number
      ai_summary: string | null
      ai_summary_provider: string | null
      ai_summary_generated_at: Date | null
      id: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type articleGetPayload<S extends boolean | null | undefined | articleDefaultArgs> = $Result.GetResult<Prisma.$articlePayload, S>

  type articleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<articleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface articleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['article'], meta: { name: 'article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {articleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends articleFindUniqueArgs>(args: SelectSubset<T, articleFindUniqueArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {articleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends articleFindUniqueOrThrowArgs>(args: SelectSubset<T, articleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends articleFindFirstArgs>(args?: SelectSubset<T, articleFindFirstArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends articleFindFirstOrThrowArgs>(args?: SelectSubset<T, articleFindFirstOrThrowArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `title`
     * const articleWithTitleOnly = await prisma.article.findMany({ select: { title: true } })
     * 
     */
    findMany<T extends articleFindManyArgs>(args?: SelectSubset<T, articleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Article.
     * @param {articleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends articleCreateArgs>(args: SelectSubset<T, articleCreateArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Articles.
     * @param {articleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends articleCreateManyArgs>(args?: SelectSubset<T, articleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {articleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articles and only return the `title`
     * const articleWithTitleOnly = await prisma.article.createManyAndReturn({ 
     *   select: { title: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends articleCreateManyAndReturnArgs>(args?: SelectSubset<T, articleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Article.
     * @param {articleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends articleDeleteArgs>(args: SelectSubset<T, articleDeleteArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Article.
     * @param {articleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends articleUpdateArgs>(args: SelectSubset<T, articleUpdateArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {articleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends articleDeleteManyArgs>(args?: SelectSubset<T, articleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends articleUpdateManyArgs>(args: SelectSubset<T, articleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {articleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends articleUpsertArgs>(args: SelectSubset<T, articleUpsertArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends articleCountArgs>(
      args?: Subset<T, articleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends articleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: articleGroupByArgs['orderBy'] }
        : { orderBy?: articleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, articleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the article model
   */
  readonly fields: articleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__articleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends article$userArgs<ExtArgs> = {}>(args?: Subset<T, article$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    article_tags<T extends article$article_tagsArgs<ExtArgs> = {}>(args?: Subset<T, article$article_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findMany"> | Null>
    articlestar<T extends article$articlestarArgs<ExtArgs> = {}>(args?: Subset<T, article$articlestarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findMany"> | Null>
    articleview<T extends article$articleviewArgs<ExtArgs> = {}>(args?: Subset<T, article$articleviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the article model
   */ 
  interface articleFieldRefs {
    readonly title: FieldRef<"article", 'String'>
    readonly slug: FieldRef<"article", 'String'>
    readonly summary: FieldRef<"article", 'String'>
    readonly content: FieldRef<"article", 'String'>
    readonly source: FieldRef<"article", 'String'>
    readonly source_url: FieldRef<"article", 'String'>
    readonly published_at: FieldRef<"article", 'DateTime'>
    readonly category: FieldRef<"article", 'String'>
    readonly region: FieldRef<"article", 'String'>
    readonly sector: FieldRef<"article", 'String'>
    readonly keywords: FieldRef<"article", 'Json'>
    readonly sentiment_score: FieldRef<"article", 'Float'>
    readonly relevance_score: FieldRef<"article", 'Float'>
    readonly author_id: FieldRef<"article", 'Int'>
    readonly author_name: FieldRef<"article", 'String'>
    readonly is_published: FieldRef<"article", 'Boolean'>
    readonly is_featured: FieldRef<"article", 'Boolean'>
    readonly view_count: FieldRef<"article", 'Int'>
    readonly unique_viewers: FieldRef<"article", 'Int'>
    readonly ai_summary: FieldRef<"article", 'String'>
    readonly ai_summary_provider: FieldRef<"article", 'String'>
    readonly ai_summary_generated_at: FieldRef<"article", 'DateTime'>
    readonly id: FieldRef<"article", 'Int'>
    readonly created_at: FieldRef<"article", 'DateTime'>
    readonly updated_at: FieldRef<"article", 'DateTime'>
    readonly is_deleted: FieldRef<"article", 'Boolean'>
    readonly deleted_at: FieldRef<"article", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * article findUnique
   */
  export type articleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter, which article to fetch.
     */
    where: articleWhereUniqueInput
  }

  /**
   * article findUniqueOrThrow
   */
  export type articleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter, which article to fetch.
     */
    where: articleWhereUniqueInput
  }

  /**
   * article findFirst
   */
  export type articleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter, which article to fetch.
     */
    where?: articleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articleOrderByWithRelationInput | articleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articles.
     */
    cursor?: articleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * article findFirstOrThrow
   */
  export type articleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter, which article to fetch.
     */
    where?: articleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articleOrderByWithRelationInput | articleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articles.
     */
    cursor?: articleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * article findMany
   */
  export type articleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter, which articles to fetch.
     */
    where?: articleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articles to fetch.
     */
    orderBy?: articleOrderByWithRelationInput | articleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing articles.
     */
    cursor?: articleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * article create
   */
  export type articleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * The data needed to create a article.
     */
    data: XOR<articleCreateInput, articleUncheckedCreateInput>
  }

  /**
   * article createMany
   */
  export type articleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many articles.
     */
    data: articleCreateManyInput | articleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * article createManyAndReturn
   */
  export type articleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many articles.
     */
    data: articleCreateManyInput | articleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * article update
   */
  export type articleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * The data needed to update a article.
     */
    data: XOR<articleUpdateInput, articleUncheckedUpdateInput>
    /**
     * Choose, which article to update.
     */
    where: articleWhereUniqueInput
  }

  /**
   * article updateMany
   */
  export type articleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update articles.
     */
    data: XOR<articleUpdateManyMutationInput, articleUncheckedUpdateManyInput>
    /**
     * Filter which articles to update
     */
    where?: articleWhereInput
  }

  /**
   * article upsert
   */
  export type articleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * The filter to search for the article to update in case it exists.
     */
    where: articleWhereUniqueInput
    /**
     * In case the article found by the `where` argument doesn't exist, create a new article with this data.
     */
    create: XOR<articleCreateInput, articleUncheckedCreateInput>
    /**
     * In case the article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<articleUpdateInput, articleUncheckedUpdateInput>
  }

  /**
   * article delete
   */
  export type articleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    /**
     * Filter which article to delete.
     */
    where: articleWhereUniqueInput
  }

  /**
   * article deleteMany
   */
  export type articleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articles to delete
     */
    where?: articleWhereInput
  }

  /**
   * article.user
   */
  export type article$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * article.article_tags
   */
  export type article$article_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    where?: article_tagsWhereInput
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    cursor?: article_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Article_tagsScalarFieldEnum | Article_tagsScalarFieldEnum[]
  }

  /**
   * article.articlestar
   */
  export type article$articlestarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    where?: articlestarWhereInput
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    cursor?: articlestarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticlestarScalarFieldEnum | ArticlestarScalarFieldEnum[]
  }

  /**
   * article.articleview
   */
  export type article$articleviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    where?: articleviewWhereInput
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    cursor?: articleviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleviewScalarFieldEnum | ArticleviewScalarFieldEnum[]
  }

  /**
   * article without action
   */
  export type articleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
  }


  /**
   * Model article_tags
   */

  export type AggregateArticle_tags = {
    _count: Article_tagsCountAggregateOutputType | null
    _avg: Article_tagsAvgAggregateOutputType | null
    _sum: Article_tagsSumAggregateOutputType | null
    _min: Article_tagsMinAggregateOutputType | null
    _max: Article_tagsMaxAggregateOutputType | null
  }

  export type Article_tagsAvgAggregateOutputType = {
    article_id: number | null
    tag_id: number | null
  }

  export type Article_tagsSumAggregateOutputType = {
    article_id: number | null
    tag_id: number | null
  }

  export type Article_tagsMinAggregateOutputType = {
    article_id: number | null
    tag_id: number | null
  }

  export type Article_tagsMaxAggregateOutputType = {
    article_id: number | null
    tag_id: number | null
  }

  export type Article_tagsCountAggregateOutputType = {
    article_id: number
    tag_id: number
    _all: number
  }


  export type Article_tagsAvgAggregateInputType = {
    article_id?: true
    tag_id?: true
  }

  export type Article_tagsSumAggregateInputType = {
    article_id?: true
    tag_id?: true
  }

  export type Article_tagsMinAggregateInputType = {
    article_id?: true
    tag_id?: true
  }

  export type Article_tagsMaxAggregateInputType = {
    article_id?: true
    tag_id?: true
  }

  export type Article_tagsCountAggregateInputType = {
    article_id?: true
    tag_id?: true
    _all?: true
  }

  export type Article_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which article_tags to aggregate.
     */
    where?: article_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of article_tags to fetch.
     */
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: article_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` article_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` article_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned article_tags
    **/
    _count?: true | Article_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Article_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Article_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Article_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Article_tagsMaxAggregateInputType
  }

  export type GetArticle_tagsAggregateType<T extends Article_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle_tags[P]>
      : GetScalarType<T[P], AggregateArticle_tags[P]>
  }




  export type article_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: article_tagsWhereInput
    orderBy?: article_tagsOrderByWithAggregationInput | article_tagsOrderByWithAggregationInput[]
    by: Article_tagsScalarFieldEnum[] | Article_tagsScalarFieldEnum
    having?: article_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Article_tagsCountAggregateInputType | true
    _avg?: Article_tagsAvgAggregateInputType
    _sum?: Article_tagsSumAggregateInputType
    _min?: Article_tagsMinAggregateInputType
    _max?: Article_tagsMaxAggregateInputType
  }

  export type Article_tagsGroupByOutputType = {
    article_id: number
    tag_id: number
    _count: Article_tagsCountAggregateOutputType | null
    _avg: Article_tagsAvgAggregateOutputType | null
    _sum: Article_tagsSumAggregateOutputType | null
    _min: Article_tagsMinAggregateOutputType | null
    _max: Article_tagsMaxAggregateOutputType | null
  }

  type GetArticle_tagsGroupByPayload<T extends article_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Article_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Article_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Article_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Article_tagsGroupByOutputType[P]>
        }
      >
    >


  export type article_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    article_id?: boolean
    tag_id?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article_tags"]>

  export type article_tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    article_id?: boolean
    tag_id?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article_tags"]>

  export type article_tagsSelectScalar = {
    article_id?: boolean
    tag_id?: boolean
  }

  export type article_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }
  export type article_tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    tag?: boolean | tagDefaultArgs<ExtArgs>
  }

  export type $article_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "article_tags"
    objects: {
      article: Prisma.$articlePayload<ExtArgs>
      tag: Prisma.$tagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      article_id: number
      tag_id: number
    }, ExtArgs["result"]["article_tags"]>
    composites: {}
  }

  type article_tagsGetPayload<S extends boolean | null | undefined | article_tagsDefaultArgs> = $Result.GetResult<Prisma.$article_tagsPayload, S>

  type article_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<article_tagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Article_tagsCountAggregateInputType | true
    }

  export interface article_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['article_tags'], meta: { name: 'article_tags' } }
    /**
     * Find zero or one Article_tags that matches the filter.
     * @param {article_tagsFindUniqueArgs} args - Arguments to find a Article_tags
     * @example
     * // Get one Article_tags
     * const article_tags = await prisma.article_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends article_tagsFindUniqueArgs>(args: SelectSubset<T, article_tagsFindUniqueArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Article_tags that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {article_tagsFindUniqueOrThrowArgs} args - Arguments to find a Article_tags
     * @example
     * // Get one Article_tags
     * const article_tags = await prisma.article_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends article_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, article_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Article_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsFindFirstArgs} args - Arguments to find a Article_tags
     * @example
     * // Get one Article_tags
     * const article_tags = await prisma.article_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends article_tagsFindFirstArgs>(args?: SelectSubset<T, article_tagsFindFirstArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Article_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsFindFirstOrThrowArgs} args - Arguments to find a Article_tags
     * @example
     * // Get one Article_tags
     * const article_tags = await prisma.article_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends article_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, article_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Article_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Article_tags
     * const article_tags = await prisma.article_tags.findMany()
     * 
     * // Get first 10 Article_tags
     * const article_tags = await prisma.article_tags.findMany({ take: 10 })
     * 
     * // Only select the `article_id`
     * const article_tagsWithArticle_idOnly = await prisma.article_tags.findMany({ select: { article_id: true } })
     * 
     */
    findMany<T extends article_tagsFindManyArgs>(args?: SelectSubset<T, article_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Article_tags.
     * @param {article_tagsCreateArgs} args - Arguments to create a Article_tags.
     * @example
     * // Create one Article_tags
     * const Article_tags = await prisma.article_tags.create({
     *   data: {
     *     // ... data to create a Article_tags
     *   }
     * })
     * 
     */
    create<T extends article_tagsCreateArgs>(args: SelectSubset<T, article_tagsCreateArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Article_tags.
     * @param {article_tagsCreateManyArgs} args - Arguments to create many Article_tags.
     * @example
     * // Create many Article_tags
     * const article_tags = await prisma.article_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends article_tagsCreateManyArgs>(args?: SelectSubset<T, article_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Article_tags and returns the data saved in the database.
     * @param {article_tagsCreateManyAndReturnArgs} args - Arguments to create many Article_tags.
     * @example
     * // Create many Article_tags
     * const article_tags = await prisma.article_tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Article_tags and only return the `article_id`
     * const article_tagsWithArticle_idOnly = await prisma.article_tags.createManyAndReturn({ 
     *   select: { article_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends article_tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, article_tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Article_tags.
     * @param {article_tagsDeleteArgs} args - Arguments to delete one Article_tags.
     * @example
     * // Delete one Article_tags
     * const Article_tags = await prisma.article_tags.delete({
     *   where: {
     *     // ... filter to delete one Article_tags
     *   }
     * })
     * 
     */
    delete<T extends article_tagsDeleteArgs>(args: SelectSubset<T, article_tagsDeleteArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Article_tags.
     * @param {article_tagsUpdateArgs} args - Arguments to update one Article_tags.
     * @example
     * // Update one Article_tags
     * const article_tags = await prisma.article_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends article_tagsUpdateArgs>(args: SelectSubset<T, article_tagsUpdateArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Article_tags.
     * @param {article_tagsDeleteManyArgs} args - Arguments to filter Article_tags to delete.
     * @example
     * // Delete a few Article_tags
     * const { count } = await prisma.article_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends article_tagsDeleteManyArgs>(args?: SelectSubset<T, article_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Article_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Article_tags
     * const article_tags = await prisma.article_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends article_tagsUpdateManyArgs>(args: SelectSubset<T, article_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article_tags.
     * @param {article_tagsUpsertArgs} args - Arguments to update or create a Article_tags.
     * @example
     * // Update or create a Article_tags
     * const article_tags = await prisma.article_tags.upsert({
     *   create: {
     *     // ... data to create a Article_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article_tags we want to update
     *   }
     * })
     */
    upsert<T extends article_tagsUpsertArgs>(args: SelectSubset<T, article_tagsUpsertArgs<ExtArgs>>): Prisma__article_tagsClient<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Article_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsCountArgs} args - Arguments to filter Article_tags to count.
     * @example
     * // Count the number of Article_tags
     * const count = await prisma.article_tags.count({
     *   where: {
     *     // ... the filter for the Article_tags we want to count
     *   }
     * })
    **/
    count<T extends article_tagsCountArgs>(
      args?: Subset<T, article_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Article_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Article_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Article_tagsAggregateArgs>(args: Subset<T, Article_tagsAggregateArgs>): Prisma.PrismaPromise<GetArticle_tagsAggregateType<T>>

    /**
     * Group by Article_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {article_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends article_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: article_tagsGroupByArgs['orderBy'] }
        : { orderBy?: article_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, article_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticle_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the article_tags model
   */
  readonly fields: article_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for article_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__article_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends articleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, articleDefaultArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends tagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagDefaultArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the article_tags model
   */ 
  interface article_tagsFieldRefs {
    readonly article_id: FieldRef<"article_tags", 'Int'>
    readonly tag_id: FieldRef<"article_tags", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * article_tags findUnique
   */
  export type article_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter, which article_tags to fetch.
     */
    where: article_tagsWhereUniqueInput
  }

  /**
   * article_tags findUniqueOrThrow
   */
  export type article_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter, which article_tags to fetch.
     */
    where: article_tagsWhereUniqueInput
  }

  /**
   * article_tags findFirst
   */
  export type article_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter, which article_tags to fetch.
     */
    where?: article_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of article_tags to fetch.
     */
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for article_tags.
     */
    cursor?: article_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` article_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` article_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of article_tags.
     */
    distinct?: Article_tagsScalarFieldEnum | Article_tagsScalarFieldEnum[]
  }

  /**
   * article_tags findFirstOrThrow
   */
  export type article_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter, which article_tags to fetch.
     */
    where?: article_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of article_tags to fetch.
     */
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for article_tags.
     */
    cursor?: article_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` article_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` article_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of article_tags.
     */
    distinct?: Article_tagsScalarFieldEnum | Article_tagsScalarFieldEnum[]
  }

  /**
   * article_tags findMany
   */
  export type article_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter, which article_tags to fetch.
     */
    where?: article_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of article_tags to fetch.
     */
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing article_tags.
     */
    cursor?: article_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` article_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` article_tags.
     */
    skip?: number
    distinct?: Article_tagsScalarFieldEnum | Article_tagsScalarFieldEnum[]
  }

  /**
   * article_tags create
   */
  export type article_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a article_tags.
     */
    data: XOR<article_tagsCreateInput, article_tagsUncheckedCreateInput>
  }

  /**
   * article_tags createMany
   */
  export type article_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many article_tags.
     */
    data: article_tagsCreateManyInput | article_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * article_tags createManyAndReturn
   */
  export type article_tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many article_tags.
     */
    data: article_tagsCreateManyInput | article_tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * article_tags update
   */
  export type article_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a article_tags.
     */
    data: XOR<article_tagsUpdateInput, article_tagsUncheckedUpdateInput>
    /**
     * Choose, which article_tags to update.
     */
    where: article_tagsWhereUniqueInput
  }

  /**
   * article_tags updateMany
   */
  export type article_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update article_tags.
     */
    data: XOR<article_tagsUpdateManyMutationInput, article_tagsUncheckedUpdateManyInput>
    /**
     * Filter which article_tags to update
     */
    where?: article_tagsWhereInput
  }

  /**
   * article_tags upsert
   */
  export type article_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the article_tags to update in case it exists.
     */
    where: article_tagsWhereUniqueInput
    /**
     * In case the article_tags found by the `where` argument doesn't exist, create a new article_tags with this data.
     */
    create: XOR<article_tagsCreateInput, article_tagsUncheckedCreateInput>
    /**
     * In case the article_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<article_tagsUpdateInput, article_tagsUncheckedUpdateInput>
  }

  /**
   * article_tags delete
   */
  export type article_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    /**
     * Filter which article_tags to delete.
     */
    where: article_tagsWhereUniqueInput
  }

  /**
   * article_tags deleteMany
   */
  export type article_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which article_tags to delete
     */
    where?: article_tagsWhereInput
  }

  /**
   * article_tags without action
   */
  export type article_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
  }


  /**
   * Model articlestar
   */

  export type AggregateArticlestar = {
    _count: ArticlestarCountAggregateOutputType | null
    _avg: ArticlestarAvgAggregateOutputType | null
    _sum: ArticlestarSumAggregateOutputType | null
    _min: ArticlestarMinAggregateOutputType | null
    _max: ArticlestarMaxAggregateOutputType | null
  }

  export type ArticlestarAvgAggregateOutputType = {
    user_id: number | null
    article_id: number | null
    id: number | null
  }

  export type ArticlestarSumAggregateOutputType = {
    user_id: number | null
    article_id: number | null
    id: number | null
  }

  export type ArticlestarMinAggregateOutputType = {
    user_id: number | null
    article_id: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticlestarMaxAggregateOutputType = {
    user_id: number | null
    article_id: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticlestarCountAggregateOutputType = {
    user_id: number
    article_id: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ArticlestarAvgAggregateInputType = {
    user_id?: true
    article_id?: true
    id?: true
  }

  export type ArticlestarSumAggregateInputType = {
    user_id?: true
    article_id?: true
    id?: true
  }

  export type ArticlestarMinAggregateInputType = {
    user_id?: true
    article_id?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticlestarMaxAggregateInputType = {
    user_id?: true
    article_id?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticlestarCountAggregateInputType = {
    user_id?: true
    article_id?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ArticlestarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articlestar to aggregate.
     */
    where?: articlestarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articlestars to fetch.
     */
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: articlestarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articlestars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articlestars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned articlestars
    **/
    _count?: true | ArticlestarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticlestarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticlestarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticlestarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticlestarMaxAggregateInputType
  }

  export type GetArticlestarAggregateType<T extends ArticlestarAggregateArgs> = {
        [P in keyof T & keyof AggregateArticlestar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticlestar[P]>
      : GetScalarType<T[P], AggregateArticlestar[P]>
  }




  export type articlestarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articlestarWhereInput
    orderBy?: articlestarOrderByWithAggregationInput | articlestarOrderByWithAggregationInput[]
    by: ArticlestarScalarFieldEnum[] | ArticlestarScalarFieldEnum
    having?: articlestarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticlestarCountAggregateInputType | true
    _avg?: ArticlestarAvgAggregateInputType
    _sum?: ArticlestarSumAggregateInputType
    _min?: ArticlestarMinAggregateInputType
    _max?: ArticlestarMaxAggregateInputType
  }

  export type ArticlestarGroupByOutputType = {
    user_id: number
    article_id: number
    id: number
    created_at: Date
    updated_at: Date
    _count: ArticlestarCountAggregateOutputType | null
    _avg: ArticlestarAvgAggregateOutputType | null
    _sum: ArticlestarSumAggregateOutputType | null
    _min: ArticlestarMinAggregateOutputType | null
    _max: ArticlestarMaxAggregateOutputType | null
  }

  type GetArticlestarGroupByPayload<T extends articlestarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticlestarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticlestarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticlestarGroupByOutputType[P]>
            : GetScalarType<T[P], ArticlestarGroupByOutputType[P]>
        }
      >
    >


  export type articlestarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    article_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articlestar"]>

  export type articlestarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    article_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articlestar"]>

  export type articlestarSelectScalar = {
    user_id?: boolean
    article_id?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type articlestarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type articlestarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $articlestarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "articlestar"
    objects: {
      article: Prisma.$articlePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      article_id: number
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["articlestar"]>
    composites: {}
  }

  type articlestarGetPayload<S extends boolean | null | undefined | articlestarDefaultArgs> = $Result.GetResult<Prisma.$articlestarPayload, S>

  type articlestarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<articlestarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticlestarCountAggregateInputType | true
    }

  export interface articlestarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['articlestar'], meta: { name: 'articlestar' } }
    /**
     * Find zero or one Articlestar that matches the filter.
     * @param {articlestarFindUniqueArgs} args - Arguments to find a Articlestar
     * @example
     * // Get one Articlestar
     * const articlestar = await prisma.articlestar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends articlestarFindUniqueArgs>(args: SelectSubset<T, articlestarFindUniqueArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Articlestar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {articlestarFindUniqueOrThrowArgs} args - Arguments to find a Articlestar
     * @example
     * // Get one Articlestar
     * const articlestar = await prisma.articlestar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends articlestarFindUniqueOrThrowArgs>(args: SelectSubset<T, articlestarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Articlestar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarFindFirstArgs} args - Arguments to find a Articlestar
     * @example
     * // Get one Articlestar
     * const articlestar = await prisma.articlestar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends articlestarFindFirstArgs>(args?: SelectSubset<T, articlestarFindFirstArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Articlestar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarFindFirstOrThrowArgs} args - Arguments to find a Articlestar
     * @example
     * // Get one Articlestar
     * const articlestar = await prisma.articlestar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends articlestarFindFirstOrThrowArgs>(args?: SelectSubset<T, articlestarFindFirstOrThrowArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Articlestars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articlestars
     * const articlestars = await prisma.articlestar.findMany()
     * 
     * // Get first 10 Articlestars
     * const articlestars = await prisma.articlestar.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const articlestarWithUser_idOnly = await prisma.articlestar.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends articlestarFindManyArgs>(args?: SelectSubset<T, articlestarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Articlestar.
     * @param {articlestarCreateArgs} args - Arguments to create a Articlestar.
     * @example
     * // Create one Articlestar
     * const Articlestar = await prisma.articlestar.create({
     *   data: {
     *     // ... data to create a Articlestar
     *   }
     * })
     * 
     */
    create<T extends articlestarCreateArgs>(args: SelectSubset<T, articlestarCreateArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Articlestars.
     * @param {articlestarCreateManyArgs} args - Arguments to create many Articlestars.
     * @example
     * // Create many Articlestars
     * const articlestar = await prisma.articlestar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends articlestarCreateManyArgs>(args?: SelectSubset<T, articlestarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articlestars and returns the data saved in the database.
     * @param {articlestarCreateManyAndReturnArgs} args - Arguments to create many Articlestars.
     * @example
     * // Create many Articlestars
     * const articlestar = await prisma.articlestar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articlestars and only return the `user_id`
     * const articlestarWithUser_idOnly = await prisma.articlestar.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends articlestarCreateManyAndReturnArgs>(args?: SelectSubset<T, articlestarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Articlestar.
     * @param {articlestarDeleteArgs} args - Arguments to delete one Articlestar.
     * @example
     * // Delete one Articlestar
     * const Articlestar = await prisma.articlestar.delete({
     *   where: {
     *     // ... filter to delete one Articlestar
     *   }
     * })
     * 
     */
    delete<T extends articlestarDeleteArgs>(args: SelectSubset<T, articlestarDeleteArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Articlestar.
     * @param {articlestarUpdateArgs} args - Arguments to update one Articlestar.
     * @example
     * // Update one Articlestar
     * const articlestar = await prisma.articlestar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends articlestarUpdateArgs>(args: SelectSubset<T, articlestarUpdateArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Articlestars.
     * @param {articlestarDeleteManyArgs} args - Arguments to filter Articlestars to delete.
     * @example
     * // Delete a few Articlestars
     * const { count } = await prisma.articlestar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends articlestarDeleteManyArgs>(args?: SelectSubset<T, articlestarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articlestars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articlestars
     * const articlestar = await prisma.articlestar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends articlestarUpdateManyArgs>(args: SelectSubset<T, articlestarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Articlestar.
     * @param {articlestarUpsertArgs} args - Arguments to update or create a Articlestar.
     * @example
     * // Update or create a Articlestar
     * const articlestar = await prisma.articlestar.upsert({
     *   create: {
     *     // ... data to create a Articlestar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Articlestar we want to update
     *   }
     * })
     */
    upsert<T extends articlestarUpsertArgs>(args: SelectSubset<T, articlestarUpsertArgs<ExtArgs>>): Prisma__articlestarClient<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Articlestars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarCountArgs} args - Arguments to filter Articlestars to count.
     * @example
     * // Count the number of Articlestars
     * const count = await prisma.articlestar.count({
     *   where: {
     *     // ... the filter for the Articlestars we want to count
     *   }
     * })
    **/
    count<T extends articlestarCountArgs>(
      args?: Subset<T, articlestarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticlestarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Articlestar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlestarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticlestarAggregateArgs>(args: Subset<T, ArticlestarAggregateArgs>): Prisma.PrismaPromise<GetArticlestarAggregateType<T>>

    /**
     * Group by Articlestar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articlestarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends articlestarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: articlestarGroupByArgs['orderBy'] }
        : { orderBy?: articlestarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, articlestarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticlestarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the articlestar model
   */
  readonly fields: articlestarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for articlestar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__articlestarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends articleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, articleDefaultArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the articlestar model
   */ 
  interface articlestarFieldRefs {
    readonly user_id: FieldRef<"articlestar", 'Int'>
    readonly article_id: FieldRef<"articlestar", 'Int'>
    readonly id: FieldRef<"articlestar", 'Int'>
    readonly created_at: FieldRef<"articlestar", 'DateTime'>
    readonly updated_at: FieldRef<"articlestar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * articlestar findUnique
   */
  export type articlestarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter, which articlestar to fetch.
     */
    where: articlestarWhereUniqueInput
  }

  /**
   * articlestar findUniqueOrThrow
   */
  export type articlestarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter, which articlestar to fetch.
     */
    where: articlestarWhereUniqueInput
  }

  /**
   * articlestar findFirst
   */
  export type articlestarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter, which articlestar to fetch.
     */
    where?: articlestarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articlestars to fetch.
     */
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articlestars.
     */
    cursor?: articlestarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articlestars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articlestars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articlestars.
     */
    distinct?: ArticlestarScalarFieldEnum | ArticlestarScalarFieldEnum[]
  }

  /**
   * articlestar findFirstOrThrow
   */
  export type articlestarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter, which articlestar to fetch.
     */
    where?: articlestarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articlestars to fetch.
     */
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articlestars.
     */
    cursor?: articlestarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articlestars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articlestars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articlestars.
     */
    distinct?: ArticlestarScalarFieldEnum | ArticlestarScalarFieldEnum[]
  }

  /**
   * articlestar findMany
   */
  export type articlestarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter, which articlestars to fetch.
     */
    where?: articlestarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articlestars to fetch.
     */
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing articlestars.
     */
    cursor?: articlestarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articlestars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articlestars.
     */
    skip?: number
    distinct?: ArticlestarScalarFieldEnum | ArticlestarScalarFieldEnum[]
  }

  /**
   * articlestar create
   */
  export type articlestarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * The data needed to create a articlestar.
     */
    data: XOR<articlestarCreateInput, articlestarUncheckedCreateInput>
  }

  /**
   * articlestar createMany
   */
  export type articlestarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many articlestars.
     */
    data: articlestarCreateManyInput | articlestarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * articlestar createManyAndReturn
   */
  export type articlestarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many articlestars.
     */
    data: articlestarCreateManyInput | articlestarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * articlestar update
   */
  export type articlestarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * The data needed to update a articlestar.
     */
    data: XOR<articlestarUpdateInput, articlestarUncheckedUpdateInput>
    /**
     * Choose, which articlestar to update.
     */
    where: articlestarWhereUniqueInput
  }

  /**
   * articlestar updateMany
   */
  export type articlestarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update articlestars.
     */
    data: XOR<articlestarUpdateManyMutationInput, articlestarUncheckedUpdateManyInput>
    /**
     * Filter which articlestars to update
     */
    where?: articlestarWhereInput
  }

  /**
   * articlestar upsert
   */
  export type articlestarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * The filter to search for the articlestar to update in case it exists.
     */
    where: articlestarWhereUniqueInput
    /**
     * In case the articlestar found by the `where` argument doesn't exist, create a new articlestar with this data.
     */
    create: XOR<articlestarCreateInput, articlestarUncheckedCreateInput>
    /**
     * In case the articlestar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<articlestarUpdateInput, articlestarUncheckedUpdateInput>
  }

  /**
   * articlestar delete
   */
  export type articlestarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    /**
     * Filter which articlestar to delete.
     */
    where: articlestarWhereUniqueInput
  }

  /**
   * articlestar deleteMany
   */
  export type articlestarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articlestars to delete
     */
    where?: articlestarWhereInput
  }

  /**
   * articlestar without action
   */
  export type articlestarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
  }


  /**
   * Model articleview
   */

  export type AggregateArticleview = {
    _count: ArticleviewCountAggregateOutputType | null
    _avg: ArticleviewAvgAggregateOutputType | null
    _sum: ArticleviewSumAggregateOutputType | null
    _min: ArticleviewMinAggregateOutputType | null
    _max: ArticleviewMaxAggregateOutputType | null
  }

  export type ArticleviewAvgAggregateOutputType = {
    article_id: number | null
    user_id: number | null
    view_duration: number | null
    id: number | null
  }

  export type ArticleviewSumAggregateOutputType = {
    article_id: number | null
    user_id: number | null
    view_duration: number | null
    id: number | null
  }

  export type ArticleviewMinAggregateOutputType = {
    article_id: number | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    referrer: string | null
    view_duration: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticleviewMaxAggregateOutputType = {
    article_id: number | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    referrer: string | null
    view_duration: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticleviewCountAggregateOutputType = {
    article_id: number
    user_id: number
    ip_address: number
    user_agent: number
    referrer: number
    view_duration: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ArticleviewAvgAggregateInputType = {
    article_id?: true
    user_id?: true
    view_duration?: true
    id?: true
  }

  export type ArticleviewSumAggregateInputType = {
    article_id?: true
    user_id?: true
    view_duration?: true
    id?: true
  }

  export type ArticleviewMinAggregateInputType = {
    article_id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    referrer?: true
    view_duration?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticleviewMaxAggregateInputType = {
    article_id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    referrer?: true
    view_duration?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticleviewCountAggregateInputType = {
    article_id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    referrer?: true
    view_duration?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ArticleviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articleview to aggregate.
     */
    where?: articleviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articleviews to fetch.
     */
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: articleviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articleviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articleviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned articleviews
    **/
    _count?: true | ArticleviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleviewMaxAggregateInputType
  }

  export type GetArticleviewAggregateType<T extends ArticleviewAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleview[P]>
      : GetScalarType<T[P], AggregateArticleview[P]>
  }




  export type articleviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: articleviewWhereInput
    orderBy?: articleviewOrderByWithAggregationInput | articleviewOrderByWithAggregationInput[]
    by: ArticleviewScalarFieldEnum[] | ArticleviewScalarFieldEnum
    having?: articleviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleviewCountAggregateInputType | true
    _avg?: ArticleviewAvgAggregateInputType
    _sum?: ArticleviewSumAggregateInputType
    _min?: ArticleviewMinAggregateInputType
    _max?: ArticleviewMaxAggregateInputType
  }

  export type ArticleviewGroupByOutputType = {
    article_id: number
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    referrer: string | null
    view_duration: number | null
    id: number
    created_at: Date
    updated_at: Date
    _count: ArticleviewCountAggregateOutputType | null
    _avg: ArticleviewAvgAggregateOutputType | null
    _sum: ArticleviewSumAggregateOutputType | null
    _min: ArticleviewMinAggregateOutputType | null
    _max: ArticleviewMaxAggregateOutputType | null
  }

  type GetArticleviewGroupByPayload<T extends articleviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleviewGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleviewGroupByOutputType[P]>
        }
      >
    >


  export type articleviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    article_id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    referrer?: boolean
    view_duration?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | articleview$userArgs<ExtArgs>
  }, ExtArgs["result"]["articleview"]>

  export type articleviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    article_id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    referrer?: boolean
    view_duration?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | articleview$userArgs<ExtArgs>
  }, ExtArgs["result"]["articleview"]>

  export type articleviewSelectScalar = {
    article_id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    referrer?: boolean
    view_duration?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type articleviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | articleview$userArgs<ExtArgs>
  }
  export type articleviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | articleDefaultArgs<ExtArgs>
    user?: boolean | articleview$userArgs<ExtArgs>
  }

  export type $articleviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "articleview"
    objects: {
      article: Prisma.$articlePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      article_id: number
      user_id: number | null
      ip_address: string | null
      user_agent: string | null
      referrer: string | null
      view_duration: number | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["articleview"]>
    composites: {}
  }

  type articleviewGetPayload<S extends boolean | null | undefined | articleviewDefaultArgs> = $Result.GetResult<Prisma.$articleviewPayload, S>

  type articleviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<articleviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleviewCountAggregateInputType | true
    }

  export interface articleviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['articleview'], meta: { name: 'articleview' } }
    /**
     * Find zero or one Articleview that matches the filter.
     * @param {articleviewFindUniqueArgs} args - Arguments to find a Articleview
     * @example
     * // Get one Articleview
     * const articleview = await prisma.articleview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends articleviewFindUniqueArgs>(args: SelectSubset<T, articleviewFindUniqueArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Articleview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {articleviewFindUniqueOrThrowArgs} args - Arguments to find a Articleview
     * @example
     * // Get one Articleview
     * const articleview = await prisma.articleview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends articleviewFindUniqueOrThrowArgs>(args: SelectSubset<T, articleviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Articleview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewFindFirstArgs} args - Arguments to find a Articleview
     * @example
     * // Get one Articleview
     * const articleview = await prisma.articleview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends articleviewFindFirstArgs>(args?: SelectSubset<T, articleviewFindFirstArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Articleview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewFindFirstOrThrowArgs} args - Arguments to find a Articleview
     * @example
     * // Get one Articleview
     * const articleview = await prisma.articleview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends articleviewFindFirstOrThrowArgs>(args?: SelectSubset<T, articleviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Articleviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articleviews
     * const articleviews = await prisma.articleview.findMany()
     * 
     * // Get first 10 Articleviews
     * const articleviews = await prisma.articleview.findMany({ take: 10 })
     * 
     * // Only select the `article_id`
     * const articleviewWithArticle_idOnly = await prisma.articleview.findMany({ select: { article_id: true } })
     * 
     */
    findMany<T extends articleviewFindManyArgs>(args?: SelectSubset<T, articleviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Articleview.
     * @param {articleviewCreateArgs} args - Arguments to create a Articleview.
     * @example
     * // Create one Articleview
     * const Articleview = await prisma.articleview.create({
     *   data: {
     *     // ... data to create a Articleview
     *   }
     * })
     * 
     */
    create<T extends articleviewCreateArgs>(args: SelectSubset<T, articleviewCreateArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Articleviews.
     * @param {articleviewCreateManyArgs} args - Arguments to create many Articleviews.
     * @example
     * // Create many Articleviews
     * const articleview = await prisma.articleview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends articleviewCreateManyArgs>(args?: SelectSubset<T, articleviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articleviews and returns the data saved in the database.
     * @param {articleviewCreateManyAndReturnArgs} args - Arguments to create many Articleviews.
     * @example
     * // Create many Articleviews
     * const articleview = await prisma.articleview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articleviews and only return the `article_id`
     * const articleviewWithArticle_idOnly = await prisma.articleview.createManyAndReturn({ 
     *   select: { article_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends articleviewCreateManyAndReturnArgs>(args?: SelectSubset<T, articleviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Articleview.
     * @param {articleviewDeleteArgs} args - Arguments to delete one Articleview.
     * @example
     * // Delete one Articleview
     * const Articleview = await prisma.articleview.delete({
     *   where: {
     *     // ... filter to delete one Articleview
     *   }
     * })
     * 
     */
    delete<T extends articleviewDeleteArgs>(args: SelectSubset<T, articleviewDeleteArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Articleview.
     * @param {articleviewUpdateArgs} args - Arguments to update one Articleview.
     * @example
     * // Update one Articleview
     * const articleview = await prisma.articleview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends articleviewUpdateArgs>(args: SelectSubset<T, articleviewUpdateArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Articleviews.
     * @param {articleviewDeleteManyArgs} args - Arguments to filter Articleviews to delete.
     * @example
     * // Delete a few Articleviews
     * const { count } = await prisma.articleview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends articleviewDeleteManyArgs>(args?: SelectSubset<T, articleviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articleviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articleviews
     * const articleview = await prisma.articleview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends articleviewUpdateManyArgs>(args: SelectSubset<T, articleviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Articleview.
     * @param {articleviewUpsertArgs} args - Arguments to update or create a Articleview.
     * @example
     * // Update or create a Articleview
     * const articleview = await prisma.articleview.upsert({
     *   create: {
     *     // ... data to create a Articleview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Articleview we want to update
     *   }
     * })
     */
    upsert<T extends articleviewUpsertArgs>(args: SelectSubset<T, articleviewUpsertArgs<ExtArgs>>): Prisma__articleviewClient<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Articleviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewCountArgs} args - Arguments to filter Articleviews to count.
     * @example
     * // Count the number of Articleviews
     * const count = await prisma.articleview.count({
     *   where: {
     *     // ... the filter for the Articleviews we want to count
     *   }
     * })
    **/
    count<T extends articleviewCountArgs>(
      args?: Subset<T, articleviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Articleview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleviewAggregateArgs>(args: Subset<T, ArticleviewAggregateArgs>): Prisma.PrismaPromise<GetArticleviewAggregateType<T>>

    /**
     * Group by Articleview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {articleviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends articleviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: articleviewGroupByArgs['orderBy'] }
        : { orderBy?: articleviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, articleviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the articleview model
   */
  readonly fields: articleviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for articleview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__articleviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends articleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, articleDefaultArgs<ExtArgs>>): Prisma__articleClient<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends articleview$userArgs<ExtArgs> = {}>(args?: Subset<T, articleview$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the articleview model
   */ 
  interface articleviewFieldRefs {
    readonly article_id: FieldRef<"articleview", 'Int'>
    readonly user_id: FieldRef<"articleview", 'Int'>
    readonly ip_address: FieldRef<"articleview", 'String'>
    readonly user_agent: FieldRef<"articleview", 'String'>
    readonly referrer: FieldRef<"articleview", 'String'>
    readonly view_duration: FieldRef<"articleview", 'Int'>
    readonly id: FieldRef<"articleview", 'Int'>
    readonly created_at: FieldRef<"articleview", 'DateTime'>
    readonly updated_at: FieldRef<"articleview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * articleview findUnique
   */
  export type articleviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter, which articleview to fetch.
     */
    where: articleviewWhereUniqueInput
  }

  /**
   * articleview findUniqueOrThrow
   */
  export type articleviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter, which articleview to fetch.
     */
    where: articleviewWhereUniqueInput
  }

  /**
   * articleview findFirst
   */
  export type articleviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter, which articleview to fetch.
     */
    where?: articleviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articleviews to fetch.
     */
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articleviews.
     */
    cursor?: articleviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articleviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articleviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articleviews.
     */
    distinct?: ArticleviewScalarFieldEnum | ArticleviewScalarFieldEnum[]
  }

  /**
   * articleview findFirstOrThrow
   */
  export type articleviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter, which articleview to fetch.
     */
    where?: articleviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articleviews to fetch.
     */
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for articleviews.
     */
    cursor?: articleviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articleviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articleviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of articleviews.
     */
    distinct?: ArticleviewScalarFieldEnum | ArticleviewScalarFieldEnum[]
  }

  /**
   * articleview findMany
   */
  export type articleviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter, which articleviews to fetch.
     */
    where?: articleviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of articleviews to fetch.
     */
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing articleviews.
     */
    cursor?: articleviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` articleviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` articleviews.
     */
    skip?: number
    distinct?: ArticleviewScalarFieldEnum | ArticleviewScalarFieldEnum[]
  }

  /**
   * articleview create
   */
  export type articleviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * The data needed to create a articleview.
     */
    data: XOR<articleviewCreateInput, articleviewUncheckedCreateInput>
  }

  /**
   * articleview createMany
   */
  export type articleviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many articleviews.
     */
    data: articleviewCreateManyInput | articleviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * articleview createManyAndReturn
   */
  export type articleviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many articleviews.
     */
    data: articleviewCreateManyInput | articleviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * articleview update
   */
  export type articleviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * The data needed to update a articleview.
     */
    data: XOR<articleviewUpdateInput, articleviewUncheckedUpdateInput>
    /**
     * Choose, which articleview to update.
     */
    where: articleviewWhereUniqueInput
  }

  /**
   * articleview updateMany
   */
  export type articleviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update articleviews.
     */
    data: XOR<articleviewUpdateManyMutationInput, articleviewUncheckedUpdateManyInput>
    /**
     * Filter which articleviews to update
     */
    where?: articleviewWhereInput
  }

  /**
   * articleview upsert
   */
  export type articleviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * The filter to search for the articleview to update in case it exists.
     */
    where: articleviewWhereUniqueInput
    /**
     * In case the articleview found by the `where` argument doesn't exist, create a new articleview with this data.
     */
    create: XOR<articleviewCreateInput, articleviewUncheckedCreateInput>
    /**
     * In case the articleview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<articleviewUpdateInput, articleviewUncheckedUpdateInput>
  }

  /**
   * articleview delete
   */
  export type articleviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    /**
     * Filter which articleview to delete.
     */
    where: articleviewWhereUniqueInput
  }

  /**
   * articleview deleteMany
   */
  export type articleviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which articleviews to delete
     */
    where?: articleviewWhereInput
  }

  /**
   * articleview.user
   */
  export type articleview$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * articleview without action
   */
  export type articleviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
  }


  /**
   * Model credit_articles
   */

  export type AggregateCredit_articles = {
    _count: Credit_articlesCountAggregateOutputType | null
    _avg: Credit_articlesAvgAggregateOutputType | null
    _sum: Credit_articlesSumAggregateOutputType | null
    _min: Credit_articlesMinAggregateOutputType | null
    _max: Credit_articlesMaxAggregateOutputType | null
  }

  export type Credit_articlesAvgAggregateOutputType = {
    id: number | null
  }

  export type Credit_articlesSumAggregateOutputType = {
    id: number | null
  }

  export type Credit_articlesMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    content: string | null
    link: string | null
    source: string | null
    matched_keywords: string | null
    region: string | null
    sector: string | null
    starred: boolean | null
    starred_at: Date | null
    summary: string | null
    url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Credit_articlesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    content: string | null
    link: string | null
    source: string | null
    matched_keywords: string | null
    region: string | null
    sector: string | null
    starred: boolean | null
    starred_at: Date | null
    summary: string | null
    url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Credit_articlesCountAggregateOutputType = {
    id: number
    title: number
    date: number
    content: number
    link: number
    source: number
    matched_keywords: number
    region: number
    sector: number
    starred: number
    starred_at: number
    summary: number
    url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Credit_articlesAvgAggregateInputType = {
    id?: true
  }

  export type Credit_articlesSumAggregateInputType = {
    id?: true
  }

  export type Credit_articlesMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    content?: true
    link?: true
    source?: true
    matched_keywords?: true
    region?: true
    sector?: true
    starred?: true
    starred_at?: true
    summary?: true
    url?: true
    created_at?: true
    updated_at?: true
  }

  export type Credit_articlesMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    content?: true
    link?: true
    source?: true
    matched_keywords?: true
    region?: true
    sector?: true
    starred?: true
    starred_at?: true
    summary?: true
    url?: true
    created_at?: true
    updated_at?: true
  }

  export type Credit_articlesCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    content?: true
    link?: true
    source?: true
    matched_keywords?: true
    region?: true
    sector?: true
    starred?: true
    starred_at?: true
    summary?: true
    url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Credit_articlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_articles to aggregate.
     */
    where?: credit_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_articles to fetch.
     */
    orderBy?: credit_articlesOrderByWithRelationInput | credit_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credit_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credit_articles
    **/
    _count?: true | Credit_articlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credit_articlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credit_articlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credit_articlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credit_articlesMaxAggregateInputType
  }

  export type GetCredit_articlesAggregateType<T extends Credit_articlesAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit_articles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit_articles[P]>
      : GetScalarType<T[P], AggregateCredit_articles[P]>
  }




  export type credit_articlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_articlesWhereInput
    orderBy?: credit_articlesOrderByWithAggregationInput | credit_articlesOrderByWithAggregationInput[]
    by: Credit_articlesScalarFieldEnum[] | Credit_articlesScalarFieldEnum
    having?: credit_articlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credit_articlesCountAggregateInputType | true
    _avg?: Credit_articlesAvgAggregateInputType
    _sum?: Credit_articlesSumAggregateInputType
    _min?: Credit_articlesMinAggregateInputType
    _max?: Credit_articlesMaxAggregateInputType
  }

  export type Credit_articlesGroupByOutputType = {
    id: number
    title: string | null
    date: Date | null
    content: string | null
    link: string | null
    source: string | null
    matched_keywords: string | null
    region: string | null
    sector: string | null
    starred: boolean | null
    starred_at: Date | null
    summary: string | null
    url: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Credit_articlesCountAggregateOutputType | null
    _avg: Credit_articlesAvgAggregateOutputType | null
    _sum: Credit_articlesSumAggregateOutputType | null
    _min: Credit_articlesMinAggregateOutputType | null
    _max: Credit_articlesMaxAggregateOutputType | null
  }

  type GetCredit_articlesGroupByPayload<T extends credit_articlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credit_articlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credit_articlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credit_articlesGroupByOutputType[P]>
            : GetScalarType<T[P], Credit_articlesGroupByOutputType[P]>
        }
      >
    >


  export type credit_articlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    content?: boolean
    link?: boolean
    source?: boolean
    matched_keywords?: boolean
    region?: boolean
    sector?: boolean
    starred?: boolean
    starred_at?: boolean
    summary?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_article_stars?: boolean | credit_articles$user_article_starsArgs<ExtArgs>
    _count?: boolean | Credit_articlesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credit_articles"]>

  export type credit_articlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    content?: boolean
    link?: boolean
    source?: boolean
    matched_keywords?: boolean
    region?: boolean
    sector?: boolean
    starred?: boolean
    starred_at?: boolean
    summary?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["credit_articles"]>

  export type credit_articlesSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    content?: boolean
    link?: boolean
    source?: boolean
    matched_keywords?: boolean
    region?: boolean
    sector?: boolean
    starred?: boolean
    starred_at?: boolean
    summary?: boolean
    url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type credit_articlesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_article_stars?: boolean | credit_articles$user_article_starsArgs<ExtArgs>
    _count?: boolean | Credit_articlesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type credit_articlesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $credit_articlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credit_articles"
    objects: {
      user_article_stars: Prisma.$user_article_starsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      date: Date | null
      content: string | null
      link: string | null
      source: string | null
      matched_keywords: string | null
      region: string | null
      sector: string | null
      starred: boolean | null
      starred_at: Date | null
      summary: string | null
      url: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["credit_articles"]>
    composites: {}
  }

  type credit_articlesGetPayload<S extends boolean | null | undefined | credit_articlesDefaultArgs> = $Result.GetResult<Prisma.$credit_articlesPayload, S>

  type credit_articlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<credit_articlesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Credit_articlesCountAggregateInputType | true
    }

  export interface credit_articlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credit_articles'], meta: { name: 'credit_articles' } }
    /**
     * Find zero or one Credit_articles that matches the filter.
     * @param {credit_articlesFindUniqueArgs} args - Arguments to find a Credit_articles
     * @example
     * // Get one Credit_articles
     * const credit_articles = await prisma.credit_articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credit_articlesFindUniqueArgs>(args: SelectSubset<T, credit_articlesFindUniqueArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Credit_articles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {credit_articlesFindUniqueOrThrowArgs} args - Arguments to find a Credit_articles
     * @example
     * // Get one Credit_articles
     * const credit_articles = await prisma.credit_articles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credit_articlesFindUniqueOrThrowArgs>(args: SelectSubset<T, credit_articlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Credit_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesFindFirstArgs} args - Arguments to find a Credit_articles
     * @example
     * // Get one Credit_articles
     * const credit_articles = await prisma.credit_articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credit_articlesFindFirstArgs>(args?: SelectSubset<T, credit_articlesFindFirstArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Credit_articles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesFindFirstOrThrowArgs} args - Arguments to find a Credit_articles
     * @example
     * // Get one Credit_articles
     * const credit_articles = await prisma.credit_articles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credit_articlesFindFirstOrThrowArgs>(args?: SelectSubset<T, credit_articlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Credit_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credit_articles
     * const credit_articles = await prisma.credit_articles.findMany()
     * 
     * // Get first 10 Credit_articles
     * const credit_articles = await prisma.credit_articles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credit_articlesWithIdOnly = await prisma.credit_articles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends credit_articlesFindManyArgs>(args?: SelectSubset<T, credit_articlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Credit_articles.
     * @param {credit_articlesCreateArgs} args - Arguments to create a Credit_articles.
     * @example
     * // Create one Credit_articles
     * const Credit_articles = await prisma.credit_articles.create({
     *   data: {
     *     // ... data to create a Credit_articles
     *   }
     * })
     * 
     */
    create<T extends credit_articlesCreateArgs>(args: SelectSubset<T, credit_articlesCreateArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Credit_articles.
     * @param {credit_articlesCreateManyArgs} args - Arguments to create many Credit_articles.
     * @example
     * // Create many Credit_articles
     * const credit_articles = await prisma.credit_articles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credit_articlesCreateManyArgs>(args?: SelectSubset<T, credit_articlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credit_articles and returns the data saved in the database.
     * @param {credit_articlesCreateManyAndReturnArgs} args - Arguments to create many Credit_articles.
     * @example
     * // Create many Credit_articles
     * const credit_articles = await prisma.credit_articles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credit_articles and only return the `id`
     * const credit_articlesWithIdOnly = await prisma.credit_articles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credit_articlesCreateManyAndReturnArgs>(args?: SelectSubset<T, credit_articlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Credit_articles.
     * @param {credit_articlesDeleteArgs} args - Arguments to delete one Credit_articles.
     * @example
     * // Delete one Credit_articles
     * const Credit_articles = await prisma.credit_articles.delete({
     *   where: {
     *     // ... filter to delete one Credit_articles
     *   }
     * })
     * 
     */
    delete<T extends credit_articlesDeleteArgs>(args: SelectSubset<T, credit_articlesDeleteArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Credit_articles.
     * @param {credit_articlesUpdateArgs} args - Arguments to update one Credit_articles.
     * @example
     * // Update one Credit_articles
     * const credit_articles = await prisma.credit_articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credit_articlesUpdateArgs>(args: SelectSubset<T, credit_articlesUpdateArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Credit_articles.
     * @param {credit_articlesDeleteManyArgs} args - Arguments to filter Credit_articles to delete.
     * @example
     * // Delete a few Credit_articles
     * const { count } = await prisma.credit_articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credit_articlesDeleteManyArgs>(args?: SelectSubset<T, credit_articlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credit_articles
     * const credit_articles = await prisma.credit_articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credit_articlesUpdateManyArgs>(args: SelectSubset<T, credit_articlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credit_articles.
     * @param {credit_articlesUpsertArgs} args - Arguments to update or create a Credit_articles.
     * @example
     * // Update or create a Credit_articles
     * const credit_articles = await prisma.credit_articles.upsert({
     *   create: {
     *     // ... data to create a Credit_articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit_articles we want to update
     *   }
     * })
     */
    upsert<T extends credit_articlesUpsertArgs>(args: SelectSubset<T, credit_articlesUpsertArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Credit_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesCountArgs} args - Arguments to filter Credit_articles to count.
     * @example
     * // Count the number of Credit_articles
     * const count = await prisma.credit_articles.count({
     *   where: {
     *     // ... the filter for the Credit_articles we want to count
     *   }
     * })
    **/
    count<T extends credit_articlesCountArgs>(
      args?: Subset<T, credit_articlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credit_articlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credit_articlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credit_articlesAggregateArgs>(args: Subset<T, Credit_articlesAggregateArgs>): Prisma.PrismaPromise<GetCredit_articlesAggregateType<T>>

    /**
     * Group by Credit_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_articlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credit_articlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credit_articlesGroupByArgs['orderBy'] }
        : { orderBy?: credit_articlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credit_articlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredit_articlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credit_articles model
   */
  readonly fields: credit_articlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credit_articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credit_articlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_article_stars<T extends credit_articles$user_article_starsArgs<ExtArgs> = {}>(args?: Subset<T, credit_articles$user_article_starsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credit_articles model
   */ 
  interface credit_articlesFieldRefs {
    readonly id: FieldRef<"credit_articles", 'Int'>
    readonly title: FieldRef<"credit_articles", 'String'>
    readonly date: FieldRef<"credit_articles", 'DateTime'>
    readonly content: FieldRef<"credit_articles", 'String'>
    readonly link: FieldRef<"credit_articles", 'String'>
    readonly source: FieldRef<"credit_articles", 'String'>
    readonly matched_keywords: FieldRef<"credit_articles", 'String'>
    readonly region: FieldRef<"credit_articles", 'String'>
    readonly sector: FieldRef<"credit_articles", 'String'>
    readonly starred: FieldRef<"credit_articles", 'Boolean'>
    readonly starred_at: FieldRef<"credit_articles", 'DateTime'>
    readonly summary: FieldRef<"credit_articles", 'String'>
    readonly url: FieldRef<"credit_articles", 'String'>
    readonly created_at: FieldRef<"credit_articles", 'DateTime'>
    readonly updated_at: FieldRef<"credit_articles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * credit_articles findUnique
   */
  export type credit_articlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter, which credit_articles to fetch.
     */
    where: credit_articlesWhereUniqueInput
  }

  /**
   * credit_articles findUniqueOrThrow
   */
  export type credit_articlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter, which credit_articles to fetch.
     */
    where: credit_articlesWhereUniqueInput
  }

  /**
   * credit_articles findFirst
   */
  export type credit_articlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter, which credit_articles to fetch.
     */
    where?: credit_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_articles to fetch.
     */
    orderBy?: credit_articlesOrderByWithRelationInput | credit_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_articles.
     */
    cursor?: credit_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_articles.
     */
    distinct?: Credit_articlesScalarFieldEnum | Credit_articlesScalarFieldEnum[]
  }

  /**
   * credit_articles findFirstOrThrow
   */
  export type credit_articlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter, which credit_articles to fetch.
     */
    where?: credit_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_articles to fetch.
     */
    orderBy?: credit_articlesOrderByWithRelationInput | credit_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_articles.
     */
    cursor?: credit_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_articles.
     */
    distinct?: Credit_articlesScalarFieldEnum | Credit_articlesScalarFieldEnum[]
  }

  /**
   * credit_articles findMany
   */
  export type credit_articlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter, which credit_articles to fetch.
     */
    where?: credit_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_articles to fetch.
     */
    orderBy?: credit_articlesOrderByWithRelationInput | credit_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credit_articles.
     */
    cursor?: credit_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_articles.
     */
    skip?: number
    distinct?: Credit_articlesScalarFieldEnum | Credit_articlesScalarFieldEnum[]
  }

  /**
   * credit_articles create
   */
  export type credit_articlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * The data needed to create a credit_articles.
     */
    data?: XOR<credit_articlesCreateInput, credit_articlesUncheckedCreateInput>
  }

  /**
   * credit_articles createMany
   */
  export type credit_articlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credit_articles.
     */
    data: credit_articlesCreateManyInput | credit_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_articles createManyAndReturn
   */
  export type credit_articlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many credit_articles.
     */
    data: credit_articlesCreateManyInput | credit_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_articles update
   */
  export type credit_articlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * The data needed to update a credit_articles.
     */
    data: XOR<credit_articlesUpdateInput, credit_articlesUncheckedUpdateInput>
    /**
     * Choose, which credit_articles to update.
     */
    where: credit_articlesWhereUniqueInput
  }

  /**
   * credit_articles updateMany
   */
  export type credit_articlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credit_articles.
     */
    data: XOR<credit_articlesUpdateManyMutationInput, credit_articlesUncheckedUpdateManyInput>
    /**
     * Filter which credit_articles to update
     */
    where?: credit_articlesWhereInput
  }

  /**
   * credit_articles upsert
   */
  export type credit_articlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * The filter to search for the credit_articles to update in case it exists.
     */
    where: credit_articlesWhereUniqueInput
    /**
     * In case the credit_articles found by the `where` argument doesn't exist, create a new credit_articles with this data.
     */
    create: XOR<credit_articlesCreateInput, credit_articlesUncheckedCreateInput>
    /**
     * In case the credit_articles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credit_articlesUpdateInput, credit_articlesUncheckedUpdateInput>
  }

  /**
   * credit_articles delete
   */
  export type credit_articlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
    /**
     * Filter which credit_articles to delete.
     */
    where: credit_articlesWhereUniqueInput
  }

  /**
   * credit_articles deleteMany
   */
  export type credit_articlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_articles to delete
     */
    where?: credit_articlesWhereInput
  }

  /**
   * credit_articles.user_article_stars
   */
  export type credit_articles$user_article_starsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    where?: user_article_starsWhereInput
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    cursor?: user_article_starsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_article_starsScalarFieldEnum | User_article_starsScalarFieldEnum[]
  }

  /**
   * credit_articles without action
   */
  export type credit_articlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_articles
     */
    select?: credit_articlesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credit_articlesInclude<ExtArgs> | null
  }


  /**
   * Model email_alerts
   */

  export type AggregateEmail_alerts = {
    _count: Email_alertsCountAggregateOutputType | null
    _avg: Email_alertsAvgAggregateOutputType | null
    _sum: Email_alertsSumAggregateOutputType | null
    _min: Email_alertsMinAggregateOutputType | null
    _max: Email_alertsMaxAggregateOutputType | null
  }

  export type Email_alertsAvgAggregateOutputType = {
    id: number | null
  }

  export type Email_alertsSumAggregateOutputType = {
    id: number | null
  }

  export type Email_alertsMinAggregateOutputType = {
    id: number | null
    email: string | null
    alert_type: string | null
    subscription_date: Date | null
    active: boolean | null
  }

  export type Email_alertsMaxAggregateOutputType = {
    id: number | null
    email: string | null
    alert_type: string | null
    subscription_date: Date | null
    active: boolean | null
  }

  export type Email_alertsCountAggregateOutputType = {
    id: number
    email: number
    alert_type: number
    subscription_date: number
    active: number
    _all: number
  }


  export type Email_alertsAvgAggregateInputType = {
    id?: true
  }

  export type Email_alertsSumAggregateInputType = {
    id?: true
  }

  export type Email_alertsMinAggregateInputType = {
    id?: true
    email?: true
    alert_type?: true
    subscription_date?: true
    active?: true
  }

  export type Email_alertsMaxAggregateInputType = {
    id?: true
    email?: true
    alert_type?: true
    subscription_date?: true
    active?: true
  }

  export type Email_alertsCountAggregateInputType = {
    id?: true
    email?: true
    alert_type?: true
    subscription_date?: true
    active?: true
    _all?: true
  }

  export type Email_alertsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_alerts to aggregate.
     */
    where?: email_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_alerts to fetch.
     */
    orderBy?: email_alertsOrderByWithRelationInput | email_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_alerts
    **/
    _count?: true | Email_alertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Email_alertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Email_alertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_alertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_alertsMaxAggregateInputType
  }

  export type GetEmail_alertsAggregateType<T extends Email_alertsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_alerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_alerts[P]>
      : GetScalarType<T[P], AggregateEmail_alerts[P]>
  }




  export type email_alertsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_alertsWhereInput
    orderBy?: email_alertsOrderByWithAggregationInput | email_alertsOrderByWithAggregationInput[]
    by: Email_alertsScalarFieldEnum[] | Email_alertsScalarFieldEnum
    having?: email_alertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_alertsCountAggregateInputType | true
    _avg?: Email_alertsAvgAggregateInputType
    _sum?: Email_alertsSumAggregateInputType
    _min?: Email_alertsMinAggregateInputType
    _max?: Email_alertsMaxAggregateInputType
  }

  export type Email_alertsGroupByOutputType = {
    id: number
    email: string
    alert_type: string
    subscription_date: Date
    active: boolean
    _count: Email_alertsCountAggregateOutputType | null
    _avg: Email_alertsAvgAggregateOutputType | null
    _sum: Email_alertsSumAggregateOutputType | null
    _min: Email_alertsMinAggregateOutputType | null
    _max: Email_alertsMaxAggregateOutputType | null
  }

  type GetEmail_alertsGroupByPayload<T extends email_alertsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_alertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_alertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_alertsGroupByOutputType[P]>
            : GetScalarType<T[P], Email_alertsGroupByOutputType[P]>
        }
      >
    >


  export type email_alertsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    alert_type?: boolean
    subscription_date?: boolean
    active?: boolean
  }, ExtArgs["result"]["email_alerts"]>

  export type email_alertsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    alert_type?: boolean
    subscription_date?: boolean
    active?: boolean
  }, ExtArgs["result"]["email_alerts"]>

  export type email_alertsSelectScalar = {
    id?: boolean
    email?: boolean
    alert_type?: boolean
    subscription_date?: boolean
    active?: boolean
  }


  export type $email_alertsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_alerts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      alert_type: string
      subscription_date: Date
      active: boolean
    }, ExtArgs["result"]["email_alerts"]>
    composites: {}
  }

  type email_alertsGetPayload<S extends boolean | null | undefined | email_alertsDefaultArgs> = $Result.GetResult<Prisma.$email_alertsPayload, S>

  type email_alertsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<email_alertsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Email_alertsCountAggregateInputType | true
    }

  export interface email_alertsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_alerts'], meta: { name: 'email_alerts' } }
    /**
     * Find zero or one Email_alerts that matches the filter.
     * @param {email_alertsFindUniqueArgs} args - Arguments to find a Email_alerts
     * @example
     * // Get one Email_alerts
     * const email_alerts = await prisma.email_alerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_alertsFindUniqueArgs>(args: SelectSubset<T, email_alertsFindUniqueArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Email_alerts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {email_alertsFindUniqueOrThrowArgs} args - Arguments to find a Email_alerts
     * @example
     * // Get one Email_alerts
     * const email_alerts = await prisma.email_alerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_alertsFindUniqueOrThrowArgs>(args: SelectSubset<T, email_alertsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Email_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsFindFirstArgs} args - Arguments to find a Email_alerts
     * @example
     * // Get one Email_alerts
     * const email_alerts = await prisma.email_alerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_alertsFindFirstArgs>(args?: SelectSubset<T, email_alertsFindFirstArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Email_alerts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsFindFirstOrThrowArgs} args - Arguments to find a Email_alerts
     * @example
     * // Get one Email_alerts
     * const email_alerts = await prisma.email_alerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_alertsFindFirstOrThrowArgs>(args?: SelectSubset<T, email_alertsFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Email_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_alerts
     * const email_alerts = await prisma.email_alerts.findMany()
     * 
     * // Get first 10 Email_alerts
     * const email_alerts = await prisma.email_alerts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_alertsWithIdOnly = await prisma.email_alerts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_alertsFindManyArgs>(args?: SelectSubset<T, email_alertsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Email_alerts.
     * @param {email_alertsCreateArgs} args - Arguments to create a Email_alerts.
     * @example
     * // Create one Email_alerts
     * const Email_alerts = await prisma.email_alerts.create({
     *   data: {
     *     // ... data to create a Email_alerts
     *   }
     * })
     * 
     */
    create<T extends email_alertsCreateArgs>(args: SelectSubset<T, email_alertsCreateArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Email_alerts.
     * @param {email_alertsCreateManyArgs} args - Arguments to create many Email_alerts.
     * @example
     * // Create many Email_alerts
     * const email_alerts = await prisma.email_alerts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_alertsCreateManyArgs>(args?: SelectSubset<T, email_alertsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_alerts and returns the data saved in the database.
     * @param {email_alertsCreateManyAndReturnArgs} args - Arguments to create many Email_alerts.
     * @example
     * // Create many Email_alerts
     * const email_alerts = await prisma.email_alerts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_alerts and only return the `id`
     * const email_alertsWithIdOnly = await prisma.email_alerts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_alertsCreateManyAndReturnArgs>(args?: SelectSubset<T, email_alertsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Email_alerts.
     * @param {email_alertsDeleteArgs} args - Arguments to delete one Email_alerts.
     * @example
     * // Delete one Email_alerts
     * const Email_alerts = await prisma.email_alerts.delete({
     *   where: {
     *     // ... filter to delete one Email_alerts
     *   }
     * })
     * 
     */
    delete<T extends email_alertsDeleteArgs>(args: SelectSubset<T, email_alertsDeleteArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Email_alerts.
     * @param {email_alertsUpdateArgs} args - Arguments to update one Email_alerts.
     * @example
     * // Update one Email_alerts
     * const email_alerts = await prisma.email_alerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_alertsUpdateArgs>(args: SelectSubset<T, email_alertsUpdateArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Email_alerts.
     * @param {email_alertsDeleteManyArgs} args - Arguments to filter Email_alerts to delete.
     * @example
     * // Delete a few Email_alerts
     * const { count } = await prisma.email_alerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_alertsDeleteManyArgs>(args?: SelectSubset<T, email_alertsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_alerts
     * const email_alerts = await prisma.email_alerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_alertsUpdateManyArgs>(args: SelectSubset<T, email_alertsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email_alerts.
     * @param {email_alertsUpsertArgs} args - Arguments to update or create a Email_alerts.
     * @example
     * // Update or create a Email_alerts
     * const email_alerts = await prisma.email_alerts.upsert({
     *   create: {
     *     // ... data to create a Email_alerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_alerts we want to update
     *   }
     * })
     */
    upsert<T extends email_alertsUpsertArgs>(args: SelectSubset<T, email_alertsUpsertArgs<ExtArgs>>): Prisma__email_alertsClient<$Result.GetResult<Prisma.$email_alertsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Email_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsCountArgs} args - Arguments to filter Email_alerts to count.
     * @example
     * // Count the number of Email_alerts
     * const count = await prisma.email_alerts.count({
     *   where: {
     *     // ... the filter for the Email_alerts we want to count
     *   }
     * })
    **/
    count<T extends email_alertsCountArgs>(
      args?: Subset<T, email_alertsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_alertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_alertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_alertsAggregateArgs>(args: Subset<T, Email_alertsAggregateArgs>): Prisma.PrismaPromise<GetEmail_alertsAggregateType<T>>

    /**
     * Group by Email_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_alertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_alertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_alertsGroupByArgs['orderBy'] }
        : { orderBy?: email_alertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_alertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_alertsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_alerts model
   */
  readonly fields: email_alertsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_alerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_alertsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_alerts model
   */ 
  interface email_alertsFieldRefs {
    readonly id: FieldRef<"email_alerts", 'Int'>
    readonly email: FieldRef<"email_alerts", 'String'>
    readonly alert_type: FieldRef<"email_alerts", 'String'>
    readonly subscription_date: FieldRef<"email_alerts", 'DateTime'>
    readonly active: FieldRef<"email_alerts", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * email_alerts findUnique
   */
  export type email_alertsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter, which email_alerts to fetch.
     */
    where: email_alertsWhereUniqueInput
  }

  /**
   * email_alerts findUniqueOrThrow
   */
  export type email_alertsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter, which email_alerts to fetch.
     */
    where: email_alertsWhereUniqueInput
  }

  /**
   * email_alerts findFirst
   */
  export type email_alertsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter, which email_alerts to fetch.
     */
    where?: email_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_alerts to fetch.
     */
    orderBy?: email_alertsOrderByWithRelationInput | email_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_alerts.
     */
    cursor?: email_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_alerts.
     */
    distinct?: Email_alertsScalarFieldEnum | Email_alertsScalarFieldEnum[]
  }

  /**
   * email_alerts findFirstOrThrow
   */
  export type email_alertsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter, which email_alerts to fetch.
     */
    where?: email_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_alerts to fetch.
     */
    orderBy?: email_alertsOrderByWithRelationInput | email_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_alerts.
     */
    cursor?: email_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_alerts.
     */
    distinct?: Email_alertsScalarFieldEnum | Email_alertsScalarFieldEnum[]
  }

  /**
   * email_alerts findMany
   */
  export type email_alertsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter, which email_alerts to fetch.
     */
    where?: email_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_alerts to fetch.
     */
    orderBy?: email_alertsOrderByWithRelationInput | email_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_alerts.
     */
    cursor?: email_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_alerts.
     */
    skip?: number
    distinct?: Email_alertsScalarFieldEnum | Email_alertsScalarFieldEnum[]
  }

  /**
   * email_alerts create
   */
  export type email_alertsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * The data needed to create a email_alerts.
     */
    data: XOR<email_alertsCreateInput, email_alertsUncheckedCreateInput>
  }

  /**
   * email_alerts createMany
   */
  export type email_alertsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_alerts.
     */
    data: email_alertsCreateManyInput | email_alertsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_alerts createManyAndReturn
   */
  export type email_alertsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many email_alerts.
     */
    data: email_alertsCreateManyInput | email_alertsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_alerts update
   */
  export type email_alertsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * The data needed to update a email_alerts.
     */
    data: XOR<email_alertsUpdateInput, email_alertsUncheckedUpdateInput>
    /**
     * Choose, which email_alerts to update.
     */
    where: email_alertsWhereUniqueInput
  }

  /**
   * email_alerts updateMany
   */
  export type email_alertsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_alerts.
     */
    data: XOR<email_alertsUpdateManyMutationInput, email_alertsUncheckedUpdateManyInput>
    /**
     * Filter which email_alerts to update
     */
    where?: email_alertsWhereInput
  }

  /**
   * email_alerts upsert
   */
  export type email_alertsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * The filter to search for the email_alerts to update in case it exists.
     */
    where: email_alertsWhereUniqueInput
    /**
     * In case the email_alerts found by the `where` argument doesn't exist, create a new email_alerts with this data.
     */
    create: XOR<email_alertsCreateInput, email_alertsUncheckedCreateInput>
    /**
     * In case the email_alerts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_alertsUpdateInput, email_alertsUncheckedUpdateInput>
  }

  /**
   * email_alerts delete
   */
  export type email_alertsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
    /**
     * Filter which email_alerts to delete.
     */
    where: email_alertsWhereUniqueInput
  }

  /**
   * email_alerts deleteMany
   */
  export type email_alertsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_alerts to delete
     */
    where?: email_alertsWhereInput
  }

  /**
   * email_alerts without action
   */
  export type email_alertsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_alerts
     */
    select?: email_alertsSelect<ExtArgs> | null
  }


  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    max_attendees: number | null
    price: number | null
    created_by_id: number | null
    view_count: number | null
    id: number | null
  }

  export type EventSumAggregateOutputType = {
    max_attendees: number | null
    price: number | null
    created_by_id: number | null
    view_count: number | null
    id: number | null
  }

  export type EventMinAggregateOutputType = {
    title: string | null
    slug: string | null
    description: string | null
    event_type: string | null
    location: string | null
    venue: string | null
    is_virtual: boolean | null
    virtual_link: string | null
    start_date: Date | null
    end_date: Date | null
    timezone: string | null
    registration_link: string | null
    registration_deadline: Date | null
    max_attendees: number | null
    price: number | null
    currency: string | null
    organizer: string | null
    organizer_email: string | null
    organizer_phone: string | null
    agenda: string | null
    source: string | null
    source_url: string | null
    is_published: boolean | null
    is_featured: boolean | null
    is_cancelled: boolean | null
    cancellation_reason: string | null
    created_by_id: number | null
    view_count: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type EventMaxAggregateOutputType = {
    title: string | null
    slug: string | null
    description: string | null
    event_type: string | null
    location: string | null
    venue: string | null
    is_virtual: boolean | null
    virtual_link: string | null
    start_date: Date | null
    end_date: Date | null
    timezone: string | null
    registration_link: string | null
    registration_deadline: Date | null
    max_attendees: number | null
    price: number | null
    currency: string | null
    organizer: string | null
    organizer_email: string | null
    organizer_phone: string | null
    agenda: string | null
    source: string | null
    source_url: string | null
    is_published: boolean | null
    is_featured: boolean | null
    is_cancelled: boolean | null
    cancellation_reason: string | null
    created_by_id: number | null
    view_count: number | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type EventCountAggregateOutputType = {
    title: number
    slug: number
    description: number
    event_type: number
    location: number
    venue: number
    is_virtual: number
    virtual_link: number
    start_date: number
    end_date: number
    timezone: number
    registration_link: number
    registration_deadline: number
    max_attendees: number
    price: number
    currency: number
    organizer: number
    organizer_email: number
    organizer_phone: number
    sponsors: number
    agenda: number
    speakers: number
    tags: number
    source: number
    source_url: number
    is_published: number
    is_featured: number
    is_cancelled: number
    cancellation_reason: number
    created_by_id: number
    view_count: number
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    max_attendees?: true
    price?: true
    created_by_id?: true
    view_count?: true
    id?: true
  }

  export type EventSumAggregateInputType = {
    max_attendees?: true
    price?: true
    created_by_id?: true
    view_count?: true
    id?: true
  }

  export type EventMinAggregateInputType = {
    title?: true
    slug?: true
    description?: true
    event_type?: true
    location?: true
    venue?: true
    is_virtual?: true
    virtual_link?: true
    start_date?: true
    end_date?: true
    timezone?: true
    registration_link?: true
    registration_deadline?: true
    max_attendees?: true
    price?: true
    currency?: true
    organizer?: true
    organizer_email?: true
    organizer_phone?: true
    agenda?: true
    source?: true
    source_url?: true
    is_published?: true
    is_featured?: true
    is_cancelled?: true
    cancellation_reason?: true
    created_by_id?: true
    view_count?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type EventMaxAggregateInputType = {
    title?: true
    slug?: true
    description?: true
    event_type?: true
    location?: true
    venue?: true
    is_virtual?: true
    virtual_link?: true
    start_date?: true
    end_date?: true
    timezone?: true
    registration_link?: true
    registration_deadline?: true
    max_attendees?: true
    price?: true
    currency?: true
    organizer?: true
    organizer_email?: true
    organizer_phone?: true
    agenda?: true
    source?: true
    source_url?: true
    is_published?: true
    is_featured?: true
    is_cancelled?: true
    cancellation_reason?: true
    created_by_id?: true
    view_count?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type EventCountAggregateInputType = {
    title?: true
    slug?: true
    description?: true
    event_type?: true
    location?: true
    venue?: true
    is_virtual?: true
    virtual_link?: true
    start_date?: true
    end_date?: true
    timezone?: true
    registration_link?: true
    registration_deadline?: true
    max_attendees?: true
    price?: true
    currency?: true
    organizer?: true
    organizer_email?: true
    organizer_phone?: true
    sponsors?: true
    agenda?: true
    speakers?: true
    tags?: true
    source?: true
    source_url?: true
    is_published?: true
    is_featured?: true
    is_cancelled?: true
    cancellation_reason?: true
    created_by_id?: true
    view_count?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventWhereInput
    orderBy?: eventOrderByWithAggregationInput | eventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    title: string
    slug: string
    description: string | null
    event_type: string | null
    location: string | null
    venue: string | null
    is_virtual: boolean
    virtual_link: string | null
    start_date: Date
    end_date: Date | null
    timezone: string | null
    registration_link: string | null
    registration_deadline: Date | null
    max_attendees: number | null
    price: number | null
    currency: string | null
    organizer: string | null
    organizer_email: string | null
    organizer_phone: string | null
    sponsors: JsonValue | null
    agenda: string | null
    speakers: JsonValue | null
    tags: JsonValue | null
    source: string | null
    source_url: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason: string | null
    created_by_id: number | null
    view_count: number
    id: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    slug?: boolean
    description?: boolean
    event_type?: boolean
    location?: boolean
    venue?: boolean
    is_virtual?: boolean
    virtual_link?: boolean
    start_date?: boolean
    end_date?: boolean
    timezone?: boolean
    registration_link?: boolean
    registration_deadline?: boolean
    max_attendees?: boolean
    price?: boolean
    currency?: boolean
    organizer?: boolean
    organizer_email?: boolean
    organizer_phone?: boolean
    sponsors?: boolean
    agenda?: boolean
    speakers?: boolean
    tags?: boolean
    source?: boolean
    source_url?: boolean
    is_published?: boolean
    is_featured?: boolean
    is_cancelled?: boolean
    cancellation_reason?: boolean
    created_by_id?: boolean
    view_count?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user?: boolean | event$userArgs<ExtArgs>
    eventregistration?: boolean | event$eventregistrationArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    slug?: boolean
    description?: boolean
    event_type?: boolean
    location?: boolean
    venue?: boolean
    is_virtual?: boolean
    virtual_link?: boolean
    start_date?: boolean
    end_date?: boolean
    timezone?: boolean
    registration_link?: boolean
    registration_deadline?: boolean
    max_attendees?: boolean
    price?: boolean
    currency?: boolean
    organizer?: boolean
    organizer_email?: boolean
    organizer_phone?: boolean
    sponsors?: boolean
    agenda?: boolean
    speakers?: boolean
    tags?: boolean
    source?: boolean
    source_url?: boolean
    is_published?: boolean
    is_featured?: boolean
    is_cancelled?: boolean
    cancellation_reason?: boolean
    created_by_id?: boolean
    view_count?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user?: boolean | event$userArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type eventSelectScalar = {
    title?: boolean
    slug?: boolean
    description?: boolean
    event_type?: boolean
    location?: boolean
    venue?: boolean
    is_virtual?: boolean
    virtual_link?: boolean
    start_date?: boolean
    end_date?: boolean
    timezone?: boolean
    registration_link?: boolean
    registration_deadline?: boolean
    max_attendees?: boolean
    price?: boolean
    currency?: boolean
    organizer?: boolean
    organizer_email?: boolean
    organizer_phone?: boolean
    sponsors?: boolean
    agenda?: boolean
    speakers?: boolean
    tags?: boolean
    source?: boolean
    source_url?: boolean
    is_published?: boolean
    is_featured?: boolean
    is_cancelled?: boolean
    cancellation_reason?: boolean
    created_by_id?: boolean
    view_count?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
  }

  export type eventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | event$userArgs<ExtArgs>
    eventregistration?: boolean | event$eventregistrationArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type eventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | event$userArgs<ExtArgs>
  }

  export type $eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      eventregistration: Prisma.$eventregistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      title: string
      slug: string
      description: string | null
      event_type: string | null
      location: string | null
      venue: string | null
      is_virtual: boolean
      virtual_link: string | null
      start_date: Date
      end_date: Date | null
      timezone: string | null
      registration_link: string | null
      registration_deadline: Date | null
      max_attendees: number | null
      price: number | null
      currency: string | null
      organizer: string | null
      organizer_email: string | null
      organizer_phone: string | null
      sponsors: Prisma.JsonValue | null
      agenda: string | null
      speakers: Prisma.JsonValue | null
      tags: Prisma.JsonValue | null
      source: string | null
      source_url: string | null
      is_published: boolean
      is_featured: boolean
      is_cancelled: boolean
      cancellation_reason: string | null
      created_by_id: number | null
      view_count: number
      id: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type eventGetPayload<S extends boolean | null | undefined | eventDefaultArgs> = $Result.GetResult<Prisma.$eventPayload, S>

  type eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event'], meta: { name: 'event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventFindUniqueArgs>(args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs>(args: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventFindFirstArgs>(args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs>(args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `title`
     * const eventWithTitleOnly = await prisma.event.findMany({ select: { title: true } })
     * 
     */
    findMany<T extends eventFindManyArgs>(args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends eventCreateArgs>(args: SelectSubset<T, eventCreateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {eventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventCreateManyArgs>(args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {eventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `title`
     * const eventWithTitleOnly = await prisma.event.createManyAndReturn({ 
     *   select: { title: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends eventCreateManyAndReturnArgs>(args?: SelectSubset<T, eventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends eventDeleteArgs>(args: SelectSubset<T, eventDeleteArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventUpdateArgs>(args: SelectSubset<T, eventUpdateArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventDeleteManyArgs>(args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventUpdateManyArgs>(args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends eventUpsertArgs>(args: SelectSubset<T, eventUpsertArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs['orderBy'] }
        : { orderBy?: eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event model
   */
  readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends event$userArgs<ExtArgs> = {}>(args?: Subset<T, event$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    eventregistration<T extends event$eventregistrationArgs<ExtArgs> = {}>(args?: Subset<T, event$eventregistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event model
   */ 
  interface eventFieldRefs {
    readonly title: FieldRef<"event", 'String'>
    readonly slug: FieldRef<"event", 'String'>
    readonly description: FieldRef<"event", 'String'>
    readonly event_type: FieldRef<"event", 'String'>
    readonly location: FieldRef<"event", 'String'>
    readonly venue: FieldRef<"event", 'String'>
    readonly is_virtual: FieldRef<"event", 'Boolean'>
    readonly virtual_link: FieldRef<"event", 'String'>
    readonly start_date: FieldRef<"event", 'DateTime'>
    readonly end_date: FieldRef<"event", 'DateTime'>
    readonly timezone: FieldRef<"event", 'String'>
    readonly registration_link: FieldRef<"event", 'String'>
    readonly registration_deadline: FieldRef<"event", 'DateTime'>
    readonly max_attendees: FieldRef<"event", 'Int'>
    readonly price: FieldRef<"event", 'Float'>
    readonly currency: FieldRef<"event", 'String'>
    readonly organizer: FieldRef<"event", 'String'>
    readonly organizer_email: FieldRef<"event", 'String'>
    readonly organizer_phone: FieldRef<"event", 'String'>
    readonly sponsors: FieldRef<"event", 'Json'>
    readonly agenda: FieldRef<"event", 'String'>
    readonly speakers: FieldRef<"event", 'Json'>
    readonly tags: FieldRef<"event", 'Json'>
    readonly source: FieldRef<"event", 'String'>
    readonly source_url: FieldRef<"event", 'String'>
    readonly is_published: FieldRef<"event", 'Boolean'>
    readonly is_featured: FieldRef<"event", 'Boolean'>
    readonly is_cancelled: FieldRef<"event", 'Boolean'>
    readonly cancellation_reason: FieldRef<"event", 'String'>
    readonly created_by_id: FieldRef<"event", 'Int'>
    readonly view_count: FieldRef<"event", 'Int'>
    readonly id: FieldRef<"event", 'Int'>
    readonly created_at: FieldRef<"event", 'DateTime'>
    readonly updated_at: FieldRef<"event", 'DateTime'>
    readonly is_deleted: FieldRef<"event", 'Boolean'>
    readonly deleted_at: FieldRef<"event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event findFirst
   */
  export type eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event findMany
   */
  export type eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * event create
   */
  export type eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>
  }

  /**
   * event createMany
   */
  export type eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event createManyAndReturn
   */
  export type eventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * event update
   */
  export type eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventWhereInput
  }

  /**
   * event upsert
   */
  export type eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>
  }

  /**
   * event delete
   */
  export type eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput
  }

  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput
  }

  /**
   * event.user
   */
  export type event$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * event.eventregistration
   */
  export type event$eventregistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    where?: eventregistrationWhereInput
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    cursor?: eventregistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventregistrationScalarFieldEnum | EventregistrationScalarFieldEnum[]
  }

  /**
   * event without action
   */
  export type eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
  }


  /**
   * Model eventregistration
   */

  export type AggregateEventregistration = {
    _count: EventregistrationCountAggregateOutputType | null
    _avg: EventregistrationAvgAggregateOutputType | null
    _sum: EventregistrationSumAggregateOutputType | null
    _min: EventregistrationMinAggregateOutputType | null
    _max: EventregistrationMaxAggregateOutputType | null
  }

  export type EventregistrationAvgAggregateOutputType = {
    event_id: number | null
    user_id: number | null
    id: number | null
  }

  export type EventregistrationSumAggregateOutputType = {
    event_id: number | null
    user_id: number | null
    id: number | null
  }

  export type EventregistrationMinAggregateOutputType = {
    event_id: number | null
    user_id: number | null
    registered_at: Date | null
    is_confirmed: boolean | null
    is_cancelled: boolean | null
    cancelled_at: Date | null
    cancellation_reason: string | null
    attended: boolean | null
    check_in_time: Date | null
    dietary_requirements: string | null
    special_requirements: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EventregistrationMaxAggregateOutputType = {
    event_id: number | null
    user_id: number | null
    registered_at: Date | null
    is_confirmed: boolean | null
    is_cancelled: boolean | null
    cancelled_at: Date | null
    cancellation_reason: string | null
    attended: boolean | null
    check_in_time: Date | null
    dietary_requirements: string | null
    special_requirements: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EventregistrationCountAggregateOutputType = {
    event_id: number
    user_id: number
    registered_at: number
    is_confirmed: number
    is_cancelled: number
    cancelled_at: number
    cancellation_reason: number
    attended: number
    check_in_time: number
    dietary_requirements: number
    special_requirements: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EventregistrationAvgAggregateInputType = {
    event_id?: true
    user_id?: true
    id?: true
  }

  export type EventregistrationSumAggregateInputType = {
    event_id?: true
    user_id?: true
    id?: true
  }

  export type EventregistrationMinAggregateInputType = {
    event_id?: true
    user_id?: true
    registered_at?: true
    is_confirmed?: true
    is_cancelled?: true
    cancelled_at?: true
    cancellation_reason?: true
    attended?: true
    check_in_time?: true
    dietary_requirements?: true
    special_requirements?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type EventregistrationMaxAggregateInputType = {
    event_id?: true
    user_id?: true
    registered_at?: true
    is_confirmed?: true
    is_cancelled?: true
    cancelled_at?: true
    cancellation_reason?: true
    attended?: true
    check_in_time?: true
    dietary_requirements?: true
    special_requirements?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type EventregistrationCountAggregateInputType = {
    event_id?: true
    user_id?: true
    registered_at?: true
    is_confirmed?: true
    is_cancelled?: true
    cancelled_at?: true
    cancellation_reason?: true
    attended?: true
    check_in_time?: true
    dietary_requirements?: true
    special_requirements?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EventregistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventregistration to aggregate.
     */
    where?: eventregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventregistrations to fetch.
     */
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventregistrations
    **/
    _count?: true | EventregistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventregistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventregistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventregistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventregistrationMaxAggregateInputType
  }

  export type GetEventregistrationAggregateType<T extends EventregistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventregistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventregistration[P]>
      : GetScalarType<T[P], AggregateEventregistration[P]>
  }




  export type eventregistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventregistrationWhereInput
    orderBy?: eventregistrationOrderByWithAggregationInput | eventregistrationOrderByWithAggregationInput[]
    by: EventregistrationScalarFieldEnum[] | EventregistrationScalarFieldEnum
    having?: eventregistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventregistrationCountAggregateInputType | true
    _avg?: EventregistrationAvgAggregateInputType
    _sum?: EventregistrationSumAggregateInputType
    _min?: EventregistrationMinAggregateInputType
    _max?: EventregistrationMaxAggregateInputType
  }

  export type EventregistrationGroupByOutputType = {
    event_id: number
    user_id: number
    registered_at: Date
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at: Date | null
    cancellation_reason: string | null
    attended: boolean
    check_in_time: Date | null
    dietary_requirements: string | null
    special_requirements: string | null
    id: number
    created_at: Date
    updated_at: Date
    _count: EventregistrationCountAggregateOutputType | null
    _avg: EventregistrationAvgAggregateOutputType | null
    _sum: EventregistrationSumAggregateOutputType | null
    _min: EventregistrationMinAggregateOutputType | null
    _max: EventregistrationMaxAggregateOutputType | null
  }

  type GetEventregistrationGroupByPayload<T extends eventregistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventregistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventregistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventregistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventregistrationGroupByOutputType[P]>
        }
      >
    >


  export type eventregistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    is_confirmed?: boolean
    is_cancelled?: boolean
    cancelled_at?: boolean
    cancellation_reason?: boolean
    attended?: boolean
    check_in_time?: boolean
    dietary_requirements?: boolean
    special_requirements?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    event?: boolean | eventDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventregistration"]>

  export type eventregistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    is_confirmed?: boolean
    is_cancelled?: boolean
    cancelled_at?: boolean
    cancellation_reason?: boolean
    attended?: boolean
    check_in_time?: boolean
    dietary_requirements?: boolean
    special_requirements?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    event?: boolean | eventDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventregistration"]>

  export type eventregistrationSelectScalar = {
    event_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    is_confirmed?: boolean
    is_cancelled?: boolean
    cancelled_at?: boolean
    cancellation_reason?: boolean
    attended?: boolean
    check_in_time?: boolean
    dietary_requirements?: boolean
    special_requirements?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type eventregistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | eventDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type eventregistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | eventDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $eventregistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "eventregistration"
    objects: {
      event: Prisma.$eventPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: number
      user_id: number
      registered_at: Date
      is_confirmed: boolean
      is_cancelled: boolean
      cancelled_at: Date | null
      cancellation_reason: string | null
      attended: boolean
      check_in_time: Date | null
      dietary_requirements: string | null
      special_requirements: string | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["eventregistration"]>
    composites: {}
  }

  type eventregistrationGetPayload<S extends boolean | null | undefined | eventregistrationDefaultArgs> = $Result.GetResult<Prisma.$eventregistrationPayload, S>

  type eventregistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventregistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventregistrationCountAggregateInputType | true
    }

  export interface eventregistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eventregistration'], meta: { name: 'eventregistration' } }
    /**
     * Find zero or one Eventregistration that matches the filter.
     * @param {eventregistrationFindUniqueArgs} args - Arguments to find a Eventregistration
     * @example
     * // Get one Eventregistration
     * const eventregistration = await prisma.eventregistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventregistrationFindUniqueArgs>(args: SelectSubset<T, eventregistrationFindUniqueArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eventregistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventregistrationFindUniqueOrThrowArgs} args - Arguments to find a Eventregistration
     * @example
     * // Get one Eventregistration
     * const eventregistration = await prisma.eventregistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventregistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, eventregistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eventregistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationFindFirstArgs} args - Arguments to find a Eventregistration
     * @example
     * // Get one Eventregistration
     * const eventregistration = await prisma.eventregistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventregistrationFindFirstArgs>(args?: SelectSubset<T, eventregistrationFindFirstArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eventregistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationFindFirstOrThrowArgs} args - Arguments to find a Eventregistration
     * @example
     * // Get one Eventregistration
     * const eventregistration = await prisma.eventregistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventregistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, eventregistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eventregistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventregistrations
     * const eventregistrations = await prisma.eventregistration.findMany()
     * 
     * // Get first 10 Eventregistrations
     * const eventregistrations = await prisma.eventregistration.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const eventregistrationWithEvent_idOnly = await prisma.eventregistration.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends eventregistrationFindManyArgs>(args?: SelectSubset<T, eventregistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eventregistration.
     * @param {eventregistrationCreateArgs} args - Arguments to create a Eventregistration.
     * @example
     * // Create one Eventregistration
     * const Eventregistration = await prisma.eventregistration.create({
     *   data: {
     *     // ... data to create a Eventregistration
     *   }
     * })
     * 
     */
    create<T extends eventregistrationCreateArgs>(args: SelectSubset<T, eventregistrationCreateArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eventregistrations.
     * @param {eventregistrationCreateManyArgs} args - Arguments to create many Eventregistrations.
     * @example
     * // Create many Eventregistrations
     * const eventregistration = await prisma.eventregistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventregistrationCreateManyArgs>(args?: SelectSubset<T, eventregistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Eventregistrations and returns the data saved in the database.
     * @param {eventregistrationCreateManyAndReturnArgs} args - Arguments to create many Eventregistrations.
     * @example
     * // Create many Eventregistrations
     * const eventregistration = await prisma.eventregistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Eventregistrations and only return the `event_id`
     * const eventregistrationWithEvent_idOnly = await prisma.eventregistration.createManyAndReturn({ 
     *   select: { event_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends eventregistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, eventregistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Eventregistration.
     * @param {eventregistrationDeleteArgs} args - Arguments to delete one Eventregistration.
     * @example
     * // Delete one Eventregistration
     * const Eventregistration = await prisma.eventregistration.delete({
     *   where: {
     *     // ... filter to delete one Eventregistration
     *   }
     * })
     * 
     */
    delete<T extends eventregistrationDeleteArgs>(args: SelectSubset<T, eventregistrationDeleteArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eventregistration.
     * @param {eventregistrationUpdateArgs} args - Arguments to update one Eventregistration.
     * @example
     * // Update one Eventregistration
     * const eventregistration = await prisma.eventregistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventregistrationUpdateArgs>(args: SelectSubset<T, eventregistrationUpdateArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eventregistrations.
     * @param {eventregistrationDeleteManyArgs} args - Arguments to filter Eventregistrations to delete.
     * @example
     * // Delete a few Eventregistrations
     * const { count } = await prisma.eventregistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventregistrationDeleteManyArgs>(args?: SelectSubset<T, eventregistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventregistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventregistrations
     * const eventregistration = await prisma.eventregistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventregistrationUpdateManyArgs>(args: SelectSubset<T, eventregistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventregistration.
     * @param {eventregistrationUpsertArgs} args - Arguments to update or create a Eventregistration.
     * @example
     * // Update or create a Eventregistration
     * const eventregistration = await prisma.eventregistration.upsert({
     *   create: {
     *     // ... data to create a Eventregistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventregistration we want to update
     *   }
     * })
     */
    upsert<T extends eventregistrationUpsertArgs>(args: SelectSubset<T, eventregistrationUpsertArgs<ExtArgs>>): Prisma__eventregistrationClient<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eventregistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationCountArgs} args - Arguments to filter Eventregistrations to count.
     * @example
     * // Count the number of Eventregistrations
     * const count = await prisma.eventregistration.count({
     *   where: {
     *     // ... the filter for the Eventregistrations we want to count
     *   }
     * })
    **/
    count<T extends eventregistrationCountArgs>(
      args?: Subset<T, eventregistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventregistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventregistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventregistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventregistrationAggregateArgs>(args: Subset<T, EventregistrationAggregateArgs>): Prisma.PrismaPromise<GetEventregistrationAggregateType<T>>

    /**
     * Group by Eventregistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventregistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventregistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventregistrationGroupByArgs['orderBy'] }
        : { orderBy?: eventregistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventregistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventregistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eventregistration model
   */
  readonly fields: eventregistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eventregistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventregistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends eventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, eventDefaultArgs<ExtArgs>>): Prisma__eventClient<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the eventregistration model
   */ 
  interface eventregistrationFieldRefs {
    readonly event_id: FieldRef<"eventregistration", 'Int'>
    readonly user_id: FieldRef<"eventregistration", 'Int'>
    readonly registered_at: FieldRef<"eventregistration", 'DateTime'>
    readonly is_confirmed: FieldRef<"eventregistration", 'Boolean'>
    readonly is_cancelled: FieldRef<"eventregistration", 'Boolean'>
    readonly cancelled_at: FieldRef<"eventregistration", 'DateTime'>
    readonly cancellation_reason: FieldRef<"eventregistration", 'String'>
    readonly attended: FieldRef<"eventregistration", 'Boolean'>
    readonly check_in_time: FieldRef<"eventregistration", 'DateTime'>
    readonly dietary_requirements: FieldRef<"eventregistration", 'String'>
    readonly special_requirements: FieldRef<"eventregistration", 'String'>
    readonly id: FieldRef<"eventregistration", 'Int'>
    readonly created_at: FieldRef<"eventregistration", 'DateTime'>
    readonly updated_at: FieldRef<"eventregistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * eventregistration findUnique
   */
  export type eventregistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter, which eventregistration to fetch.
     */
    where: eventregistrationWhereUniqueInput
  }

  /**
   * eventregistration findUniqueOrThrow
   */
  export type eventregistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter, which eventregistration to fetch.
     */
    where: eventregistrationWhereUniqueInput
  }

  /**
   * eventregistration findFirst
   */
  export type eventregistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter, which eventregistration to fetch.
     */
    where?: eventregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventregistrations to fetch.
     */
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventregistrations.
     */
    cursor?: eventregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventregistrations.
     */
    distinct?: EventregistrationScalarFieldEnum | EventregistrationScalarFieldEnum[]
  }

  /**
   * eventregistration findFirstOrThrow
   */
  export type eventregistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter, which eventregistration to fetch.
     */
    where?: eventregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventregistrations to fetch.
     */
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventregistrations.
     */
    cursor?: eventregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventregistrations.
     */
    distinct?: EventregistrationScalarFieldEnum | EventregistrationScalarFieldEnum[]
  }

  /**
   * eventregistration findMany
   */
  export type eventregistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter, which eventregistrations to fetch.
     */
    where?: eventregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventregistrations to fetch.
     */
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventregistrations.
     */
    cursor?: eventregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventregistrations.
     */
    skip?: number
    distinct?: EventregistrationScalarFieldEnum | EventregistrationScalarFieldEnum[]
  }

  /**
   * eventregistration create
   */
  export type eventregistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a eventregistration.
     */
    data: XOR<eventregistrationCreateInput, eventregistrationUncheckedCreateInput>
  }

  /**
   * eventregistration createMany
   */
  export type eventregistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eventregistrations.
     */
    data: eventregistrationCreateManyInput | eventregistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * eventregistration createManyAndReturn
   */
  export type eventregistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many eventregistrations.
     */
    data: eventregistrationCreateManyInput | eventregistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * eventregistration update
   */
  export type eventregistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a eventregistration.
     */
    data: XOR<eventregistrationUpdateInput, eventregistrationUncheckedUpdateInput>
    /**
     * Choose, which eventregistration to update.
     */
    where: eventregistrationWhereUniqueInput
  }

  /**
   * eventregistration updateMany
   */
  export type eventregistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eventregistrations.
     */
    data: XOR<eventregistrationUpdateManyMutationInput, eventregistrationUncheckedUpdateManyInput>
    /**
     * Filter which eventregistrations to update
     */
    where?: eventregistrationWhereInput
  }

  /**
   * eventregistration upsert
   */
  export type eventregistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the eventregistration to update in case it exists.
     */
    where: eventregistrationWhereUniqueInput
    /**
     * In case the eventregistration found by the `where` argument doesn't exist, create a new eventregistration with this data.
     */
    create: XOR<eventregistrationCreateInput, eventregistrationUncheckedCreateInput>
    /**
     * In case the eventregistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventregistrationUpdateInput, eventregistrationUncheckedUpdateInput>
  }

  /**
   * eventregistration delete
   */
  export type eventregistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    /**
     * Filter which eventregistration to delete.
     */
    where: eventregistrationWhereUniqueInput
  }

  /**
   * eventregistration deleteMany
   */
  export type eventregistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventregistrations to delete
     */
    where?: eventregistrationWhereInput
  }

  /**
   * eventregistration without action
   */
  export type eventregistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
  }


  /**
   * Model events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    location: string | null
    details: string | null
    link: string | null
    source: string | null
    created_at: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    location: string | null
    details: string | null
    link: string | null
    source: string | null
    created_at: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    date: number
    location: number
    details: number
    link: number
    source: number
    created_at: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    details?: true
    link?: true
    source?: true
    created_at?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    details?: true
    link?: true
    source?: true
    created_at?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    location?: true
    details?: true
    link?: true
    source?: true
    created_at?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to aggregate.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithAggregationInput | eventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: number
    title: string
    date: Date | null
    location: string | null
    details: string | null
    link: string | null
    source: string | null
    created_at: Date | null
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    details?: boolean
    link?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["events"]>

  export type eventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    details?: boolean
    link?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["events"]>

  export type eventsSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    location?: boolean
    details?: boolean
    link?: boolean
    source?: boolean
    created_at?: boolean
  }


  export type $eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      date: Date | null
      location: string | null
      details: string | null
      link: string | null
      source: string | null
      created_at: Date | null
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type eventsGetPayload<S extends boolean | null | undefined | eventsDefaultArgs> = $Result.GetResult<Prisma.$eventsPayload, S>

  type eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['events'], meta: { name: 'events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {eventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventsFindUniqueArgs>(args: SelectSubset<T, eventsFindUniqueArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventsFindFirstArgs>(args?: SelectSubset<T, eventsFindFirstArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventsFindManyArgs>(args?: SelectSubset<T, eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Events.
     * @param {eventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends eventsCreateArgs>(args: SelectSubset<T, eventsCreateArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {eventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventsCreateManyArgs>(args?: SelectSubset<T, eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {eventsCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventsWithIdOnly = await prisma.events.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends eventsCreateManyAndReturnArgs>(args?: SelectSubset<T, eventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Events.
     * @param {eventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends eventsDeleteArgs>(args: SelectSubset<T, eventsDeleteArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Events.
     * @param {eventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventsUpdateArgs>(args: SelectSubset<T, eventsUpdateArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventsDeleteManyArgs>(args?: SelectSubset<T, eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventsUpdateManyArgs>(args: SelectSubset<T, eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends eventsUpsertArgs>(args: SelectSubset<T, eventsUpsertArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventsCountArgs>(
      args?: Subset<T, eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventsGroupByArgs['orderBy'] }
        : { orderBy?: eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the events model
   */
  readonly fields: eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the events model
   */ 
  interface eventsFieldRefs {
    readonly id: FieldRef<"events", 'Int'>
    readonly title: FieldRef<"events", 'String'>
    readonly date: FieldRef<"events", 'DateTime'>
    readonly location: FieldRef<"events", 'String'>
    readonly details: FieldRef<"events", 'String'>
    readonly link: FieldRef<"events", 'String'>
    readonly source: FieldRef<"events", 'String'>
    readonly created_at: FieldRef<"events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * events findUnique
   */
  export type eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findUniqueOrThrow
   */
  export type eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findFirst
   */
  export type eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events findFirstOrThrow
   */
  export type eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events findMany
   */
  export type eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events create
   */
  export type eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The data needed to create a events.
     */
    data: XOR<eventsCreateInput, eventsUncheckedCreateInput>
  }

  /**
   * events createMany
   */
  export type eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventsCreateManyInput | eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * events createManyAndReturn
   */
  export type eventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many events.
     */
    data: eventsCreateManyInput | eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * events update
   */
  export type eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The data needed to update a events.
     */
    data: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
    /**
     * Choose, which events to update.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events updateMany
   */
  export type eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventsWhereInput
  }

  /**
   * events upsert
   */
  export type eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * The filter to search for the events to update in case it exists.
     */
    where: eventsWhereUniqueInput
    /**
     * In case the events found by the `where` argument doesn't exist, create a new events with this data.
     */
    create: XOR<eventsCreateInput, eventsUncheckedCreateInput>
    /**
     * In case the events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
  }

  /**
   * events delete
   */
  export type eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Filter which events to delete.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events deleteMany
   */
  export type eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventsWhereInput
  }

  /**
   * events without action
   */
  export type eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
  }


  /**
   * Model methodologies
   */

  export type AggregateMethodologies = {
    _count: MethodologiesCountAggregateOutputType | null
    _avg: MethodologiesAvgAggregateOutputType | null
    _sum: MethodologiesSumAggregateOutputType | null
    _min: MethodologiesMinAggregateOutputType | null
    _max: MethodologiesMaxAggregateOutputType | null
  }

  export type MethodologiesAvgAggregateOutputType = {
    id: number | null
  }

  export type MethodologiesSumAggregateOutputType = {
    id: number | null
  }

  export type MethodologiesMinAggregateOutputType = {
    id: number | null
    title: string | null
    published_date: Date | null
    abstract: string | null
    description: string | null
    link: string | null
    source: string | null
    permalink: string | null
    created_at: Date | null
    report_url: string | null
  }

  export type MethodologiesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    published_date: Date | null
    abstract: string | null
    description: string | null
    link: string | null
    source: string | null
    permalink: string | null
    created_at: Date | null
    report_url: string | null
  }

  export type MethodologiesCountAggregateOutputType = {
    id: number
    title: number
    published_date: number
    abstract: number
    description: number
    link: number
    source: number
    permalink: number
    created_at: number
    report_url: number
    _all: number
  }


  export type MethodologiesAvgAggregateInputType = {
    id?: true
  }

  export type MethodologiesSumAggregateInputType = {
    id?: true
  }

  export type MethodologiesMinAggregateInputType = {
    id?: true
    title?: true
    published_date?: true
    abstract?: true
    description?: true
    link?: true
    source?: true
    permalink?: true
    created_at?: true
    report_url?: true
  }

  export type MethodologiesMaxAggregateInputType = {
    id?: true
    title?: true
    published_date?: true
    abstract?: true
    description?: true
    link?: true
    source?: true
    permalink?: true
    created_at?: true
    report_url?: true
  }

  export type MethodologiesCountAggregateInputType = {
    id?: true
    title?: true
    published_date?: true
    abstract?: true
    description?: true
    link?: true
    source?: true
    permalink?: true
    created_at?: true
    report_url?: true
    _all?: true
  }

  export type MethodologiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which methodologies to aggregate.
     */
    where?: methodologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodologies to fetch.
     */
    orderBy?: methodologiesOrderByWithRelationInput | methodologiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: methodologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned methodologies
    **/
    _count?: true | MethodologiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MethodologiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MethodologiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodologiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodologiesMaxAggregateInputType
  }

  export type GetMethodologiesAggregateType<T extends MethodologiesAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodologies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodologies[P]>
      : GetScalarType<T[P], AggregateMethodologies[P]>
  }




  export type methodologiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: methodologiesWhereInput
    orderBy?: methodologiesOrderByWithAggregationInput | methodologiesOrderByWithAggregationInput[]
    by: MethodologiesScalarFieldEnum[] | MethodologiesScalarFieldEnum
    having?: methodologiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodologiesCountAggregateInputType | true
    _avg?: MethodologiesAvgAggregateInputType
    _sum?: MethodologiesSumAggregateInputType
    _min?: MethodologiesMinAggregateInputType
    _max?: MethodologiesMaxAggregateInputType
  }

  export type MethodologiesGroupByOutputType = {
    id: number
    title: string | null
    published_date: Date | null
    abstract: string | null
    description: string | null
    link: string | null
    source: string | null
    permalink: string | null
    created_at: Date | null
    report_url: string | null
    _count: MethodologiesCountAggregateOutputType | null
    _avg: MethodologiesAvgAggregateOutputType | null
    _sum: MethodologiesSumAggregateOutputType | null
    _min: MethodologiesMinAggregateOutputType | null
    _max: MethodologiesMaxAggregateOutputType | null
  }

  type GetMethodologiesGroupByPayload<T extends methodologiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodologiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodologiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodologiesGroupByOutputType[P]>
            : GetScalarType<T[P], MethodologiesGroupByOutputType[P]>
        }
      >
    >


  export type methodologiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    published_date?: boolean
    abstract?: boolean
    description?: boolean
    link?: boolean
    source?: boolean
    permalink?: boolean
    created_at?: boolean
    report_url?: boolean
  }, ExtArgs["result"]["methodologies"]>

  export type methodologiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    published_date?: boolean
    abstract?: boolean
    description?: boolean
    link?: boolean
    source?: boolean
    permalink?: boolean
    created_at?: boolean
    report_url?: boolean
  }, ExtArgs["result"]["methodologies"]>

  export type methodologiesSelectScalar = {
    id?: boolean
    title?: boolean
    published_date?: boolean
    abstract?: boolean
    description?: boolean
    link?: boolean
    source?: boolean
    permalink?: boolean
    created_at?: boolean
    report_url?: boolean
  }


  export type $methodologiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "methodologies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      published_date: Date | null
      abstract: string | null
      description: string | null
      link: string | null
      source: string | null
      permalink: string | null
      created_at: Date | null
      report_url: string | null
    }, ExtArgs["result"]["methodologies"]>
    composites: {}
  }

  type methodologiesGetPayload<S extends boolean | null | undefined | methodologiesDefaultArgs> = $Result.GetResult<Prisma.$methodologiesPayload, S>

  type methodologiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<methodologiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MethodologiesCountAggregateInputType | true
    }

  export interface methodologiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['methodologies'], meta: { name: 'methodologies' } }
    /**
     * Find zero or one Methodologies that matches the filter.
     * @param {methodologiesFindUniqueArgs} args - Arguments to find a Methodologies
     * @example
     * // Get one Methodologies
     * const methodologies = await prisma.methodologies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends methodologiesFindUniqueArgs>(args: SelectSubset<T, methodologiesFindUniqueArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Methodologies that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {methodologiesFindUniqueOrThrowArgs} args - Arguments to find a Methodologies
     * @example
     * // Get one Methodologies
     * const methodologies = await prisma.methodologies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends methodologiesFindUniqueOrThrowArgs>(args: SelectSubset<T, methodologiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Methodologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesFindFirstArgs} args - Arguments to find a Methodologies
     * @example
     * // Get one Methodologies
     * const methodologies = await prisma.methodologies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends methodologiesFindFirstArgs>(args?: SelectSubset<T, methodologiesFindFirstArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Methodologies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesFindFirstOrThrowArgs} args - Arguments to find a Methodologies
     * @example
     * // Get one Methodologies
     * const methodologies = await prisma.methodologies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends methodologiesFindFirstOrThrowArgs>(args?: SelectSubset<T, methodologiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Methodologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Methodologies
     * const methodologies = await prisma.methodologies.findMany()
     * 
     * // Get first 10 Methodologies
     * const methodologies = await prisma.methodologies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodologiesWithIdOnly = await prisma.methodologies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends methodologiesFindManyArgs>(args?: SelectSubset<T, methodologiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Methodologies.
     * @param {methodologiesCreateArgs} args - Arguments to create a Methodologies.
     * @example
     * // Create one Methodologies
     * const Methodologies = await prisma.methodologies.create({
     *   data: {
     *     // ... data to create a Methodologies
     *   }
     * })
     * 
     */
    create<T extends methodologiesCreateArgs>(args: SelectSubset<T, methodologiesCreateArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Methodologies.
     * @param {methodologiesCreateManyArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodologies = await prisma.methodologies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends methodologiesCreateManyArgs>(args?: SelectSubset<T, methodologiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Methodologies and returns the data saved in the database.
     * @param {methodologiesCreateManyAndReturnArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodologies = await prisma.methodologies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Methodologies and only return the `id`
     * const methodologiesWithIdOnly = await prisma.methodologies.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends methodologiesCreateManyAndReturnArgs>(args?: SelectSubset<T, methodologiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Methodologies.
     * @param {methodologiesDeleteArgs} args - Arguments to delete one Methodologies.
     * @example
     * // Delete one Methodologies
     * const Methodologies = await prisma.methodologies.delete({
     *   where: {
     *     // ... filter to delete one Methodologies
     *   }
     * })
     * 
     */
    delete<T extends methodologiesDeleteArgs>(args: SelectSubset<T, methodologiesDeleteArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Methodologies.
     * @param {methodologiesUpdateArgs} args - Arguments to update one Methodologies.
     * @example
     * // Update one Methodologies
     * const methodologies = await prisma.methodologies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends methodologiesUpdateArgs>(args: SelectSubset<T, methodologiesUpdateArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Methodologies.
     * @param {methodologiesDeleteManyArgs} args - Arguments to filter Methodologies to delete.
     * @example
     * // Delete a few Methodologies
     * const { count } = await prisma.methodologies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends methodologiesDeleteManyArgs>(args?: SelectSubset<T, methodologiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Methodologies
     * const methodologies = await prisma.methodologies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends methodologiesUpdateManyArgs>(args: SelectSubset<T, methodologiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Methodologies.
     * @param {methodologiesUpsertArgs} args - Arguments to update or create a Methodologies.
     * @example
     * // Update or create a Methodologies
     * const methodologies = await prisma.methodologies.upsert({
     *   create: {
     *     // ... data to create a Methodologies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Methodologies we want to update
     *   }
     * })
     */
    upsert<T extends methodologiesUpsertArgs>(args: SelectSubset<T, methodologiesUpsertArgs<ExtArgs>>): Prisma__methodologiesClient<$Result.GetResult<Prisma.$methodologiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesCountArgs} args - Arguments to filter Methodologies to count.
     * @example
     * // Count the number of Methodologies
     * const count = await prisma.methodologies.count({
     *   where: {
     *     // ... the filter for the Methodologies we want to count
     *   }
     * })
    **/
    count<T extends methodologiesCountArgs>(
      args?: Subset<T, methodologiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodologiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodologiesAggregateArgs>(args: Subset<T, MethodologiesAggregateArgs>): Prisma.PrismaPromise<GetMethodologiesAggregateType<T>>

    /**
     * Group by Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {methodologiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends methodologiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: methodologiesGroupByArgs['orderBy'] }
        : { orderBy?: methodologiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, methodologiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodologiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the methodologies model
   */
  readonly fields: methodologiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for methodologies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__methodologiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the methodologies model
   */ 
  interface methodologiesFieldRefs {
    readonly id: FieldRef<"methodologies", 'Int'>
    readonly title: FieldRef<"methodologies", 'String'>
    readonly published_date: FieldRef<"methodologies", 'DateTime'>
    readonly abstract: FieldRef<"methodologies", 'String'>
    readonly description: FieldRef<"methodologies", 'String'>
    readonly link: FieldRef<"methodologies", 'String'>
    readonly source: FieldRef<"methodologies", 'String'>
    readonly permalink: FieldRef<"methodologies", 'String'>
    readonly created_at: FieldRef<"methodologies", 'DateTime'>
    readonly report_url: FieldRef<"methodologies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * methodologies findUnique
   */
  export type methodologiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter, which methodologies to fetch.
     */
    where: methodologiesWhereUniqueInput
  }

  /**
   * methodologies findUniqueOrThrow
   */
  export type methodologiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter, which methodologies to fetch.
     */
    where: methodologiesWhereUniqueInput
  }

  /**
   * methodologies findFirst
   */
  export type methodologiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter, which methodologies to fetch.
     */
    where?: methodologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodologies to fetch.
     */
    orderBy?: methodologiesOrderByWithRelationInput | methodologiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for methodologies.
     */
    cursor?: methodologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of methodologies.
     */
    distinct?: MethodologiesScalarFieldEnum | MethodologiesScalarFieldEnum[]
  }

  /**
   * methodologies findFirstOrThrow
   */
  export type methodologiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter, which methodologies to fetch.
     */
    where?: methodologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodologies to fetch.
     */
    orderBy?: methodologiesOrderByWithRelationInput | methodologiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for methodologies.
     */
    cursor?: methodologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of methodologies.
     */
    distinct?: MethodologiesScalarFieldEnum | MethodologiesScalarFieldEnum[]
  }

  /**
   * methodologies findMany
   */
  export type methodologiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter, which methodologies to fetch.
     */
    where?: methodologiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of methodologies to fetch.
     */
    orderBy?: methodologiesOrderByWithRelationInput | methodologiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing methodologies.
     */
    cursor?: methodologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` methodologies.
     */
    skip?: number
    distinct?: MethodologiesScalarFieldEnum | MethodologiesScalarFieldEnum[]
  }

  /**
   * methodologies create
   */
  export type methodologiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * The data needed to create a methodologies.
     */
    data?: XOR<methodologiesCreateInput, methodologiesUncheckedCreateInput>
  }

  /**
   * methodologies createMany
   */
  export type methodologiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many methodologies.
     */
    data: methodologiesCreateManyInput | methodologiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * methodologies createManyAndReturn
   */
  export type methodologiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many methodologies.
     */
    data: methodologiesCreateManyInput | methodologiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * methodologies update
   */
  export type methodologiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * The data needed to update a methodologies.
     */
    data: XOR<methodologiesUpdateInput, methodologiesUncheckedUpdateInput>
    /**
     * Choose, which methodologies to update.
     */
    where: methodologiesWhereUniqueInput
  }

  /**
   * methodologies updateMany
   */
  export type methodologiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update methodologies.
     */
    data: XOR<methodologiesUpdateManyMutationInput, methodologiesUncheckedUpdateManyInput>
    /**
     * Filter which methodologies to update
     */
    where?: methodologiesWhereInput
  }

  /**
   * methodologies upsert
   */
  export type methodologiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * The filter to search for the methodologies to update in case it exists.
     */
    where: methodologiesWhereUniqueInput
    /**
     * In case the methodologies found by the `where` argument doesn't exist, create a new methodologies with this data.
     */
    create: XOR<methodologiesCreateInput, methodologiesUncheckedCreateInput>
    /**
     * In case the methodologies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<methodologiesUpdateInput, methodologiesUncheckedUpdateInput>
  }

  /**
   * methodologies delete
   */
  export type methodologiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
    /**
     * Filter which methodologies to delete.
     */
    where: methodologiesWhereUniqueInput
  }

  /**
   * methodologies deleteMany
   */
  export type methodologiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which methodologies to delete
     */
    where?: methodologiesWhereInput
  }

  /**
   * methodologies without action
   */
  export type methodologiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the methodologies
     */
    select?: methodologiesSelect<ExtArgs> | null
  }


  /**
   * Model newsletter_logs
   */

  export type AggregateNewsletter_logs = {
    _count: Newsletter_logsCountAggregateOutputType | null
    _avg: Newsletter_logsAvgAggregateOutputType | null
    _sum: Newsletter_logsSumAggregateOutputType | null
    _min: Newsletter_logsMinAggregateOutputType | null
    _max: Newsletter_logsMaxAggregateOutputType | null
  }

  export type Newsletter_logsAvgAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    articles_count: number | null
  }

  export type Newsletter_logsSumAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    articles_count: number | null
  }

  export type Newsletter_logsMinAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    sent_at: Date | null
    email_to: string | null
    email_subject: string | null
    articles_count: number | null
    success: boolean | null
    error_message: string | null
    email_content_preview: string | null
  }

  export type Newsletter_logsMaxAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    sent_at: Date | null
    email_to: string | null
    email_subject: string | null
    articles_count: number | null
    success: boolean | null
    error_message: string | null
    email_content_preview: string | null
  }

  export type Newsletter_logsCountAggregateOutputType = {
    id: number
    subscription_id: number
    sent_at: number
    email_to: number
    email_subject: number
    articles_count: number
    success: number
    error_message: number
    articles_included: number
    email_content_preview: number
    _all: number
  }


  export type Newsletter_logsAvgAggregateInputType = {
    id?: true
    subscription_id?: true
    articles_count?: true
  }

  export type Newsletter_logsSumAggregateInputType = {
    id?: true
    subscription_id?: true
    articles_count?: true
  }

  export type Newsletter_logsMinAggregateInputType = {
    id?: true
    subscription_id?: true
    sent_at?: true
    email_to?: true
    email_subject?: true
    articles_count?: true
    success?: true
    error_message?: true
    email_content_preview?: true
  }

  export type Newsletter_logsMaxAggregateInputType = {
    id?: true
    subscription_id?: true
    sent_at?: true
    email_to?: true
    email_subject?: true
    articles_count?: true
    success?: true
    error_message?: true
    email_content_preview?: true
  }

  export type Newsletter_logsCountAggregateInputType = {
    id?: true
    subscription_id?: true
    sent_at?: true
    email_to?: true
    email_subject?: true
    articles_count?: true
    success?: true
    error_message?: true
    articles_included?: true
    email_content_preview?: true
    _all?: true
  }

  export type Newsletter_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_logs to aggregate.
     */
    where?: newsletter_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_logs to fetch.
     */
    orderBy?: newsletter_logsOrderByWithRelationInput | newsletter_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletter_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletter_logs
    **/
    _count?: true | Newsletter_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Newsletter_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Newsletter_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Newsletter_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Newsletter_logsMaxAggregateInputType
  }

  export type GetNewsletter_logsAggregateType<T extends Newsletter_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter_logs[P]>
      : GetScalarType<T[P], AggregateNewsletter_logs[P]>
  }




  export type newsletter_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_logsWhereInput
    orderBy?: newsletter_logsOrderByWithAggregationInput | newsletter_logsOrderByWithAggregationInput[]
    by: Newsletter_logsScalarFieldEnum[] | Newsletter_logsScalarFieldEnum
    having?: newsletter_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Newsletter_logsCountAggregateInputType | true
    _avg?: Newsletter_logsAvgAggregateInputType
    _sum?: Newsletter_logsSumAggregateInputType
    _min?: Newsletter_logsMinAggregateInputType
    _max?: Newsletter_logsMaxAggregateInputType
  }

  export type Newsletter_logsGroupByOutputType = {
    id: number
    subscription_id: number
    sent_at: Date | null
    email_to: string
    email_subject: string | null
    articles_count: number | null
    success: boolean | null
    error_message: string | null
    articles_included: JsonValue | null
    email_content_preview: string | null
    _count: Newsletter_logsCountAggregateOutputType | null
    _avg: Newsletter_logsAvgAggregateOutputType | null
    _sum: Newsletter_logsSumAggregateOutputType | null
    _min: Newsletter_logsMinAggregateOutputType | null
    _max: Newsletter_logsMaxAggregateOutputType | null
  }

  type GetNewsletter_logsGroupByPayload<T extends newsletter_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Newsletter_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Newsletter_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Newsletter_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Newsletter_logsGroupByOutputType[P]>
        }
      >
    >


  export type newsletter_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscription_id?: boolean
    sent_at?: boolean
    email_to?: boolean
    email_subject?: boolean
    articles_count?: boolean
    success?: boolean
    error_message?: boolean
    articles_included?: boolean
    email_content_preview?: boolean
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_logs"]>

  export type newsletter_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscription_id?: boolean
    sent_at?: boolean
    email_to?: boolean
    email_subject?: boolean
    articles_count?: boolean
    success?: boolean
    error_message?: boolean
    articles_included?: boolean
    email_content_preview?: boolean
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_logs"]>

  export type newsletter_logsSelectScalar = {
    id?: boolean
    subscription_id?: boolean
    sent_at?: boolean
    email_to?: boolean
    email_subject?: boolean
    articles_count?: boolean
    success?: boolean
    error_message?: boolean
    articles_included?: boolean
    email_content_preview?: boolean
  }

  export type newsletter_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }
  export type newsletter_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }

  export type $newsletter_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter_logs"
    objects: {
      newsletter_subscriptions: Prisma.$newsletter_subscriptionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subscription_id: number
      sent_at: Date | null
      email_to: string
      email_subject: string | null
      articles_count: number | null
      success: boolean | null
      error_message: string | null
      articles_included: Prisma.JsonValue | null
      email_content_preview: string | null
    }, ExtArgs["result"]["newsletter_logs"]>
    composites: {}
  }

  type newsletter_logsGetPayload<S extends boolean | null | undefined | newsletter_logsDefaultArgs> = $Result.GetResult<Prisma.$newsletter_logsPayload, S>

  type newsletter_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<newsletter_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Newsletter_logsCountAggregateInputType | true
    }

  export interface newsletter_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter_logs'], meta: { name: 'newsletter_logs' } }
    /**
     * Find zero or one Newsletter_logs that matches the filter.
     * @param {newsletter_logsFindUniqueArgs} args - Arguments to find a Newsletter_logs
     * @example
     * // Get one Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletter_logsFindUniqueArgs>(args: SelectSubset<T, newsletter_logsFindUniqueArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Newsletter_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {newsletter_logsFindUniqueOrThrowArgs} args - Arguments to find a Newsletter_logs
     * @example
     * // Get one Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletter_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletter_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Newsletter_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsFindFirstArgs} args - Arguments to find a Newsletter_logs
     * @example
     * // Get one Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletter_logsFindFirstArgs>(args?: SelectSubset<T, newsletter_logsFindFirstArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Newsletter_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsFindFirstOrThrowArgs} args - Arguments to find a Newsletter_logs
     * @example
     * // Get one Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletter_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletter_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Newsletter_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findMany()
     * 
     * // Get first 10 Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletter_logsWithIdOnly = await prisma.newsletter_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsletter_logsFindManyArgs>(args?: SelectSubset<T, newsletter_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Newsletter_logs.
     * @param {newsletter_logsCreateArgs} args - Arguments to create a Newsletter_logs.
     * @example
     * // Create one Newsletter_logs
     * const Newsletter_logs = await prisma.newsletter_logs.create({
     *   data: {
     *     // ... data to create a Newsletter_logs
     *   }
     * })
     * 
     */
    create<T extends newsletter_logsCreateArgs>(args: SelectSubset<T, newsletter_logsCreateArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Newsletter_logs.
     * @param {newsletter_logsCreateManyArgs} args - Arguments to create many Newsletter_logs.
     * @example
     * // Create many Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletter_logsCreateManyArgs>(args?: SelectSubset<T, newsletter_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Newsletter_logs and returns the data saved in the database.
     * @param {newsletter_logsCreateManyAndReturnArgs} args - Arguments to create many Newsletter_logs.
     * @example
     * // Create many Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Newsletter_logs and only return the `id`
     * const newsletter_logsWithIdOnly = await prisma.newsletter_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends newsletter_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, newsletter_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Newsletter_logs.
     * @param {newsletter_logsDeleteArgs} args - Arguments to delete one Newsletter_logs.
     * @example
     * // Delete one Newsletter_logs
     * const Newsletter_logs = await prisma.newsletter_logs.delete({
     *   where: {
     *     // ... filter to delete one Newsletter_logs
     *   }
     * })
     * 
     */
    delete<T extends newsletter_logsDeleteArgs>(args: SelectSubset<T, newsletter_logsDeleteArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Newsletter_logs.
     * @param {newsletter_logsUpdateArgs} args - Arguments to update one Newsletter_logs.
     * @example
     * // Update one Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletter_logsUpdateArgs>(args: SelectSubset<T, newsletter_logsUpdateArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Newsletter_logs.
     * @param {newsletter_logsDeleteManyArgs} args - Arguments to filter Newsletter_logs to delete.
     * @example
     * // Delete a few Newsletter_logs
     * const { count } = await prisma.newsletter_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletter_logsDeleteManyArgs>(args?: SelectSubset<T, newsletter_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletter_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletter_logsUpdateManyArgs>(args: SelectSubset<T, newsletter_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter_logs.
     * @param {newsletter_logsUpsertArgs} args - Arguments to update or create a Newsletter_logs.
     * @example
     * // Update or create a Newsletter_logs
     * const newsletter_logs = await prisma.newsletter_logs.upsert({
     *   create: {
     *     // ... data to create a Newsletter_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter_logs we want to update
     *   }
     * })
     */
    upsert<T extends newsletter_logsUpsertArgs>(args: SelectSubset<T, newsletter_logsUpsertArgs<ExtArgs>>): Prisma__newsletter_logsClient<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Newsletter_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsCountArgs} args - Arguments to filter Newsletter_logs to count.
     * @example
     * // Count the number of Newsletter_logs
     * const count = await prisma.newsletter_logs.count({
     *   where: {
     *     // ... the filter for the Newsletter_logs we want to count
     *   }
     * })
    **/
    count<T extends newsletter_logsCountArgs>(
      args?: Subset<T, newsletter_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Newsletter_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Newsletter_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Newsletter_logsAggregateArgs>(args: Subset<T, Newsletter_logsAggregateArgs>): Prisma.PrismaPromise<GetNewsletter_logsAggregateType<T>>

    /**
     * Group by Newsletter_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletter_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletter_logsGroupByArgs['orderBy'] }
        : { orderBy?: newsletter_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletter_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletter_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter_logs model
   */
  readonly fields: newsletter_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletter_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    newsletter_subscriptions<T extends newsletter_subscriptionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, newsletter_subscriptionsDefaultArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter_logs model
   */ 
  interface newsletter_logsFieldRefs {
    readonly id: FieldRef<"newsletter_logs", 'Int'>
    readonly subscription_id: FieldRef<"newsletter_logs", 'Int'>
    readonly sent_at: FieldRef<"newsletter_logs", 'DateTime'>
    readonly email_to: FieldRef<"newsletter_logs", 'String'>
    readonly email_subject: FieldRef<"newsletter_logs", 'String'>
    readonly articles_count: FieldRef<"newsletter_logs", 'Int'>
    readonly success: FieldRef<"newsletter_logs", 'Boolean'>
    readonly error_message: FieldRef<"newsletter_logs", 'String'>
    readonly articles_included: FieldRef<"newsletter_logs", 'Json'>
    readonly email_content_preview: FieldRef<"newsletter_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * newsletter_logs findUnique
   */
  export type newsletter_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_logs to fetch.
     */
    where: newsletter_logsWhereUniqueInput
  }

  /**
   * newsletter_logs findUniqueOrThrow
   */
  export type newsletter_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_logs to fetch.
     */
    where: newsletter_logsWhereUniqueInput
  }

  /**
   * newsletter_logs findFirst
   */
  export type newsletter_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_logs to fetch.
     */
    where?: newsletter_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_logs to fetch.
     */
    orderBy?: newsletter_logsOrderByWithRelationInput | newsletter_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_logs.
     */
    cursor?: newsletter_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_logs.
     */
    distinct?: Newsletter_logsScalarFieldEnum | Newsletter_logsScalarFieldEnum[]
  }

  /**
   * newsletter_logs findFirstOrThrow
   */
  export type newsletter_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_logs to fetch.
     */
    where?: newsletter_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_logs to fetch.
     */
    orderBy?: newsletter_logsOrderByWithRelationInput | newsletter_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_logs.
     */
    cursor?: newsletter_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_logs.
     */
    distinct?: Newsletter_logsScalarFieldEnum | Newsletter_logsScalarFieldEnum[]
  }

  /**
   * newsletter_logs findMany
   */
  export type newsletter_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_logs to fetch.
     */
    where?: newsletter_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_logs to fetch.
     */
    orderBy?: newsletter_logsOrderByWithRelationInput | newsletter_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletter_logs.
     */
    cursor?: newsletter_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_logs.
     */
    skip?: number
    distinct?: Newsletter_logsScalarFieldEnum | Newsletter_logsScalarFieldEnum[]
  }

  /**
   * newsletter_logs create
   */
  export type newsletter_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a newsletter_logs.
     */
    data: XOR<newsletter_logsCreateInput, newsletter_logsUncheckedCreateInput>
  }

  /**
   * newsletter_logs createMany
   */
  export type newsletter_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletter_logs.
     */
    data: newsletter_logsCreateManyInput | newsletter_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter_logs createManyAndReturn
   */
  export type newsletter_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many newsletter_logs.
     */
    data: newsletter_logsCreateManyInput | newsletter_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * newsletter_logs update
   */
  export type newsletter_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a newsletter_logs.
     */
    data: XOR<newsletter_logsUpdateInput, newsletter_logsUncheckedUpdateInput>
    /**
     * Choose, which newsletter_logs to update.
     */
    where: newsletter_logsWhereUniqueInput
  }

  /**
   * newsletter_logs updateMany
   */
  export type newsletter_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletter_logs.
     */
    data: XOR<newsletter_logsUpdateManyMutationInput, newsletter_logsUncheckedUpdateManyInput>
    /**
     * Filter which newsletter_logs to update
     */
    where?: newsletter_logsWhereInput
  }

  /**
   * newsletter_logs upsert
   */
  export type newsletter_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the newsletter_logs to update in case it exists.
     */
    where: newsletter_logsWhereUniqueInput
    /**
     * In case the newsletter_logs found by the `where` argument doesn't exist, create a new newsletter_logs with this data.
     */
    create: XOR<newsletter_logsCreateInput, newsletter_logsUncheckedCreateInput>
    /**
     * In case the newsletter_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletter_logsUpdateInput, newsletter_logsUncheckedUpdateInput>
  }

  /**
   * newsletter_logs delete
   */
  export type newsletter_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    /**
     * Filter which newsletter_logs to delete.
     */
    where: newsletter_logsWhereUniqueInput
  }

  /**
   * newsletter_logs deleteMany
   */
  export type newsletter_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_logs to delete
     */
    where?: newsletter_logsWhereInput
  }

  /**
   * newsletter_logs without action
   */
  export type newsletter_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
  }


  /**
   * Model newsletter_preferences
   */

  export type AggregateNewsletter_preferences = {
    _count: Newsletter_preferencesCountAggregateOutputType | null
    _avg: Newsletter_preferencesAvgAggregateOutputType | null
    _sum: Newsletter_preferencesSumAggregateOutputType | null
    _min: Newsletter_preferencesMinAggregateOutputType | null
    _max: Newsletter_preferencesMaxAggregateOutputType | null
  }

  export type Newsletter_preferencesAvgAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    day_of_week: number | null
    max_articles_per_email: number | null
  }

  export type Newsletter_preferencesSumAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    day_of_week: number | null
    max_articles_per_email: number | null
  }

  export type Newsletter_preferencesMinAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    include_starred_only: boolean | null
    frequency: string | null
    day_of_week: number | null
    time_of_day: Date | null
    timezone: string | null
    max_articles_per_email: number | null
    include_summary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Newsletter_preferencesMaxAggregateOutputType = {
    id: number | null
    subscription_id: number | null
    include_starred_only: boolean | null
    frequency: string | null
    day_of_week: number | null
    time_of_day: Date | null
    timezone: string | null
    max_articles_per_email: number | null
    include_summary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Newsletter_preferencesCountAggregateOutputType = {
    id: number
    subscription_id: number
    sources: number
    regions: number
    sectors: number
    include_starred_only: number
    frequency: number
    day_of_week: number
    time_of_day: number
    timezone: number
    max_articles_per_email: number
    include_summary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Newsletter_preferencesAvgAggregateInputType = {
    id?: true
    subscription_id?: true
    day_of_week?: true
    max_articles_per_email?: true
  }

  export type Newsletter_preferencesSumAggregateInputType = {
    id?: true
    subscription_id?: true
    day_of_week?: true
    max_articles_per_email?: true
  }

  export type Newsletter_preferencesMinAggregateInputType = {
    id?: true
    subscription_id?: true
    include_starred_only?: true
    frequency?: true
    day_of_week?: true
    time_of_day?: true
    timezone?: true
    max_articles_per_email?: true
    include_summary?: true
    created_at?: true
    updated_at?: true
  }

  export type Newsletter_preferencesMaxAggregateInputType = {
    id?: true
    subscription_id?: true
    include_starred_only?: true
    frequency?: true
    day_of_week?: true
    time_of_day?: true
    timezone?: true
    max_articles_per_email?: true
    include_summary?: true
    created_at?: true
    updated_at?: true
  }

  export type Newsletter_preferencesCountAggregateInputType = {
    id?: true
    subscription_id?: true
    sources?: true
    regions?: true
    sectors?: true
    include_starred_only?: true
    frequency?: true
    day_of_week?: true
    time_of_day?: true
    timezone?: true
    max_articles_per_email?: true
    include_summary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Newsletter_preferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_preferences to aggregate.
     */
    where?: newsletter_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_preferences to fetch.
     */
    orderBy?: newsletter_preferencesOrderByWithRelationInput | newsletter_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletter_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletter_preferences
    **/
    _count?: true | Newsletter_preferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Newsletter_preferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Newsletter_preferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Newsletter_preferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Newsletter_preferencesMaxAggregateInputType
  }

  export type GetNewsletter_preferencesAggregateType<T extends Newsletter_preferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter_preferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter_preferences[P]>
      : GetScalarType<T[P], AggregateNewsletter_preferences[P]>
  }




  export type newsletter_preferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_preferencesWhereInput
    orderBy?: newsletter_preferencesOrderByWithAggregationInput | newsletter_preferencesOrderByWithAggregationInput[]
    by: Newsletter_preferencesScalarFieldEnum[] | Newsletter_preferencesScalarFieldEnum
    having?: newsletter_preferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Newsletter_preferencesCountAggregateInputType | true
    _avg?: Newsletter_preferencesAvgAggregateInputType
    _sum?: Newsletter_preferencesSumAggregateInputType
    _min?: Newsletter_preferencesMinAggregateInputType
    _max?: Newsletter_preferencesMaxAggregateInputType
  }

  export type Newsletter_preferencesGroupByOutputType = {
    id: number
    subscription_id: number
    sources: string[]
    regions: string[]
    sectors: string[]
    include_starred_only: boolean | null
    frequency: string
    day_of_week: number | null
    time_of_day: Date | null
    timezone: string | null
    max_articles_per_email: number | null
    include_summary: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Newsletter_preferencesCountAggregateOutputType | null
    _avg: Newsletter_preferencesAvgAggregateOutputType | null
    _sum: Newsletter_preferencesSumAggregateOutputType | null
    _min: Newsletter_preferencesMinAggregateOutputType | null
    _max: Newsletter_preferencesMaxAggregateOutputType | null
  }

  type GetNewsletter_preferencesGroupByPayload<T extends newsletter_preferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Newsletter_preferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Newsletter_preferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Newsletter_preferencesGroupByOutputType[P]>
            : GetScalarType<T[P], Newsletter_preferencesGroupByOutputType[P]>
        }
      >
    >


  export type newsletter_preferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscription_id?: boolean
    sources?: boolean
    regions?: boolean
    sectors?: boolean
    include_starred_only?: boolean
    frequency?: boolean
    day_of_week?: boolean
    time_of_day?: boolean
    timezone?: boolean
    max_articles_per_email?: boolean
    include_summary?: boolean
    created_at?: boolean
    updated_at?: boolean
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_preferences"]>

  export type newsletter_preferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscription_id?: boolean
    sources?: boolean
    regions?: boolean
    sectors?: boolean
    include_starred_only?: boolean
    frequency?: boolean
    day_of_week?: boolean
    time_of_day?: boolean
    timezone?: boolean
    max_articles_per_email?: boolean
    include_summary?: boolean
    created_at?: boolean
    updated_at?: boolean
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_preferences"]>

  export type newsletter_preferencesSelectScalar = {
    id?: boolean
    subscription_id?: boolean
    sources?: boolean
    regions?: boolean
    sectors?: boolean
    include_starred_only?: boolean
    frequency?: boolean
    day_of_week?: boolean
    time_of_day?: boolean
    timezone?: boolean
    max_articles_per_email?: boolean
    include_summary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type newsletter_preferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }
  export type newsletter_preferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_subscriptions?: boolean | newsletter_subscriptionsDefaultArgs<ExtArgs>
  }

  export type $newsletter_preferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter_preferences"
    objects: {
      newsletter_subscriptions: Prisma.$newsletter_subscriptionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subscription_id: number
      sources: string[]
      regions: string[]
      sectors: string[]
      include_starred_only: boolean | null
      frequency: string
      day_of_week: number | null
      time_of_day: Date | null
      timezone: string | null
      max_articles_per_email: number | null
      include_summary: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["newsletter_preferences"]>
    composites: {}
  }

  type newsletter_preferencesGetPayload<S extends boolean | null | undefined | newsletter_preferencesDefaultArgs> = $Result.GetResult<Prisma.$newsletter_preferencesPayload, S>

  type newsletter_preferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<newsletter_preferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Newsletter_preferencesCountAggregateInputType | true
    }

  export interface newsletter_preferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter_preferences'], meta: { name: 'newsletter_preferences' } }
    /**
     * Find zero or one Newsletter_preferences that matches the filter.
     * @param {newsletter_preferencesFindUniqueArgs} args - Arguments to find a Newsletter_preferences
     * @example
     * // Get one Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletter_preferencesFindUniqueArgs>(args: SelectSubset<T, newsletter_preferencesFindUniqueArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Newsletter_preferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {newsletter_preferencesFindUniqueOrThrowArgs} args - Arguments to find a Newsletter_preferences
     * @example
     * // Get one Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletter_preferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletter_preferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Newsletter_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesFindFirstArgs} args - Arguments to find a Newsletter_preferences
     * @example
     * // Get one Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletter_preferencesFindFirstArgs>(args?: SelectSubset<T, newsletter_preferencesFindFirstArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Newsletter_preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesFindFirstOrThrowArgs} args - Arguments to find a Newsletter_preferences
     * @example
     * // Get one Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletter_preferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletter_preferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Newsletter_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findMany()
     * 
     * // Get first 10 Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletter_preferencesWithIdOnly = await prisma.newsletter_preferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsletter_preferencesFindManyArgs>(args?: SelectSubset<T, newsletter_preferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Newsletter_preferences.
     * @param {newsletter_preferencesCreateArgs} args - Arguments to create a Newsletter_preferences.
     * @example
     * // Create one Newsletter_preferences
     * const Newsletter_preferences = await prisma.newsletter_preferences.create({
     *   data: {
     *     // ... data to create a Newsletter_preferences
     *   }
     * })
     * 
     */
    create<T extends newsletter_preferencesCreateArgs>(args: SelectSubset<T, newsletter_preferencesCreateArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Newsletter_preferences.
     * @param {newsletter_preferencesCreateManyArgs} args - Arguments to create many Newsletter_preferences.
     * @example
     * // Create many Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletter_preferencesCreateManyArgs>(args?: SelectSubset<T, newsletter_preferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Newsletter_preferences and returns the data saved in the database.
     * @param {newsletter_preferencesCreateManyAndReturnArgs} args - Arguments to create many Newsletter_preferences.
     * @example
     * // Create many Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Newsletter_preferences and only return the `id`
     * const newsletter_preferencesWithIdOnly = await prisma.newsletter_preferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends newsletter_preferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, newsletter_preferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Newsletter_preferences.
     * @param {newsletter_preferencesDeleteArgs} args - Arguments to delete one Newsletter_preferences.
     * @example
     * // Delete one Newsletter_preferences
     * const Newsletter_preferences = await prisma.newsletter_preferences.delete({
     *   where: {
     *     // ... filter to delete one Newsletter_preferences
     *   }
     * })
     * 
     */
    delete<T extends newsletter_preferencesDeleteArgs>(args: SelectSubset<T, newsletter_preferencesDeleteArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Newsletter_preferences.
     * @param {newsletter_preferencesUpdateArgs} args - Arguments to update one Newsletter_preferences.
     * @example
     * // Update one Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletter_preferencesUpdateArgs>(args: SelectSubset<T, newsletter_preferencesUpdateArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Newsletter_preferences.
     * @param {newsletter_preferencesDeleteManyArgs} args - Arguments to filter Newsletter_preferences to delete.
     * @example
     * // Delete a few Newsletter_preferences
     * const { count } = await prisma.newsletter_preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletter_preferencesDeleteManyArgs>(args?: SelectSubset<T, newsletter_preferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletter_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletter_preferencesUpdateManyArgs>(args: SelectSubset<T, newsletter_preferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter_preferences.
     * @param {newsletter_preferencesUpsertArgs} args - Arguments to update or create a Newsletter_preferences.
     * @example
     * // Update or create a Newsletter_preferences
     * const newsletter_preferences = await prisma.newsletter_preferences.upsert({
     *   create: {
     *     // ... data to create a Newsletter_preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter_preferences we want to update
     *   }
     * })
     */
    upsert<T extends newsletter_preferencesUpsertArgs>(args: SelectSubset<T, newsletter_preferencesUpsertArgs<ExtArgs>>): Prisma__newsletter_preferencesClient<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Newsletter_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesCountArgs} args - Arguments to filter Newsletter_preferences to count.
     * @example
     * // Count the number of Newsletter_preferences
     * const count = await prisma.newsletter_preferences.count({
     *   where: {
     *     // ... the filter for the Newsletter_preferences we want to count
     *   }
     * })
    **/
    count<T extends newsletter_preferencesCountArgs>(
      args?: Subset<T, newsletter_preferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Newsletter_preferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Newsletter_preferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Newsletter_preferencesAggregateArgs>(args: Subset<T, Newsletter_preferencesAggregateArgs>): Prisma.PrismaPromise<GetNewsletter_preferencesAggregateType<T>>

    /**
     * Group by Newsletter_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_preferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletter_preferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletter_preferencesGroupByArgs['orderBy'] }
        : { orderBy?: newsletter_preferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletter_preferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletter_preferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter_preferences model
   */
  readonly fields: newsletter_preferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter_preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletter_preferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    newsletter_subscriptions<T extends newsletter_subscriptionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, newsletter_subscriptionsDefaultArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter_preferences model
   */ 
  interface newsletter_preferencesFieldRefs {
    readonly id: FieldRef<"newsletter_preferences", 'Int'>
    readonly subscription_id: FieldRef<"newsletter_preferences", 'Int'>
    readonly sources: FieldRef<"newsletter_preferences", 'String[]'>
    readonly regions: FieldRef<"newsletter_preferences", 'String[]'>
    readonly sectors: FieldRef<"newsletter_preferences", 'String[]'>
    readonly include_starred_only: FieldRef<"newsletter_preferences", 'Boolean'>
    readonly frequency: FieldRef<"newsletter_preferences", 'String'>
    readonly day_of_week: FieldRef<"newsletter_preferences", 'Int'>
    readonly time_of_day: FieldRef<"newsletter_preferences", 'DateTime'>
    readonly timezone: FieldRef<"newsletter_preferences", 'String'>
    readonly max_articles_per_email: FieldRef<"newsletter_preferences", 'Int'>
    readonly include_summary: FieldRef<"newsletter_preferences", 'Boolean'>
    readonly created_at: FieldRef<"newsletter_preferences", 'DateTime'>
    readonly updated_at: FieldRef<"newsletter_preferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * newsletter_preferences findUnique
   */
  export type newsletter_preferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_preferences to fetch.
     */
    where: newsletter_preferencesWhereUniqueInput
  }

  /**
   * newsletter_preferences findUniqueOrThrow
   */
  export type newsletter_preferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_preferences to fetch.
     */
    where: newsletter_preferencesWhereUniqueInput
  }

  /**
   * newsletter_preferences findFirst
   */
  export type newsletter_preferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_preferences to fetch.
     */
    where?: newsletter_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_preferences to fetch.
     */
    orderBy?: newsletter_preferencesOrderByWithRelationInput | newsletter_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_preferences.
     */
    cursor?: newsletter_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_preferences.
     */
    distinct?: Newsletter_preferencesScalarFieldEnum | Newsletter_preferencesScalarFieldEnum[]
  }

  /**
   * newsletter_preferences findFirstOrThrow
   */
  export type newsletter_preferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_preferences to fetch.
     */
    where?: newsletter_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_preferences to fetch.
     */
    orderBy?: newsletter_preferencesOrderByWithRelationInput | newsletter_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_preferences.
     */
    cursor?: newsletter_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_preferences.
     */
    distinct?: Newsletter_preferencesScalarFieldEnum | Newsletter_preferencesScalarFieldEnum[]
  }

  /**
   * newsletter_preferences findMany
   */
  export type newsletter_preferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_preferences to fetch.
     */
    where?: newsletter_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_preferences to fetch.
     */
    orderBy?: newsletter_preferencesOrderByWithRelationInput | newsletter_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletter_preferences.
     */
    cursor?: newsletter_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_preferences.
     */
    skip?: number
    distinct?: Newsletter_preferencesScalarFieldEnum | Newsletter_preferencesScalarFieldEnum[]
  }

  /**
   * newsletter_preferences create
   */
  export type newsletter_preferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a newsletter_preferences.
     */
    data: XOR<newsletter_preferencesCreateInput, newsletter_preferencesUncheckedCreateInput>
  }

  /**
   * newsletter_preferences createMany
   */
  export type newsletter_preferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletter_preferences.
     */
    data: newsletter_preferencesCreateManyInput | newsletter_preferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter_preferences createManyAndReturn
   */
  export type newsletter_preferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many newsletter_preferences.
     */
    data: newsletter_preferencesCreateManyInput | newsletter_preferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * newsletter_preferences update
   */
  export type newsletter_preferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a newsletter_preferences.
     */
    data: XOR<newsletter_preferencesUpdateInput, newsletter_preferencesUncheckedUpdateInput>
    /**
     * Choose, which newsletter_preferences to update.
     */
    where: newsletter_preferencesWhereUniqueInput
  }

  /**
   * newsletter_preferences updateMany
   */
  export type newsletter_preferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletter_preferences.
     */
    data: XOR<newsletter_preferencesUpdateManyMutationInput, newsletter_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which newsletter_preferences to update
     */
    where?: newsletter_preferencesWhereInput
  }

  /**
   * newsletter_preferences upsert
   */
  export type newsletter_preferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the newsletter_preferences to update in case it exists.
     */
    where: newsletter_preferencesWhereUniqueInput
    /**
     * In case the newsletter_preferences found by the `where` argument doesn't exist, create a new newsletter_preferences with this data.
     */
    create: XOR<newsletter_preferencesCreateInput, newsletter_preferencesUncheckedCreateInput>
    /**
     * In case the newsletter_preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletter_preferencesUpdateInput, newsletter_preferencesUncheckedUpdateInput>
  }

  /**
   * newsletter_preferences delete
   */
  export type newsletter_preferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    /**
     * Filter which newsletter_preferences to delete.
     */
    where: newsletter_preferencesWhereUniqueInput
  }

  /**
   * newsletter_preferences deleteMany
   */
  export type newsletter_preferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_preferences to delete
     */
    where?: newsletter_preferencesWhereInput
  }

  /**
   * newsletter_preferences without action
   */
  export type newsletter_preferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
  }


  /**
   * Model newsletter_subscriptions
   */

  export type AggregateNewsletter_subscriptions = {
    _count: Newsletter_subscriptionsCountAggregateOutputType | null
    _avg: Newsletter_subscriptionsAvgAggregateOutputType | null
    _sum: Newsletter_subscriptionsSumAggregateOutputType | null
    _min: Newsletter_subscriptionsMinAggregateOutputType | null
    _max: Newsletter_subscriptionsMaxAggregateOutputType | null
  }

  export type Newsletter_subscriptionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Newsletter_subscriptionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Newsletter_subscriptionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    subscription_type: string | null
    is_active: boolean | null
    email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Newsletter_subscriptionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    subscription_type: string | null
    is_active: boolean | null
    email: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Newsletter_subscriptionsCountAggregateOutputType = {
    id: number
    user_id: number
    subscription_type: number
    is_active: number
    email: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Newsletter_subscriptionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Newsletter_subscriptionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Newsletter_subscriptionsMinAggregateInputType = {
    id?: true
    user_id?: true
    subscription_type?: true
    is_active?: true
    email?: true
    created_at?: true
    updated_at?: true
  }

  export type Newsletter_subscriptionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    subscription_type?: true
    is_active?: true
    email?: true
    created_at?: true
    updated_at?: true
  }

  export type Newsletter_subscriptionsCountAggregateInputType = {
    id?: true
    user_id?: true
    subscription_type?: true
    is_active?: true
    email?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Newsletter_subscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_subscriptions to aggregate.
     */
    where?: newsletter_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_subscriptions to fetch.
     */
    orderBy?: newsletter_subscriptionsOrderByWithRelationInput | newsletter_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsletter_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsletter_subscriptions
    **/
    _count?: true | Newsletter_subscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Newsletter_subscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Newsletter_subscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Newsletter_subscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Newsletter_subscriptionsMaxAggregateInputType
  }

  export type GetNewsletter_subscriptionsAggregateType<T extends Newsletter_subscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter_subscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter_subscriptions[P]>
      : GetScalarType<T[P], AggregateNewsletter_subscriptions[P]>
  }




  export type newsletter_subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsletter_subscriptionsWhereInput
    orderBy?: newsletter_subscriptionsOrderByWithAggregationInput | newsletter_subscriptionsOrderByWithAggregationInput[]
    by: Newsletter_subscriptionsScalarFieldEnum[] | Newsletter_subscriptionsScalarFieldEnum
    having?: newsletter_subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Newsletter_subscriptionsCountAggregateInputType | true
    _avg?: Newsletter_subscriptionsAvgAggregateInputType
    _sum?: Newsletter_subscriptionsSumAggregateInputType
    _min?: Newsletter_subscriptionsMinAggregateInputType
    _max?: Newsletter_subscriptionsMaxAggregateInputType
  }

  export type Newsletter_subscriptionsGroupByOutputType = {
    id: number
    user_id: number
    subscription_type: string
    is_active: boolean | null
    email: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Newsletter_subscriptionsCountAggregateOutputType | null
    _avg: Newsletter_subscriptionsAvgAggregateOutputType | null
    _sum: Newsletter_subscriptionsSumAggregateOutputType | null
    _min: Newsletter_subscriptionsMinAggregateOutputType | null
    _max: Newsletter_subscriptionsMaxAggregateOutputType | null
  }

  type GetNewsletter_subscriptionsGroupByPayload<T extends newsletter_subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Newsletter_subscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Newsletter_subscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Newsletter_subscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Newsletter_subscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type newsletter_subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subscription_type?: boolean
    is_active?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
    newsletter_logs?: boolean | newsletter_subscriptions$newsletter_logsArgs<ExtArgs>
    newsletter_preferences?: boolean | newsletter_subscriptions$newsletter_preferencesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Newsletter_subscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_subscriptions"]>

  export type newsletter_subscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subscription_type?: boolean
    is_active?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsletter_subscriptions"]>

  export type newsletter_subscriptionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    subscription_type?: boolean
    is_active?: boolean
    email?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type newsletter_subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    newsletter_logs?: boolean | newsletter_subscriptions$newsletter_logsArgs<ExtArgs>
    newsletter_preferences?: boolean | newsletter_subscriptions$newsletter_preferencesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Newsletter_subscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type newsletter_subscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $newsletter_subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsletter_subscriptions"
    objects: {
      newsletter_logs: Prisma.$newsletter_logsPayload<ExtArgs>[]
      newsletter_preferences: Prisma.$newsletter_preferencesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      subscription_type: string
      is_active: boolean | null
      email: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["newsletter_subscriptions"]>
    composites: {}
  }

  type newsletter_subscriptionsGetPayload<S extends boolean | null | undefined | newsletter_subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$newsletter_subscriptionsPayload, S>

  type newsletter_subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<newsletter_subscriptionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Newsletter_subscriptionsCountAggregateInputType | true
    }

  export interface newsletter_subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsletter_subscriptions'], meta: { name: 'newsletter_subscriptions' } }
    /**
     * Find zero or one Newsletter_subscriptions that matches the filter.
     * @param {newsletter_subscriptionsFindUniqueArgs} args - Arguments to find a Newsletter_subscriptions
     * @example
     * // Get one Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsletter_subscriptionsFindUniqueArgs>(args: SelectSubset<T, newsletter_subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Newsletter_subscriptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {newsletter_subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Newsletter_subscriptions
     * @example
     * // Get one Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsletter_subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, newsletter_subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Newsletter_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsFindFirstArgs} args - Arguments to find a Newsletter_subscriptions
     * @example
     * // Get one Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsletter_subscriptionsFindFirstArgs>(args?: SelectSubset<T, newsletter_subscriptionsFindFirstArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Newsletter_subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Newsletter_subscriptions
     * @example
     * // Get one Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsletter_subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, newsletter_subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Newsletter_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findMany()
     * 
     * // Get first 10 Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletter_subscriptionsWithIdOnly = await prisma.newsletter_subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsletter_subscriptionsFindManyArgs>(args?: SelectSubset<T, newsletter_subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Newsletter_subscriptions.
     * @param {newsletter_subscriptionsCreateArgs} args - Arguments to create a Newsletter_subscriptions.
     * @example
     * // Create one Newsletter_subscriptions
     * const Newsletter_subscriptions = await prisma.newsletter_subscriptions.create({
     *   data: {
     *     // ... data to create a Newsletter_subscriptions
     *   }
     * })
     * 
     */
    create<T extends newsletter_subscriptionsCreateArgs>(args: SelectSubset<T, newsletter_subscriptionsCreateArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Newsletter_subscriptions.
     * @param {newsletter_subscriptionsCreateManyArgs} args - Arguments to create many Newsletter_subscriptions.
     * @example
     * // Create many Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsletter_subscriptionsCreateManyArgs>(args?: SelectSubset<T, newsletter_subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Newsletter_subscriptions and returns the data saved in the database.
     * @param {newsletter_subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Newsletter_subscriptions.
     * @example
     * // Create many Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Newsletter_subscriptions and only return the `id`
     * const newsletter_subscriptionsWithIdOnly = await prisma.newsletter_subscriptions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends newsletter_subscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, newsletter_subscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Newsletter_subscriptions.
     * @param {newsletter_subscriptionsDeleteArgs} args - Arguments to delete one Newsletter_subscriptions.
     * @example
     * // Delete one Newsletter_subscriptions
     * const Newsletter_subscriptions = await prisma.newsletter_subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Newsletter_subscriptions
     *   }
     * })
     * 
     */
    delete<T extends newsletter_subscriptionsDeleteArgs>(args: SelectSubset<T, newsletter_subscriptionsDeleteArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Newsletter_subscriptions.
     * @param {newsletter_subscriptionsUpdateArgs} args - Arguments to update one Newsletter_subscriptions.
     * @example
     * // Update one Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsletter_subscriptionsUpdateArgs>(args: SelectSubset<T, newsletter_subscriptionsUpdateArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Newsletter_subscriptions.
     * @param {newsletter_subscriptionsDeleteManyArgs} args - Arguments to filter Newsletter_subscriptions to delete.
     * @example
     * // Delete a few Newsletter_subscriptions
     * const { count } = await prisma.newsletter_subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsletter_subscriptionsDeleteManyArgs>(args?: SelectSubset<T, newsletter_subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletter_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsletter_subscriptionsUpdateManyArgs>(args: SelectSubset<T, newsletter_subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter_subscriptions.
     * @param {newsletter_subscriptionsUpsertArgs} args - Arguments to update or create a Newsletter_subscriptions.
     * @example
     * // Update or create a Newsletter_subscriptions
     * const newsletter_subscriptions = await prisma.newsletter_subscriptions.upsert({
     *   create: {
     *     // ... data to create a Newsletter_subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter_subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends newsletter_subscriptionsUpsertArgs>(args: SelectSubset<T, newsletter_subscriptionsUpsertArgs<ExtArgs>>): Prisma__newsletter_subscriptionsClient<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Newsletter_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsCountArgs} args - Arguments to filter Newsletter_subscriptions to count.
     * @example
     * // Count the number of Newsletter_subscriptions
     * const count = await prisma.newsletter_subscriptions.count({
     *   where: {
     *     // ... the filter for the Newsletter_subscriptions we want to count
     *   }
     * })
    **/
    count<T extends newsletter_subscriptionsCountArgs>(
      args?: Subset<T, newsletter_subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Newsletter_subscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Newsletter_subscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Newsletter_subscriptionsAggregateArgs>(args: Subset<T, Newsletter_subscriptionsAggregateArgs>): Prisma.PrismaPromise<GetNewsletter_subscriptionsAggregateType<T>>

    /**
     * Group by Newsletter_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsletter_subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsletter_subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsletter_subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: newsletter_subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsletter_subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletter_subscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsletter_subscriptions model
   */
  readonly fields: newsletter_subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsletter_subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsletter_subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    newsletter_logs<T extends newsletter_subscriptions$newsletter_logsArgs<ExtArgs> = {}>(args?: Subset<T, newsletter_subscriptions$newsletter_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_logsPayload<ExtArgs>, T, "findMany"> | Null>
    newsletter_preferences<T extends newsletter_subscriptions$newsletter_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, newsletter_subscriptions$newsletter_preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_preferencesPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsletter_subscriptions model
   */ 
  interface newsletter_subscriptionsFieldRefs {
    readonly id: FieldRef<"newsletter_subscriptions", 'Int'>
    readonly user_id: FieldRef<"newsletter_subscriptions", 'Int'>
    readonly subscription_type: FieldRef<"newsletter_subscriptions", 'String'>
    readonly is_active: FieldRef<"newsletter_subscriptions", 'Boolean'>
    readonly email: FieldRef<"newsletter_subscriptions", 'String'>
    readonly created_at: FieldRef<"newsletter_subscriptions", 'DateTime'>
    readonly updated_at: FieldRef<"newsletter_subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * newsletter_subscriptions findUnique
   */
  export type newsletter_subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_subscriptions to fetch.
     */
    where: newsletter_subscriptionsWhereUniqueInput
  }

  /**
   * newsletter_subscriptions findUniqueOrThrow
   */
  export type newsletter_subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_subscriptions to fetch.
     */
    where: newsletter_subscriptionsWhereUniqueInput
  }

  /**
   * newsletter_subscriptions findFirst
   */
  export type newsletter_subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_subscriptions to fetch.
     */
    where?: newsletter_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_subscriptions to fetch.
     */
    orderBy?: newsletter_subscriptionsOrderByWithRelationInput | newsletter_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_subscriptions.
     */
    cursor?: newsletter_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_subscriptions.
     */
    distinct?: Newsletter_subscriptionsScalarFieldEnum | Newsletter_subscriptionsScalarFieldEnum[]
  }

  /**
   * newsletter_subscriptions findFirstOrThrow
   */
  export type newsletter_subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_subscriptions to fetch.
     */
    where?: newsletter_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_subscriptions to fetch.
     */
    orderBy?: newsletter_subscriptionsOrderByWithRelationInput | newsletter_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsletter_subscriptions.
     */
    cursor?: newsletter_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsletter_subscriptions.
     */
    distinct?: Newsletter_subscriptionsScalarFieldEnum | Newsletter_subscriptionsScalarFieldEnum[]
  }

  /**
   * newsletter_subscriptions findMany
   */
  export type newsletter_subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which newsletter_subscriptions to fetch.
     */
    where?: newsletter_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsletter_subscriptions to fetch.
     */
    orderBy?: newsletter_subscriptionsOrderByWithRelationInput | newsletter_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsletter_subscriptions.
     */
    cursor?: newsletter_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsletter_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsletter_subscriptions.
     */
    skip?: number
    distinct?: Newsletter_subscriptionsScalarFieldEnum | Newsletter_subscriptionsScalarFieldEnum[]
  }

  /**
   * newsletter_subscriptions create
   */
  export type newsletter_subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a newsletter_subscriptions.
     */
    data: XOR<newsletter_subscriptionsCreateInput, newsletter_subscriptionsUncheckedCreateInput>
  }

  /**
   * newsletter_subscriptions createMany
   */
  export type newsletter_subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsletter_subscriptions.
     */
    data: newsletter_subscriptionsCreateManyInput | newsletter_subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsletter_subscriptions createManyAndReturn
   */
  export type newsletter_subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many newsletter_subscriptions.
     */
    data: newsletter_subscriptionsCreateManyInput | newsletter_subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * newsletter_subscriptions update
   */
  export type newsletter_subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a newsletter_subscriptions.
     */
    data: XOR<newsletter_subscriptionsUpdateInput, newsletter_subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which newsletter_subscriptions to update.
     */
    where: newsletter_subscriptionsWhereUniqueInput
  }

  /**
   * newsletter_subscriptions updateMany
   */
  export type newsletter_subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsletter_subscriptions.
     */
    data: XOR<newsletter_subscriptionsUpdateManyMutationInput, newsletter_subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which newsletter_subscriptions to update
     */
    where?: newsletter_subscriptionsWhereInput
  }

  /**
   * newsletter_subscriptions upsert
   */
  export type newsletter_subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the newsletter_subscriptions to update in case it exists.
     */
    where: newsletter_subscriptionsWhereUniqueInput
    /**
     * In case the newsletter_subscriptions found by the `where` argument doesn't exist, create a new newsletter_subscriptions with this data.
     */
    create: XOR<newsletter_subscriptionsCreateInput, newsletter_subscriptionsUncheckedCreateInput>
    /**
     * In case the newsletter_subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsletter_subscriptionsUpdateInput, newsletter_subscriptionsUncheckedUpdateInput>
  }

  /**
   * newsletter_subscriptions delete
   */
  export type newsletter_subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which newsletter_subscriptions to delete.
     */
    where: newsletter_subscriptionsWhereUniqueInput
  }

  /**
   * newsletter_subscriptions deleteMany
   */
  export type newsletter_subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsletter_subscriptions to delete
     */
    where?: newsletter_subscriptionsWhereInput
  }

  /**
   * newsletter_subscriptions.newsletter_logs
   */
  export type newsletter_subscriptions$newsletter_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_logs
     */
    select?: newsletter_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_logsInclude<ExtArgs> | null
    where?: newsletter_logsWhereInput
    orderBy?: newsletter_logsOrderByWithRelationInput | newsletter_logsOrderByWithRelationInput[]
    cursor?: newsletter_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Newsletter_logsScalarFieldEnum | Newsletter_logsScalarFieldEnum[]
  }

  /**
   * newsletter_subscriptions.newsletter_preferences
   */
  export type newsletter_subscriptions$newsletter_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_preferences
     */
    select?: newsletter_preferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_preferencesInclude<ExtArgs> | null
    where?: newsletter_preferencesWhereInput
    orderBy?: newsletter_preferencesOrderByWithRelationInput | newsletter_preferencesOrderByWithRelationInput[]
    cursor?: newsletter_preferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Newsletter_preferencesScalarFieldEnum | Newsletter_preferencesScalarFieldEnum[]
  }

  /**
   * newsletter_subscriptions without action
   */
  export type newsletter_subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    name: $Enums.permissiontype | null
    description: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    name: $Enums.permissiontype | null
    description: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    name: number
    description: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    name?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionMaxAggregateInputType = {
    name?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionCountAggregateInputType = {
    name?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    name: $Enums.permissiontype
    description: string | null
    id: number
    created_at: Date
    updated_at: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_permissions?: boolean | permission$user_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    name?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type permissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_permissions?: boolean | permission$user_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission"
    objects: {
      user_permissions: Prisma.$user_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: $Enums.permissiontype
      description: string | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type permissionGetPayload<S extends boolean | null | undefined | permissionDefaultArgs> = $Result.GetResult<Prisma.$permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionFindUniqueArgs>(args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionFindFirstArgs>(args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const permissionWithDescriptionOnly = await prisma.permission.findMany({ select: { description: true } })
     * 
     */
    findMany<T extends permissionFindManyArgs>(args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends permissionCreateArgs>(args: SelectSubset<T, permissionCreateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionCreateManyArgs>(args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `description`
     * const permissionWithDescriptionOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { description: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends permissionDeleteArgs>(args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionUpdateArgs>(args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionDeleteManyArgs>(args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionUpdateManyArgs>(args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends permissionUpsertArgs>(args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_permissions<T extends permission$user_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permission$user_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission model
   */ 
  interface permissionFieldRefs {
    readonly name: FieldRef<"permission", 'permissiontype'>
    readonly description: FieldRef<"permission", 'String'>
    readonly id: FieldRef<"permission", 'Int'>
    readonly created_at: FieldRef<"permission", 'DateTime'>
    readonly updated_at: FieldRef<"permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }

  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission createManyAndReturn
   */
  export type permissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
  }

  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }

  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
  }

  /**
   * permission.user_permissions
   */
  export type permission$user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    cursor?: user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * permission without action
   */
  export type permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
  }


  /**
   * Model publications
   */

  export type AggregatePublications = {
    _count: PublicationsCountAggregateOutputType | null
    _avg: PublicationsAvgAggregateOutputType | null
    _sum: PublicationsSumAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  export type PublicationsAvgAggregateOutputType = {
    id: number | null
  }

  export type PublicationsSumAggregateOutputType = {
    id: number | null
  }

  export type PublicationsMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    description: string | null
    link: string | null
    image_url: string | null
    source: string | null
    created_at: Date | null
  }

  export type PublicationsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
    description: string | null
    link: string | null
    image_url: string | null
    source: string | null
    created_at: Date | null
  }

  export type PublicationsCountAggregateOutputType = {
    id: number
    title: number
    date: number
    description: number
    link: number
    image_url: number
    source: number
    created_at: number
    _all: number
  }


  export type PublicationsAvgAggregateInputType = {
    id?: true
  }

  export type PublicationsSumAggregateInputType = {
    id?: true
  }

  export type PublicationsMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    description?: true
    link?: true
    image_url?: true
    source?: true
    created_at?: true
  }

  export type PublicationsMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    description?: true
    link?: true
    image_url?: true
    source?: true
    created_at?: true
  }

  export type PublicationsCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    description?: true
    link?: true
    image_url?: true
    source?: true
    created_at?: true
    _all?: true
  }

  export type PublicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publications to aggregate.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publications
    **/
    _count?: true | PublicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationsMaxAggregateInputType
  }

  export type GetPublicationsAggregateType<T extends PublicationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublications[P]>
      : GetScalarType<T[P], AggregatePublications[P]>
  }




  export type publicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publicationsWhereInput
    orderBy?: publicationsOrderByWithAggregationInput | publicationsOrderByWithAggregationInput[]
    by: PublicationsScalarFieldEnum[] | PublicationsScalarFieldEnum
    having?: publicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationsCountAggregateInputType | true
    _avg?: PublicationsAvgAggregateInputType
    _sum?: PublicationsSumAggregateInputType
    _min?: PublicationsMinAggregateInputType
    _max?: PublicationsMaxAggregateInputType
  }

  export type PublicationsGroupByOutputType = {
    id: number
    title: string | null
    date: Date | null
    description: string | null
    link: string | null
    image_url: string | null
    source: string | null
    created_at: Date | null
    _count: PublicationsCountAggregateOutputType | null
    _avg: PublicationsAvgAggregateOutputType | null
    _sum: PublicationsSumAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  type GetPublicationsGroupByPayload<T extends publicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
        }
      >
    >


  export type publicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    link?: boolean
    image_url?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["publications"]>

  export type publicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    link?: boolean
    image_url?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["publications"]>

  export type publicationsSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    description?: boolean
    link?: boolean
    image_url?: boolean
    source?: boolean
    created_at?: boolean
  }


  export type $publicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      date: Date | null
      description: string | null
      link: string | null
      image_url: string | null
      source: string | null
      created_at: Date | null
    }, ExtArgs["result"]["publications"]>
    composites: {}
  }

  type publicationsGetPayload<S extends boolean | null | undefined | publicationsDefaultArgs> = $Result.GetResult<Prisma.$publicationsPayload, S>

  type publicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<publicationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicationsCountAggregateInputType | true
    }

  export interface publicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publications'], meta: { name: 'publications' } }
    /**
     * Find zero or one Publications that matches the filter.
     * @param {publicationsFindUniqueArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publicationsFindUniqueArgs>(args: SelectSubset<T, publicationsFindUniqueArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Publications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {publicationsFindUniqueOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, publicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindFirstArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publicationsFindFirstArgs>(args?: SelectSubset<T, publicationsFindFirstArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Publications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindFirstOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, publicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publications.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationsWithIdOnly = await prisma.publications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends publicationsFindManyArgs>(args?: SelectSubset<T, publicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Publications.
     * @param {publicationsCreateArgs} args - Arguments to create a Publications.
     * @example
     * // Create one Publications
     * const Publications = await prisma.publications.create({
     *   data: {
     *     // ... data to create a Publications
     *   }
     * })
     * 
     */
    create<T extends publicationsCreateArgs>(args: SelectSubset<T, publicationsCreateArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Publications.
     * @param {publicationsCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publicationsCreateManyArgs>(args?: SelectSubset<T, publicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {publicationsCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publications and only return the `id`
     * const publicationsWithIdOnly = await prisma.publications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, publicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Publications.
     * @param {publicationsDeleteArgs} args - Arguments to delete one Publications.
     * @example
     * // Delete one Publications
     * const Publications = await prisma.publications.delete({
     *   where: {
     *     // ... filter to delete one Publications
     *   }
     * })
     * 
     */
    delete<T extends publicationsDeleteArgs>(args: SelectSubset<T, publicationsDeleteArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Publications.
     * @param {publicationsUpdateArgs} args - Arguments to update one Publications.
     * @example
     * // Update one Publications
     * const publications = await prisma.publications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publicationsUpdateArgs>(args: SelectSubset<T, publicationsUpdateArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Publications.
     * @param {publicationsDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publicationsDeleteManyArgs>(args?: SelectSubset<T, publicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publications = await prisma.publications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publicationsUpdateManyArgs>(args: SelectSubset<T, publicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publications.
     * @param {publicationsUpsertArgs} args - Arguments to update or create a Publications.
     * @example
     * // Update or create a Publications
     * const publications = await prisma.publications.upsert({
     *   create: {
     *     // ... data to create a Publications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publications we want to update
     *   }
     * })
     */
    upsert<T extends publicationsUpsertArgs>(args: SelectSubset<T, publicationsUpsertArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publications.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends publicationsCountArgs>(
      args?: Subset<T, publicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationsAggregateArgs>(args: Subset<T, PublicationsAggregateArgs>): Prisma.PrismaPromise<GetPublicationsAggregateType<T>>

    /**
     * Group by Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publicationsGroupByArgs['orderBy'] }
        : { orderBy?: publicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publications model
   */
  readonly fields: publicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publications model
   */ 
  interface publicationsFieldRefs {
    readonly id: FieldRef<"publications", 'Int'>
    readonly title: FieldRef<"publications", 'String'>
    readonly date: FieldRef<"publications", 'DateTime'>
    readonly description: FieldRef<"publications", 'String'>
    readonly link: FieldRef<"publications", 'String'>
    readonly image_url: FieldRef<"publications", 'String'>
    readonly source: FieldRef<"publications", 'String'>
    readonly created_at: FieldRef<"publications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * publications findUnique
   */
  export type publicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications findUniqueOrThrow
   */
  export type publicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications findFirst
   */
  export type publicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications findFirstOrThrow
   */
  export type publicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications findMany
   */
  export type publicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications create
   */
  export type publicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * The data needed to create a publications.
     */
    data?: XOR<publicationsCreateInput, publicationsUncheckedCreateInput>
  }

  /**
   * publications createMany
   */
  export type publicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publications.
     */
    data: publicationsCreateManyInput | publicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publications createManyAndReturn
   */
  export type publicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many publications.
     */
    data: publicationsCreateManyInput | publicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publications update
   */
  export type publicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * The data needed to update a publications.
     */
    data: XOR<publicationsUpdateInput, publicationsUncheckedUpdateInput>
    /**
     * Choose, which publications to update.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications updateMany
   */
  export type publicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publications.
     */
    data: XOR<publicationsUpdateManyMutationInput, publicationsUncheckedUpdateManyInput>
    /**
     * Filter which publications to update
     */
    where?: publicationsWhereInput
  }

  /**
   * publications upsert
   */
  export type publicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * The filter to search for the publications to update in case it exists.
     */
    where: publicationsWhereUniqueInput
    /**
     * In case the publications found by the `where` argument doesn't exist, create a new publications with this data.
     */
    create: XOR<publicationsCreateInput, publicationsUncheckedCreateInput>
    /**
     * In case the publications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publicationsUpdateInput, publicationsUncheckedUpdateInput>
  }

  /**
   * publications delete
   */
  export type publicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Filter which publications to delete.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications deleteMany
   */
  export type publicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publications to delete
     */
    where?: publicationsWhereInput
  }

  /**
   * publications without action
   */
  export type publicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
  }


  /**
   * Model refreshtoken
   */

  export type AggregateRefreshtoken = {
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  export type RefreshtokenAvgAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type RefreshtokenSumAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type RefreshtokenMinAggregateOutputType = {
    token: string | null
    user_id: number | null
    expires_at: Date | null
    revoked: boolean | null
    revoked_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RefreshtokenMaxAggregateOutputType = {
    token: string | null
    user_id: number | null
    expires_at: Date | null
    revoked: boolean | null
    revoked_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RefreshtokenCountAggregateOutputType = {
    token: number
    user_id: number
    expires_at: number
    revoked: number
    revoked_at: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RefreshtokenAvgAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type RefreshtokenSumAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type RefreshtokenMinAggregateInputType = {
    token?: true
    user_id?: true
    expires_at?: true
    revoked?: true
    revoked_at?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type RefreshtokenMaxAggregateInputType = {
    token?: true
    user_id?: true
    expires_at?: true
    revoked?: true
    revoked_at?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type RefreshtokenCountAggregateInputType = {
    token?: true
    user_id?: true
    expires_at?: true
    revoked?: true
    revoked_at?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RefreshtokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtoken to aggregate.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refreshtokens
    **/
    _count?: true | RefreshtokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshtokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshtokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshtokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type GetRefreshtokenAggregateType<T extends RefreshtokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshtoken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshtoken[P]>
      : GetScalarType<T[P], AggregateRefreshtoken[P]>
  }




  export type refreshtokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithAggregationInput | refreshtokenOrderByWithAggregationInput[]
    by: RefreshtokenScalarFieldEnum[] | RefreshtokenScalarFieldEnum
    having?: refreshtokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshtokenCountAggregateInputType | true
    _avg?: RefreshtokenAvgAggregateInputType
    _sum?: RefreshtokenSumAggregateInputType
    _min?: RefreshtokenMinAggregateInputType
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type RefreshtokenGroupByOutputType = {
    token: string
    user_id: number
    expires_at: Date
    revoked: boolean
    revoked_at: Date | null
    id: number
    created_at: Date
    updated_at: Date
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  type GetRefreshtokenGroupByPayload<T extends refreshtokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshtokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshtokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
        }
      >
    >


  export type refreshtokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    user_id?: boolean
    expires_at?: boolean
    revoked?: boolean
    revoked_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>

  export type refreshtokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    user_id?: boolean
    expires_at?: boolean
    revoked?: boolean
    revoked_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>

  export type refreshtokenSelectScalar = {
    token?: boolean
    user_id?: boolean
    expires_at?: boolean
    revoked?: boolean
    revoked_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type refreshtokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type refreshtokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $refreshtokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refreshtoken"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      token: string
      user_id: number
      expires_at: Date
      revoked: boolean
      revoked_at: Date | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["refreshtoken"]>
    composites: {}
  }

  type refreshtokenGetPayload<S extends boolean | null | undefined | refreshtokenDefaultArgs> = $Result.GetResult<Prisma.$refreshtokenPayload, S>

  type refreshtokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<refreshtokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshtokenCountAggregateInputType | true
    }

  export interface refreshtokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refreshtoken'], meta: { name: 'refreshtoken' } }
    /**
     * Find zero or one Refreshtoken that matches the filter.
     * @param {refreshtokenFindUniqueArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refreshtokenFindUniqueArgs>(args: SelectSubset<T, refreshtokenFindUniqueArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refreshtoken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {refreshtokenFindUniqueOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refreshtokenFindUniqueOrThrowArgs>(args: SelectSubset<T, refreshtokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refreshtokenFindFirstArgs>(args?: SelectSubset<T, refreshtokenFindFirstArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refreshtokenFindFirstOrThrowArgs>(args?: SelectSubset<T, refreshtokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refreshtokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany()
     * 
     * // Get first 10 Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const refreshtokenWithTokenOnly = await prisma.refreshtoken.findMany({ select: { token: true } })
     * 
     */
    findMany<T extends refreshtokenFindManyArgs>(args?: SelectSubset<T, refreshtokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refreshtoken.
     * @param {refreshtokenCreateArgs} args - Arguments to create a Refreshtoken.
     * @example
     * // Create one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.create({
     *   data: {
     *     // ... data to create a Refreshtoken
     *   }
     * })
     * 
     */
    create<T extends refreshtokenCreateArgs>(args: SelectSubset<T, refreshtokenCreateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refreshtokens.
     * @param {refreshtokenCreateManyArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refreshtokenCreateManyArgs>(args?: SelectSubset<T, refreshtokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refreshtokens and returns the data saved in the database.
     * @param {refreshtokenCreateManyAndReturnArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refreshtokens and only return the `token`
     * const refreshtokenWithTokenOnly = await prisma.refreshtoken.createManyAndReturn({ 
     *   select: { token: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends refreshtokenCreateManyAndReturnArgs>(args?: SelectSubset<T, refreshtokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Refreshtoken.
     * @param {refreshtokenDeleteArgs} args - Arguments to delete one Refreshtoken.
     * @example
     * // Delete one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.delete({
     *   where: {
     *     // ... filter to delete one Refreshtoken
     *   }
     * })
     * 
     */
    delete<T extends refreshtokenDeleteArgs>(args: SelectSubset<T, refreshtokenDeleteArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refreshtoken.
     * @param {refreshtokenUpdateArgs} args - Arguments to update one Refreshtoken.
     * @example
     * // Update one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refreshtokenUpdateArgs>(args: SelectSubset<T, refreshtokenUpdateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refreshtokens.
     * @param {refreshtokenDeleteManyArgs} args - Arguments to filter Refreshtokens to delete.
     * @example
     * // Delete a few Refreshtokens
     * const { count } = await prisma.refreshtoken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refreshtokenDeleteManyArgs>(args?: SelectSubset<T, refreshtokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refreshtokenUpdateManyArgs>(args: SelectSubset<T, refreshtokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refreshtoken.
     * @param {refreshtokenUpsertArgs} args - Arguments to update or create a Refreshtoken.
     * @example
     * // Update or create a Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.upsert({
     *   create: {
     *     // ... data to create a Refreshtoken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refreshtoken we want to update
     *   }
     * })
     */
    upsert<T extends refreshtokenUpsertArgs>(args: SelectSubset<T, refreshtokenUpsertArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenCountArgs} args - Arguments to filter Refreshtokens to count.
     * @example
     * // Count the number of Refreshtokens
     * const count = await prisma.refreshtoken.count({
     *   where: {
     *     // ... the filter for the Refreshtokens we want to count
     *   }
     * })
    **/
    count<T extends refreshtokenCountArgs>(
      args?: Subset<T, refreshtokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshtokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshtokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshtokenAggregateArgs>(args: Subset<T, RefreshtokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshtokenAggregateType<T>>

    /**
     * Group by Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refreshtokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refreshtokenGroupByArgs['orderBy'] }
        : { orderBy?: refreshtokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refreshtokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshtokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refreshtoken model
   */
  readonly fields: refreshtokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refreshtoken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refreshtokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refreshtoken model
   */ 
  interface refreshtokenFieldRefs {
    readonly token: FieldRef<"refreshtoken", 'String'>
    readonly user_id: FieldRef<"refreshtoken", 'Int'>
    readonly expires_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly revoked: FieldRef<"refreshtoken", 'Boolean'>
    readonly revoked_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly id: FieldRef<"refreshtoken", 'Int'>
    readonly created_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly updated_at: FieldRef<"refreshtoken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refreshtoken findUnique
   */
  export type refreshtokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findUniqueOrThrow
   */
  export type refreshtokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findFirst
   */
  export type refreshtokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findFirstOrThrow
   */
  export type refreshtokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findMany
   */
  export type refreshtokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtokens to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken create
   */
  export type refreshtokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to create a refreshtoken.
     */
    data: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
  }

  /**
   * refreshtoken createMany
   */
  export type refreshtokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refreshtoken createManyAndReturn
   */
  export type refreshtokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * refreshtoken update
   */
  export type refreshtokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to update a refreshtoken.
     */
    data: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
    /**
     * Choose, which refreshtoken to update.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken updateMany
   */
  export type refreshtokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refreshtokens.
     */
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyInput>
    /**
     * Filter which refreshtokens to update
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken upsert
   */
  export type refreshtokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The filter to search for the refreshtoken to update in case it exists.
     */
    where: refreshtokenWhereUniqueInput
    /**
     * In case the refreshtoken found by the `where` argument doesn't exist, create a new refreshtoken with this data.
     */
    create: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
    /**
     * In case the refreshtoken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
  }

  /**
   * refreshtoken delete
   */
  export type refreshtokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter which refreshtoken to delete.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken deleteMany
   */
  export type refreshtokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtokens to delete
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken without action
   */
  export type refreshtokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }


  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
  }


  /**
   * Model tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    name: string | null
    slug: string | null
    description: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagMaxAggregateOutputType = {
    name: string | null
    slug: string | null
    description: string | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagCountAggregateOutputType = {
    name: number
    slug: number
    description: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    name?: true
    slug?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type TagMaxAggregateInputType = {
    name?: true
    slug?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type TagCountAggregateInputType = {
    name?: true
    slug?: true
    description?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tag to aggregate.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type tagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagWhereInput
    orderBy?: tagOrderByWithAggregationInput | tagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: tagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    name: string
    slug: string
    description: string | null
    id: number
    created_at: Date
    updated_at: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends tagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type tagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    slug?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    article_tags?: boolean | tag$article_tagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type tagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    slug?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tag"]>

  export type tagSelectScalar = {
    name?: boolean
    slug?: boolean
    description?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article_tags?: boolean | tag$article_tagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tag"
    objects: {
      article_tags: Prisma.$article_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      slug: string
      description: string | null
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type tagGetPayload<S extends boolean | null | undefined | tagDefaultArgs> = $Result.GetResult<Prisma.$tagPayload, S>

  type tagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface tagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tag'], meta: { name: 'tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {tagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagFindUniqueArgs>(args: SelectSubset<T, tagFindUniqueArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagFindUniqueOrThrowArgs>(args: SelectSubset<T, tagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagFindFirstArgs>(args?: SelectSubset<T, tagFindFirstArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagFindFirstOrThrowArgs>(args?: SelectSubset<T, tagFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const tagWithNameOnly = await prisma.tag.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends tagFindManyArgs>(args?: SelectSubset<T, tagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {tagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends tagCreateArgs>(args: SelectSubset<T, tagCreateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {tagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagCreateManyArgs>(args?: SelectSubset<T, tagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `name`
     * const tagWithNameOnly = await prisma.tag.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagCreateManyAndReturnArgs>(args?: SelectSubset<T, tagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tag.
     * @param {tagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends tagDeleteArgs>(args: SelectSubset<T, tagDeleteArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {tagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagUpdateArgs>(args: SelectSubset<T, tagUpdateArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {tagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagDeleteManyArgs>(args?: SelectSubset<T, tagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagUpdateManyArgs>(args: SelectSubset<T, tagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {tagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends tagUpsertArgs>(args: SelectSubset<T, tagUpsertArgs<ExtArgs>>): Prisma__tagClient<$Result.GetResult<Prisma.$tagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagCountArgs>(
      args?: Subset<T, tagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagGroupByArgs['orderBy'] }
        : { orderBy?: tagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tag model
   */
  readonly fields: tagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article_tags<T extends tag$article_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tag$article_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$article_tagsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tag model
   */ 
  interface tagFieldRefs {
    readonly name: FieldRef<"tag", 'String'>
    readonly slug: FieldRef<"tag", 'String'>
    readonly description: FieldRef<"tag", 'String'>
    readonly id: FieldRef<"tag", 'Int'>
    readonly created_at: FieldRef<"tag", 'DateTime'>
    readonly updated_at: FieldRef<"tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tag findUnique
   */
  export type tagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findUniqueOrThrow
   */
  export type tagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag findFirst
   */
  export type tagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findFirstOrThrow
   */
  export type tagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tag to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag findMany
   */
  export type tagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagOrderByWithRelationInput | tagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * tag create
   */
  export type tagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to create a tag.
     */
    data: XOR<tagCreateInput, tagUncheckedCreateInput>
  }

  /**
   * tag createMany
   */
  export type tagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tag createManyAndReturn
   */
  export type tagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagCreateManyInput | tagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tag update
   */
  export type tagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The data needed to update a tag.
     */
    data: XOR<tagUpdateInput, tagUncheckedUpdateInput>
    /**
     * Choose, which tag to update.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag updateMany
   */
  export type tagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagUpdateManyMutationInput, tagUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagWhereInput
  }

  /**
   * tag upsert
   */
  export type tagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * The filter to search for the tag to update in case it exists.
     */
    where: tagWhereUniqueInput
    /**
     * In case the tag found by the `where` argument doesn't exist, create a new tag with this data.
     */
    create: XOR<tagCreateInput, tagUncheckedCreateInput>
    /**
     * In case the tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagUpdateInput, tagUncheckedUpdateInput>
  }

  /**
   * tag delete
   */
  export type tagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
    /**
     * Filter which tag to delete.
     */
    where: tagWhereUniqueInput
  }

  /**
   * tag deleteMany
   */
  export type tagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagWhereInput
  }

  /**
   * tag.article_tags
   */
  export type tag$article_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article_tags
     */
    select?: article_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: article_tagsInclude<ExtArgs> | null
    where?: article_tagsWhereInput
    orderBy?: article_tagsOrderByWithRelationInput | article_tagsOrderByWithRelationInput[]
    cursor?: article_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Article_tagsScalarFieldEnum | Article_tagsScalarFieldEnum[]
  }

  /**
   * tag without action
   */
  export type tagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tag
     */
    select?: tagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failed_login_attempts: number | null
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    failed_login_attempts: number | null
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    email: string | null
    username: string | null
    full_name: string | null
    hashed_password: string | null
    is_active: boolean | null
    is_verified: boolean | null
    role: $Enums.userrole | null
    bio: string | null
    avatar_url: string | null
    phone_number: string | null
    last_login_at: Date | null
    last_login_ip: string | null
    failed_login_attempts: number | null
    locked_until: Date | null
    two_factor_enabled: boolean | null
    two_factor_secret: string | null
    email_verified_at: Date | null
    email_verification_token: string | null
    password_reset_token: string | null
    password_reset_expires: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    email: string | null
    username: string | null
    full_name: string | null
    hashed_password: string | null
    is_active: boolean | null
    is_verified: boolean | null
    role: $Enums.userrole | null
    bio: string | null
    avatar_url: string | null
    phone_number: string | null
    last_login_at: Date | null
    last_login_ip: string | null
    failed_login_attempts: number | null
    locked_until: Date | null
    two_factor_enabled: boolean | null
    two_factor_secret: string | null
    email_verified_at: Date | null
    email_verification_token: string | null
    password_reset_token: string | null
    password_reset_expires: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    email: number
    username: number
    full_name: number
    hashed_password: number
    is_active: number
    is_verified: number
    role: number
    bio: number
    avatar_url: number
    phone_number: number
    last_login_at: number
    last_login_ip: number
    failed_login_attempts: number
    locked_until: number
    two_factor_enabled: number
    two_factor_secret: number
    email_verified_at: number
    email_verification_token: number
    password_reset_token: number
    password_reset_expires: number
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failed_login_attempts?: true
    id?: true
  }

  export type UserSumAggregateInputType = {
    failed_login_attempts?: true
    id?: true
  }

  export type UserMinAggregateInputType = {
    email?: true
    username?: true
    full_name?: true
    hashed_password?: true
    is_active?: true
    is_verified?: true
    role?: true
    bio?: true
    avatar_url?: true
    phone_number?: true
    last_login_at?: true
    last_login_ip?: true
    failed_login_attempts?: true
    locked_until?: true
    two_factor_enabled?: true
    two_factor_secret?: true
    email_verified_at?: true
    email_verification_token?: true
    password_reset_token?: true
    password_reset_expires?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    email?: true
    username?: true
    full_name?: true
    hashed_password?: true
    is_active?: true
    is_verified?: true
    role?: true
    bio?: true
    avatar_url?: true
    phone_number?: true
    last_login_at?: true
    last_login_ip?: true
    failed_login_attempts?: true
    locked_until?: true
    two_factor_enabled?: true
    two_factor_secret?: true
    email_verified_at?: true
    email_verification_token?: true
    password_reset_token?: true
    password_reset_expires?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    email?: true
    username?: true
    full_name?: true
    hashed_password?: true
    is_active?: true
    is_verified?: true
    role?: true
    bio?: true
    avatar_url?: true
    phone_number?: true
    last_login_at?: true
    last_login_ip?: true
    failed_login_attempts?: true
    locked_until?: true
    two_factor_enabled?: true
    two_factor_secret?: true
    email_verified_at?: true
    email_verification_token?: true
    password_reset_token?: true
    password_reset_expires?: true
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    email: string
    username: string | null
    full_name: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio: string | null
    avatar_url: string | null
    phone_number: string | null
    last_login_at: Date | null
    last_login_ip: string | null
    failed_login_attempts: number
    locked_until: Date | null
    two_factor_enabled: boolean
    two_factor_secret: string | null
    email_verified_at: Date | null
    email_verification_token: string | null
    password_reset_token: string | null
    password_reset_expires: Date | null
    id: number
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    username?: boolean
    full_name?: boolean
    hashed_password?: boolean
    is_active?: boolean
    is_verified?: boolean
    role?: boolean
    bio?: boolean
    avatar_url?: boolean
    phone_number?: boolean
    last_login_at?: boolean
    last_login_ip?: boolean
    failed_login_attempts?: boolean
    locked_until?: boolean
    two_factor_enabled?: boolean
    two_factor_secret?: boolean
    email_verified_at?: boolean
    email_verification_token?: boolean
    password_reset_token?: boolean
    password_reset_expires?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    activitylog?: boolean | user$activitylogArgs<ExtArgs>
    article?: boolean | user$articleArgs<ExtArgs>
    articlestar?: boolean | user$articlestarArgs<ExtArgs>
    articleview?: boolean | user$articleviewArgs<ExtArgs>
    event?: boolean | user$eventArgs<ExtArgs>
    eventregistration?: boolean | user$eventregistrationArgs<ExtArgs>
    refreshtoken?: boolean | user$refreshtokenArgs<ExtArgs>
    user_permissions?: boolean | user$user_permissionsArgs<ExtArgs>
    usersession?: boolean | user$usersessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    username?: boolean
    full_name?: boolean
    hashed_password?: boolean
    is_active?: boolean
    is_verified?: boolean
    role?: boolean
    bio?: boolean
    avatar_url?: boolean
    phone_number?: boolean
    last_login_at?: boolean
    last_login_ip?: boolean
    failed_login_attempts?: boolean
    locked_until?: boolean
    two_factor_enabled?: boolean
    two_factor_secret?: boolean
    email_verified_at?: boolean
    email_verification_token?: boolean
    password_reset_token?: boolean
    password_reset_expires?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    email?: boolean
    username?: boolean
    full_name?: boolean
    hashed_password?: boolean
    is_active?: boolean
    is_verified?: boolean
    role?: boolean
    bio?: boolean
    avatar_url?: boolean
    phone_number?: boolean
    last_login_at?: boolean
    last_login_ip?: boolean
    failed_login_attempts?: boolean
    locked_until?: boolean
    two_factor_enabled?: boolean
    two_factor_secret?: boolean
    email_verified_at?: boolean
    email_verification_token?: boolean
    password_reset_token?: boolean
    password_reset_expires?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitylog?: boolean | user$activitylogArgs<ExtArgs>
    article?: boolean | user$articleArgs<ExtArgs>
    articlestar?: boolean | user$articlestarArgs<ExtArgs>
    articleview?: boolean | user$articleviewArgs<ExtArgs>
    event?: boolean | user$eventArgs<ExtArgs>
    eventregistration?: boolean | user$eventregistrationArgs<ExtArgs>
    refreshtoken?: boolean | user$refreshtokenArgs<ExtArgs>
    user_permissions?: boolean | user$user_permissionsArgs<ExtArgs>
    usersession?: boolean | user$usersessionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      activitylog: Prisma.$activitylogPayload<ExtArgs>[]
      article: Prisma.$articlePayload<ExtArgs>[]
      articlestar: Prisma.$articlestarPayload<ExtArgs>[]
      articleview: Prisma.$articleviewPayload<ExtArgs>[]
      event: Prisma.$eventPayload<ExtArgs>[]
      eventregistration: Prisma.$eventregistrationPayload<ExtArgs>[]
      refreshtoken: Prisma.$refreshtokenPayload<ExtArgs>[]
      user_permissions: Prisma.$user_permissionsPayload<ExtArgs>[]
      usersession: Prisma.$usersessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      username: string | null
      full_name: string | null
      hashed_password: string
      is_active: boolean
      is_verified: boolean
      role: $Enums.userrole
      bio: string | null
      avatar_url: string | null
      phone_number: string | null
      last_login_at: Date | null
      last_login_ip: string | null
      failed_login_attempts: number
      locked_until: Date | null
      two_factor_enabled: boolean
      two_factor_secret: string | null
      email_verified_at: Date | null
      email_verification_token: string | null
      password_reset_token: string | null
      password_reset_expires: Date | null
      id: number
      created_at: Date
      updated_at: Date
      is_deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const userWithEmailOnly = await prisma.user.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `email`
     * const userWithEmailOnly = await prisma.user.createManyAndReturn({ 
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitylog<T extends user$activitylogArgs<ExtArgs> = {}>(args?: Subset<T, user$activitylogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findMany"> | Null>
    article<T extends user$articleArgs<ExtArgs> = {}>(args?: Subset<T, user$articleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlePayload<ExtArgs>, T, "findMany"> | Null>
    articlestar<T extends user$articlestarArgs<ExtArgs> = {}>(args?: Subset<T, user$articlestarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articlestarPayload<ExtArgs>, T, "findMany"> | Null>
    articleview<T extends user$articleviewArgs<ExtArgs> = {}>(args?: Subset<T, user$articleviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$articleviewPayload<ExtArgs>, T, "findMany"> | Null>
    event<T extends user$eventArgs<ExtArgs> = {}>(args?: Subset<T, user$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventPayload<ExtArgs>, T, "findMany"> | Null>
    eventregistration<T extends user$eventregistrationArgs<ExtArgs> = {}>(args?: Subset<T, user$eventregistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventregistrationPayload<ExtArgs>, T, "findMany"> | Null>
    refreshtoken<T extends user$refreshtokenArgs<ExtArgs> = {}>(args?: Subset<T, user$refreshtokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany"> | Null>
    user_permissions<T extends user$user_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany"> | Null>
    usersession<T extends user$usersessionArgs<ExtArgs> = {}>(args?: Subset<T, user$usersessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly email: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly full_name: FieldRef<"user", 'String'>
    readonly hashed_password: FieldRef<"user", 'String'>
    readonly is_active: FieldRef<"user", 'Boolean'>
    readonly is_verified: FieldRef<"user", 'Boolean'>
    readonly role: FieldRef<"user", 'userrole'>
    readonly bio: FieldRef<"user", 'String'>
    readonly avatar_url: FieldRef<"user", 'String'>
    readonly phone_number: FieldRef<"user", 'String'>
    readonly last_login_at: FieldRef<"user", 'DateTime'>
    readonly last_login_ip: FieldRef<"user", 'String'>
    readonly failed_login_attempts: FieldRef<"user", 'Int'>
    readonly locked_until: FieldRef<"user", 'DateTime'>
    readonly two_factor_enabled: FieldRef<"user", 'Boolean'>
    readonly two_factor_secret: FieldRef<"user", 'String'>
    readonly email_verified_at: FieldRef<"user", 'DateTime'>
    readonly email_verification_token: FieldRef<"user", 'String'>
    readonly password_reset_token: FieldRef<"user", 'String'>
    readonly password_reset_expires: FieldRef<"user", 'DateTime'>
    readonly id: FieldRef<"user", 'Int'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly is_deleted: FieldRef<"user", 'Boolean'>
    readonly deleted_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user.activitylog
   */
  export type user$activitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    where?: activitylogWhereInput
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    cursor?: activitylogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * user.article
   */
  export type user$articleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the article
     */
    select?: articleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleInclude<ExtArgs> | null
    where?: articleWhereInput
    orderBy?: articleOrderByWithRelationInput | articleOrderByWithRelationInput[]
    cursor?: articleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * user.articlestar
   */
  export type user$articlestarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articlestar
     */
    select?: articlestarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articlestarInclude<ExtArgs> | null
    where?: articlestarWhereInput
    orderBy?: articlestarOrderByWithRelationInput | articlestarOrderByWithRelationInput[]
    cursor?: articlestarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticlestarScalarFieldEnum | ArticlestarScalarFieldEnum[]
  }

  /**
   * user.articleview
   */
  export type user$articleviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the articleview
     */
    select?: articleviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: articleviewInclude<ExtArgs> | null
    where?: articleviewWhereInput
    orderBy?: articleviewOrderByWithRelationInput | articleviewOrderByWithRelationInput[]
    cursor?: articleviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleviewScalarFieldEnum | ArticleviewScalarFieldEnum[]
  }

  /**
   * user.event
   */
  export type user$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null
    where?: eventWhereInput
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[]
    cursor?: eventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * user.eventregistration
   */
  export type user$eventregistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventregistration
     */
    select?: eventregistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventregistrationInclude<ExtArgs> | null
    where?: eventregistrationWhereInput
    orderBy?: eventregistrationOrderByWithRelationInput | eventregistrationOrderByWithRelationInput[]
    cursor?: eventregistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventregistrationScalarFieldEnum | EventregistrationScalarFieldEnum[]
  }

  /**
   * user.refreshtoken
   */
  export type user$refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    cursor?: refreshtokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * user.user_permissions
   */
  export type user$user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    cursor?: user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user.usersession
   */
  export type user$usersessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    where?: usersessionWhereInput
    orderBy?: usersessionOrderByWithRelationInput | usersessionOrderByWithRelationInput[]
    cursor?: usersessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersessionScalarFieldEnum | UsersessionScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model user_activity
   */

  export type AggregateUser_activity = {
    _count: User_activityCountAggregateOutputType | null
    _avg: User_activityAvgAggregateOutputType | null
    _sum: User_activitySumAggregateOutputType | null
    _min: User_activityMinAggregateOutputType | null
    _max: User_activityMaxAggregateOutputType | null
  }

  export type User_activityAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    resource_id: number | null
  }

  export type User_activitySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    resource_id: number | null
  }

  export type User_activityMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    resource_type: string | null
    resource_id: number | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date | null
    created_at: Date | null
  }

  export type User_activityMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    action: string | null
    resource_type: string | null
    resource_id: number | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date | null
    created_at: Date | null
  }

  export type User_activityCountAggregateOutputType = {
    id: number
    user_id: number
    action: number
    resource_type: number
    resource_id: number
    details: number
    ip_address: number
    user_agent: number
    timestamp: number
    created_at: number
    _all: number
  }


  export type User_activityAvgAggregateInputType = {
    id?: true
    user_id?: true
    resource_id?: true
  }

  export type User_activitySumAggregateInputType = {
    id?: true
    user_id?: true
    resource_id?: true
  }

  export type User_activityMinAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    resource_type?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
    created_at?: true
  }

  export type User_activityMaxAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    resource_type?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
    created_at?: true
  }

  export type User_activityCountAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    resource_type?: true
    resource_id?: true
    details?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
    created_at?: true
    _all?: true
  }

  export type User_activityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_activity to aggregate.
     */
    where?: user_activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activities to fetch.
     */
    orderBy?: user_activityOrderByWithRelationInput | user_activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_activities
    **/
    _count?: true | User_activityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_activityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_activitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_activityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_activityMaxAggregateInputType
  }

  export type GetUser_activityAggregateType<T extends User_activityAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_activity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_activity[P]>
      : GetScalarType<T[P], AggregateUser_activity[P]>
  }




  export type user_activityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_activityWhereInput
    orderBy?: user_activityOrderByWithAggregationInput | user_activityOrderByWithAggregationInput[]
    by: User_activityScalarFieldEnum[] | User_activityScalarFieldEnum
    having?: user_activityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_activityCountAggregateInputType | true
    _avg?: User_activityAvgAggregateInputType
    _sum?: User_activitySumAggregateInputType
    _min?: User_activityMinAggregateInputType
    _max?: User_activityMaxAggregateInputType
  }

  export type User_activityGroupByOutputType = {
    id: number
    user_id: number
    action: string
    resource_type: string | null
    resource_id: number | null
    details: string | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date | null
    created_at: Date | null
    _count: User_activityCountAggregateOutputType | null
    _avg: User_activityAvgAggregateOutputType | null
    _sum: User_activitySumAggregateOutputType | null
    _min: User_activityMinAggregateOutputType | null
    _max: User_activityMaxAggregateOutputType | null
  }

  type GetUser_activityGroupByPayload<T extends user_activityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_activityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_activityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_activityGroupByOutputType[P]>
            : GetScalarType<T[P], User_activityGroupByOutputType[P]>
        }
      >
    >


  export type user_activitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    resource_type?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_activity"]>

  export type user_activitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    resource_type?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_activity"]>

  export type user_activitySelectScalar = {
    id?: boolean
    user_id?: boolean
    action?: boolean
    resource_type?: boolean
    resource_id?: boolean
    details?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    created_at?: boolean
  }

  export type user_activityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_activityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_activityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_activity"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      action: string
      resource_type: string | null
      resource_id: number | null
      details: string | null
      ip_address: string | null
      user_agent: string | null
      timestamp: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["user_activity"]>
    composites: {}
  }

  type user_activityGetPayload<S extends boolean | null | undefined | user_activityDefaultArgs> = $Result.GetResult<Prisma.$user_activityPayload, S>

  type user_activityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_activityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_activityCountAggregateInputType | true
    }

  export interface user_activityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_activity'], meta: { name: 'user_activity' } }
    /**
     * Find zero or one User_activity that matches the filter.
     * @param {user_activityFindUniqueArgs} args - Arguments to find a User_activity
     * @example
     * // Get one User_activity
     * const user_activity = await prisma.user_activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_activityFindUniqueArgs>(args: SelectSubset<T, user_activityFindUniqueArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_activityFindUniqueOrThrowArgs} args - Arguments to find a User_activity
     * @example
     * // Get one User_activity
     * const user_activity = await prisma.user_activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_activityFindUniqueOrThrowArgs>(args: SelectSubset<T, user_activityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityFindFirstArgs} args - Arguments to find a User_activity
     * @example
     * // Get one User_activity
     * const user_activity = await prisma.user_activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_activityFindFirstArgs>(args?: SelectSubset<T, user_activityFindFirstArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityFindFirstOrThrowArgs} args - Arguments to find a User_activity
     * @example
     * // Get one User_activity
     * const user_activity = await prisma.user_activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_activityFindFirstOrThrowArgs>(args?: SelectSubset<T, user_activityFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_activities
     * const user_activities = await prisma.user_activity.findMany()
     * 
     * // Get first 10 User_activities
     * const user_activities = await prisma.user_activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_activityWithIdOnly = await prisma.user_activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_activityFindManyArgs>(args?: SelectSubset<T, user_activityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_activity.
     * @param {user_activityCreateArgs} args - Arguments to create a User_activity.
     * @example
     * // Create one User_activity
     * const User_activity = await prisma.user_activity.create({
     *   data: {
     *     // ... data to create a User_activity
     *   }
     * })
     * 
     */
    create<T extends user_activityCreateArgs>(args: SelectSubset<T, user_activityCreateArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_activities.
     * @param {user_activityCreateManyArgs} args - Arguments to create many User_activities.
     * @example
     * // Create many User_activities
     * const user_activity = await prisma.user_activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_activityCreateManyArgs>(args?: SelectSubset<T, user_activityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_activities and returns the data saved in the database.
     * @param {user_activityCreateManyAndReturnArgs} args - Arguments to create many User_activities.
     * @example
     * // Create many User_activities
     * const user_activity = await prisma.user_activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_activities and only return the `id`
     * const user_activityWithIdOnly = await prisma.user_activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_activityCreateManyAndReturnArgs>(args?: SelectSubset<T, user_activityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_activity.
     * @param {user_activityDeleteArgs} args - Arguments to delete one User_activity.
     * @example
     * // Delete one User_activity
     * const User_activity = await prisma.user_activity.delete({
     *   where: {
     *     // ... filter to delete one User_activity
     *   }
     * })
     * 
     */
    delete<T extends user_activityDeleteArgs>(args: SelectSubset<T, user_activityDeleteArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_activity.
     * @param {user_activityUpdateArgs} args - Arguments to update one User_activity.
     * @example
     * // Update one User_activity
     * const user_activity = await prisma.user_activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_activityUpdateArgs>(args: SelectSubset<T, user_activityUpdateArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_activities.
     * @param {user_activityDeleteManyArgs} args - Arguments to filter User_activities to delete.
     * @example
     * // Delete a few User_activities
     * const { count } = await prisma.user_activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_activityDeleteManyArgs>(args?: SelectSubset<T, user_activityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_activities
     * const user_activity = await prisma.user_activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_activityUpdateManyArgs>(args: SelectSubset<T, user_activityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_activity.
     * @param {user_activityUpsertArgs} args - Arguments to update or create a User_activity.
     * @example
     * // Update or create a User_activity
     * const user_activity = await prisma.user_activity.upsert({
     *   create: {
     *     // ... data to create a User_activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_activity we want to update
     *   }
     * })
     */
    upsert<T extends user_activityUpsertArgs>(args: SelectSubset<T, user_activityUpsertArgs<ExtArgs>>): Prisma__user_activityClient<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityCountArgs} args - Arguments to filter User_activities to count.
     * @example
     * // Count the number of User_activities
     * const count = await prisma.user_activity.count({
     *   where: {
     *     // ... the filter for the User_activities we want to count
     *   }
     * })
    **/
    count<T extends user_activityCountArgs>(
      args?: Subset<T, user_activityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_activityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_activityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_activityAggregateArgs>(args: Subset<T, User_activityAggregateArgs>): Prisma.PrismaPromise<GetUser_activityAggregateType<T>>

    /**
     * Group by User_activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_activityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_activityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_activityGroupByArgs['orderBy'] }
        : { orderBy?: user_activityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_activityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_activityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_activity model
   */
  readonly fields: user_activityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_activityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_activity model
   */ 
  interface user_activityFieldRefs {
    readonly id: FieldRef<"user_activity", 'Int'>
    readonly user_id: FieldRef<"user_activity", 'Int'>
    readonly action: FieldRef<"user_activity", 'String'>
    readonly resource_type: FieldRef<"user_activity", 'String'>
    readonly resource_id: FieldRef<"user_activity", 'Int'>
    readonly details: FieldRef<"user_activity", 'String'>
    readonly ip_address: FieldRef<"user_activity", 'String'>
    readonly user_agent: FieldRef<"user_activity", 'String'>
    readonly timestamp: FieldRef<"user_activity", 'DateTime'>
    readonly created_at: FieldRef<"user_activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_activity findUnique
   */
  export type user_activityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter, which user_activity to fetch.
     */
    where: user_activityWhereUniqueInput
  }

  /**
   * user_activity findUniqueOrThrow
   */
  export type user_activityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter, which user_activity to fetch.
     */
    where: user_activityWhereUniqueInput
  }

  /**
   * user_activity findFirst
   */
  export type user_activityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter, which user_activity to fetch.
     */
    where?: user_activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activities to fetch.
     */
    orderBy?: user_activityOrderByWithRelationInput | user_activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_activities.
     */
    cursor?: user_activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_activities.
     */
    distinct?: User_activityScalarFieldEnum | User_activityScalarFieldEnum[]
  }

  /**
   * user_activity findFirstOrThrow
   */
  export type user_activityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter, which user_activity to fetch.
     */
    where?: user_activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activities to fetch.
     */
    orderBy?: user_activityOrderByWithRelationInput | user_activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_activities.
     */
    cursor?: user_activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_activities.
     */
    distinct?: User_activityScalarFieldEnum | User_activityScalarFieldEnum[]
  }

  /**
   * user_activity findMany
   */
  export type user_activityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter, which user_activities to fetch.
     */
    where?: user_activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_activities to fetch.
     */
    orderBy?: user_activityOrderByWithRelationInput | user_activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_activities.
     */
    cursor?: user_activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_activities.
     */
    skip?: number
    distinct?: User_activityScalarFieldEnum | User_activityScalarFieldEnum[]
  }

  /**
   * user_activity create
   */
  export type user_activityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * The data needed to create a user_activity.
     */
    data: XOR<user_activityCreateInput, user_activityUncheckedCreateInput>
  }

  /**
   * user_activity createMany
   */
  export type user_activityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_activities.
     */
    data: user_activityCreateManyInput | user_activityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_activity createManyAndReturn
   */
  export type user_activityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_activities.
     */
    data: user_activityCreateManyInput | user_activityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_activity update
   */
  export type user_activityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * The data needed to update a user_activity.
     */
    data: XOR<user_activityUpdateInput, user_activityUncheckedUpdateInput>
    /**
     * Choose, which user_activity to update.
     */
    where: user_activityWhereUniqueInput
  }

  /**
   * user_activity updateMany
   */
  export type user_activityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_activities.
     */
    data: XOR<user_activityUpdateManyMutationInput, user_activityUncheckedUpdateManyInput>
    /**
     * Filter which user_activities to update
     */
    where?: user_activityWhereInput
  }

  /**
   * user_activity upsert
   */
  export type user_activityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * The filter to search for the user_activity to update in case it exists.
     */
    where: user_activityWhereUniqueInput
    /**
     * In case the user_activity found by the `where` argument doesn't exist, create a new user_activity with this data.
     */
    create: XOR<user_activityCreateInput, user_activityUncheckedCreateInput>
    /**
     * In case the user_activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_activityUpdateInput, user_activityUncheckedUpdateInput>
  }

  /**
   * user_activity delete
   */
  export type user_activityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    /**
     * Filter which user_activity to delete.
     */
    where: user_activityWhereUniqueInput
  }

  /**
   * user_activity deleteMany
   */
  export type user_activityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_activities to delete
     */
    where?: user_activityWhereInput
  }

  /**
   * user_activity without action
   */
  export type user_activityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
  }


  /**
   * Model user_alerts
   */

  export type AggregateUser_alerts = {
    _count: User_alertsCountAggregateOutputType | null
    _avg: User_alertsAvgAggregateOutputType | null
    _sum: User_alertsSumAggregateOutputType | null
    _min: User_alertsMinAggregateOutputType | null
    _max: User_alertsMaxAggregateOutputType | null
  }

  export type User_alertsAvgAggregateOutputType = {
    id: number | null
  }

  export type User_alertsSumAggregateOutputType = {
    id: number | null
  }

  export type User_alertsMinAggregateOutputType = {
    id: number | null
    email: string | null
    sources: string | null
    sectors: string | null
    created_at: Date | null
  }

  export type User_alertsMaxAggregateOutputType = {
    id: number | null
    email: string | null
    sources: string | null
    sectors: string | null
    created_at: Date | null
  }

  export type User_alertsCountAggregateOutputType = {
    id: number
    email: number
    sources: number
    sectors: number
    created_at: number
    _all: number
  }


  export type User_alertsAvgAggregateInputType = {
    id?: true
  }

  export type User_alertsSumAggregateInputType = {
    id?: true
  }

  export type User_alertsMinAggregateInputType = {
    id?: true
    email?: true
    sources?: true
    sectors?: true
    created_at?: true
  }

  export type User_alertsMaxAggregateInputType = {
    id?: true
    email?: true
    sources?: true
    sectors?: true
    created_at?: true
  }

  export type User_alertsCountAggregateInputType = {
    id?: true
    email?: true
    sources?: true
    sectors?: true
    created_at?: true
    _all?: true
  }

  export type User_alertsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_alerts to aggregate.
     */
    where?: user_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_alerts to fetch.
     */
    orderBy?: user_alertsOrderByWithRelationInput | user_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_alerts
    **/
    _count?: true | User_alertsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_alertsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_alertsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_alertsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_alertsMaxAggregateInputType
  }

  export type GetUser_alertsAggregateType<T extends User_alertsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_alerts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_alerts[P]>
      : GetScalarType<T[P], AggregateUser_alerts[P]>
  }




  export type user_alertsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_alertsWhereInput
    orderBy?: user_alertsOrderByWithAggregationInput | user_alertsOrderByWithAggregationInput[]
    by: User_alertsScalarFieldEnum[] | User_alertsScalarFieldEnum
    having?: user_alertsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_alertsCountAggregateInputType | true
    _avg?: User_alertsAvgAggregateInputType
    _sum?: User_alertsSumAggregateInputType
    _min?: User_alertsMinAggregateInputType
    _max?: User_alertsMaxAggregateInputType
  }

  export type User_alertsGroupByOutputType = {
    id: number
    email: string
    sources: string | null
    sectors: string | null
    created_at: Date | null
    _count: User_alertsCountAggregateOutputType | null
    _avg: User_alertsAvgAggregateOutputType | null
    _sum: User_alertsSumAggregateOutputType | null
    _min: User_alertsMinAggregateOutputType | null
    _max: User_alertsMaxAggregateOutputType | null
  }

  type GetUser_alertsGroupByPayload<T extends user_alertsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_alertsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_alertsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_alertsGroupByOutputType[P]>
            : GetScalarType<T[P], User_alertsGroupByOutputType[P]>
        }
      >
    >


  export type user_alertsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    sources?: boolean
    sectors?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user_alerts"]>

  export type user_alertsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    sources?: boolean
    sectors?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user_alerts"]>

  export type user_alertsSelectScalar = {
    id?: boolean
    email?: boolean
    sources?: boolean
    sectors?: boolean
    created_at?: boolean
  }


  export type $user_alertsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_alerts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      sources: string | null
      sectors: string | null
      created_at: Date | null
    }, ExtArgs["result"]["user_alerts"]>
    composites: {}
  }

  type user_alertsGetPayload<S extends boolean | null | undefined | user_alertsDefaultArgs> = $Result.GetResult<Prisma.$user_alertsPayload, S>

  type user_alertsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_alertsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_alertsCountAggregateInputType | true
    }

  export interface user_alertsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_alerts'], meta: { name: 'user_alerts' } }
    /**
     * Find zero or one User_alerts that matches the filter.
     * @param {user_alertsFindUniqueArgs} args - Arguments to find a User_alerts
     * @example
     * // Get one User_alerts
     * const user_alerts = await prisma.user_alerts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_alertsFindUniqueArgs>(args: SelectSubset<T, user_alertsFindUniqueArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_alerts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_alertsFindUniqueOrThrowArgs} args - Arguments to find a User_alerts
     * @example
     * // Get one User_alerts
     * const user_alerts = await prisma.user_alerts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_alertsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_alertsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsFindFirstArgs} args - Arguments to find a User_alerts
     * @example
     * // Get one User_alerts
     * const user_alerts = await prisma.user_alerts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_alertsFindFirstArgs>(args?: SelectSubset<T, user_alertsFindFirstArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_alerts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsFindFirstOrThrowArgs} args - Arguments to find a User_alerts
     * @example
     * // Get one User_alerts
     * const user_alerts = await prisma.user_alerts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_alertsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_alertsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_alerts
     * const user_alerts = await prisma.user_alerts.findMany()
     * 
     * // Get first 10 User_alerts
     * const user_alerts = await prisma.user_alerts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_alertsWithIdOnly = await prisma.user_alerts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_alertsFindManyArgs>(args?: SelectSubset<T, user_alertsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_alerts.
     * @param {user_alertsCreateArgs} args - Arguments to create a User_alerts.
     * @example
     * // Create one User_alerts
     * const User_alerts = await prisma.user_alerts.create({
     *   data: {
     *     // ... data to create a User_alerts
     *   }
     * })
     * 
     */
    create<T extends user_alertsCreateArgs>(args: SelectSubset<T, user_alertsCreateArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_alerts.
     * @param {user_alertsCreateManyArgs} args - Arguments to create many User_alerts.
     * @example
     * // Create many User_alerts
     * const user_alerts = await prisma.user_alerts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_alertsCreateManyArgs>(args?: SelectSubset<T, user_alertsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_alerts and returns the data saved in the database.
     * @param {user_alertsCreateManyAndReturnArgs} args - Arguments to create many User_alerts.
     * @example
     * // Create many User_alerts
     * const user_alerts = await prisma.user_alerts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_alerts and only return the `id`
     * const user_alertsWithIdOnly = await prisma.user_alerts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_alertsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_alertsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_alerts.
     * @param {user_alertsDeleteArgs} args - Arguments to delete one User_alerts.
     * @example
     * // Delete one User_alerts
     * const User_alerts = await prisma.user_alerts.delete({
     *   where: {
     *     // ... filter to delete one User_alerts
     *   }
     * })
     * 
     */
    delete<T extends user_alertsDeleteArgs>(args: SelectSubset<T, user_alertsDeleteArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_alerts.
     * @param {user_alertsUpdateArgs} args - Arguments to update one User_alerts.
     * @example
     * // Update one User_alerts
     * const user_alerts = await prisma.user_alerts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_alertsUpdateArgs>(args: SelectSubset<T, user_alertsUpdateArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_alerts.
     * @param {user_alertsDeleteManyArgs} args - Arguments to filter User_alerts to delete.
     * @example
     * // Delete a few User_alerts
     * const { count } = await prisma.user_alerts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_alertsDeleteManyArgs>(args?: SelectSubset<T, user_alertsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_alerts
     * const user_alerts = await prisma.user_alerts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_alertsUpdateManyArgs>(args: SelectSubset<T, user_alertsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_alerts.
     * @param {user_alertsUpsertArgs} args - Arguments to update or create a User_alerts.
     * @example
     * // Update or create a User_alerts
     * const user_alerts = await prisma.user_alerts.upsert({
     *   create: {
     *     // ... data to create a User_alerts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_alerts we want to update
     *   }
     * })
     */
    upsert<T extends user_alertsUpsertArgs>(args: SelectSubset<T, user_alertsUpsertArgs<ExtArgs>>): Prisma__user_alertsClient<$Result.GetResult<Prisma.$user_alertsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsCountArgs} args - Arguments to filter User_alerts to count.
     * @example
     * // Count the number of User_alerts
     * const count = await prisma.user_alerts.count({
     *   where: {
     *     // ... the filter for the User_alerts we want to count
     *   }
     * })
    **/
    count<T extends user_alertsCountArgs>(
      args?: Subset<T, user_alertsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_alertsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_alertsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_alertsAggregateArgs>(args: Subset<T, User_alertsAggregateArgs>): Prisma.PrismaPromise<GetUser_alertsAggregateType<T>>

    /**
     * Group by User_alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_alertsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_alertsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_alertsGroupByArgs['orderBy'] }
        : { orderBy?: user_alertsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_alertsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_alertsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_alerts model
   */
  readonly fields: user_alertsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_alerts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_alertsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_alerts model
   */ 
  interface user_alertsFieldRefs {
    readonly id: FieldRef<"user_alerts", 'Int'>
    readonly email: FieldRef<"user_alerts", 'String'>
    readonly sources: FieldRef<"user_alerts", 'String'>
    readonly sectors: FieldRef<"user_alerts", 'String'>
    readonly created_at: FieldRef<"user_alerts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_alerts findUnique
   */
  export type user_alertsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter, which user_alerts to fetch.
     */
    where: user_alertsWhereUniqueInput
  }

  /**
   * user_alerts findUniqueOrThrow
   */
  export type user_alertsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter, which user_alerts to fetch.
     */
    where: user_alertsWhereUniqueInput
  }

  /**
   * user_alerts findFirst
   */
  export type user_alertsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter, which user_alerts to fetch.
     */
    where?: user_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_alerts to fetch.
     */
    orderBy?: user_alertsOrderByWithRelationInput | user_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_alerts.
     */
    cursor?: user_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_alerts.
     */
    distinct?: User_alertsScalarFieldEnum | User_alertsScalarFieldEnum[]
  }

  /**
   * user_alerts findFirstOrThrow
   */
  export type user_alertsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter, which user_alerts to fetch.
     */
    where?: user_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_alerts to fetch.
     */
    orderBy?: user_alertsOrderByWithRelationInput | user_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_alerts.
     */
    cursor?: user_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_alerts.
     */
    distinct?: User_alertsScalarFieldEnum | User_alertsScalarFieldEnum[]
  }

  /**
   * user_alerts findMany
   */
  export type user_alertsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter, which user_alerts to fetch.
     */
    where?: user_alertsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_alerts to fetch.
     */
    orderBy?: user_alertsOrderByWithRelationInput | user_alertsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_alerts.
     */
    cursor?: user_alertsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_alerts.
     */
    skip?: number
    distinct?: User_alertsScalarFieldEnum | User_alertsScalarFieldEnum[]
  }

  /**
   * user_alerts create
   */
  export type user_alertsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * The data needed to create a user_alerts.
     */
    data: XOR<user_alertsCreateInput, user_alertsUncheckedCreateInput>
  }

  /**
   * user_alerts createMany
   */
  export type user_alertsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_alerts.
     */
    data: user_alertsCreateManyInput | user_alertsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_alerts createManyAndReturn
   */
  export type user_alertsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_alerts.
     */
    data: user_alertsCreateManyInput | user_alertsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_alerts update
   */
  export type user_alertsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * The data needed to update a user_alerts.
     */
    data: XOR<user_alertsUpdateInput, user_alertsUncheckedUpdateInput>
    /**
     * Choose, which user_alerts to update.
     */
    where: user_alertsWhereUniqueInput
  }

  /**
   * user_alerts updateMany
   */
  export type user_alertsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_alerts.
     */
    data: XOR<user_alertsUpdateManyMutationInput, user_alertsUncheckedUpdateManyInput>
    /**
     * Filter which user_alerts to update
     */
    where?: user_alertsWhereInput
  }

  /**
   * user_alerts upsert
   */
  export type user_alertsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * The filter to search for the user_alerts to update in case it exists.
     */
    where: user_alertsWhereUniqueInput
    /**
     * In case the user_alerts found by the `where` argument doesn't exist, create a new user_alerts with this data.
     */
    create: XOR<user_alertsCreateInput, user_alertsUncheckedCreateInput>
    /**
     * In case the user_alerts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_alertsUpdateInput, user_alertsUncheckedUpdateInput>
  }

  /**
   * user_alerts delete
   */
  export type user_alertsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
    /**
     * Filter which user_alerts to delete.
     */
    where: user_alertsWhereUniqueInput
  }

  /**
   * user_alerts deleteMany
   */
  export type user_alertsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_alerts to delete
     */
    where?: user_alertsWhereInput
  }

  /**
   * user_alerts without action
   */
  export type user_alertsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_alerts
     */
    select?: user_alertsSelect<ExtArgs> | null
  }


  /**
   * Model user_article_stars
   */

  export type AggregateUser_article_stars = {
    _count: User_article_starsCountAggregateOutputType | null
    _avg: User_article_starsAvgAggregateOutputType | null
    _sum: User_article_starsSumAggregateOutputType | null
    _min: User_article_starsMinAggregateOutputType | null
    _max: User_article_starsMaxAggregateOutputType | null
  }

  export type User_article_starsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    article_id: number | null
  }

  export type User_article_starsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    article_id: number | null
  }

  export type User_article_starsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    article_id: number | null
    starred_at: Date | null
  }

  export type User_article_starsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    article_id: number | null
    starred_at: Date | null
  }

  export type User_article_starsCountAggregateOutputType = {
    id: number
    user_id: number
    article_id: number
    starred_at: number
    _all: number
  }


  export type User_article_starsAvgAggregateInputType = {
    id?: true
    user_id?: true
    article_id?: true
  }

  export type User_article_starsSumAggregateInputType = {
    id?: true
    user_id?: true
    article_id?: true
  }

  export type User_article_starsMinAggregateInputType = {
    id?: true
    user_id?: true
    article_id?: true
    starred_at?: true
  }

  export type User_article_starsMaxAggregateInputType = {
    id?: true
    user_id?: true
    article_id?: true
    starred_at?: true
  }

  export type User_article_starsCountAggregateInputType = {
    id?: true
    user_id?: true
    article_id?: true
    starred_at?: true
    _all?: true
  }

  export type User_article_starsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_article_stars to aggregate.
     */
    where?: user_article_starsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_article_stars to fetch.
     */
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_article_starsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_article_stars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_article_stars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_article_stars
    **/
    _count?: true | User_article_starsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_article_starsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_article_starsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_article_starsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_article_starsMaxAggregateInputType
  }

  export type GetUser_article_starsAggregateType<T extends User_article_starsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_article_stars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_article_stars[P]>
      : GetScalarType<T[P], AggregateUser_article_stars[P]>
  }




  export type user_article_starsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_article_starsWhereInput
    orderBy?: user_article_starsOrderByWithAggregationInput | user_article_starsOrderByWithAggregationInput[]
    by: User_article_starsScalarFieldEnum[] | User_article_starsScalarFieldEnum
    having?: user_article_starsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_article_starsCountAggregateInputType | true
    _avg?: User_article_starsAvgAggregateInputType
    _sum?: User_article_starsSumAggregateInputType
    _min?: User_article_starsMinAggregateInputType
    _max?: User_article_starsMaxAggregateInputType
  }

  export type User_article_starsGroupByOutputType = {
    id: number
    user_id: number
    article_id: number
    starred_at: Date
    _count: User_article_starsCountAggregateOutputType | null
    _avg: User_article_starsAvgAggregateOutputType | null
    _sum: User_article_starsSumAggregateOutputType | null
    _min: User_article_starsMinAggregateOutputType | null
    _max: User_article_starsMaxAggregateOutputType | null
  }

  type GetUser_article_starsGroupByPayload<T extends user_article_starsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_article_starsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_article_starsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_article_starsGroupByOutputType[P]>
            : GetScalarType<T[P], User_article_starsGroupByOutputType[P]>
        }
      >
    >


  export type user_article_starsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    article_id?: boolean
    starred_at?: boolean
    credit_articles?: boolean | credit_articlesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_article_stars"]>

  export type user_article_starsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    article_id?: boolean
    starred_at?: boolean
    credit_articles?: boolean | credit_articlesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_article_stars"]>

  export type user_article_starsSelectScalar = {
    id?: boolean
    user_id?: boolean
    article_id?: boolean
    starred_at?: boolean
  }

  export type user_article_starsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_articles?: boolean | credit_articlesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_article_starsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credit_articles?: boolean | credit_articlesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_article_starsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_article_stars"
    objects: {
      credit_articles: Prisma.$credit_articlesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      article_id: number
      starred_at: Date
    }, ExtArgs["result"]["user_article_stars"]>
    composites: {}
  }

  type user_article_starsGetPayload<S extends boolean | null | undefined | user_article_starsDefaultArgs> = $Result.GetResult<Prisma.$user_article_starsPayload, S>

  type user_article_starsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_article_starsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_article_starsCountAggregateInputType | true
    }

  export interface user_article_starsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_article_stars'], meta: { name: 'user_article_stars' } }
    /**
     * Find zero or one User_article_stars that matches the filter.
     * @param {user_article_starsFindUniqueArgs} args - Arguments to find a User_article_stars
     * @example
     * // Get one User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_article_starsFindUniqueArgs>(args: SelectSubset<T, user_article_starsFindUniqueArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_article_stars that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_article_starsFindUniqueOrThrowArgs} args - Arguments to find a User_article_stars
     * @example
     * // Get one User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_article_starsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_article_starsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_article_stars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsFindFirstArgs} args - Arguments to find a User_article_stars
     * @example
     * // Get one User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_article_starsFindFirstArgs>(args?: SelectSubset<T, user_article_starsFindFirstArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_article_stars that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsFindFirstOrThrowArgs} args - Arguments to find a User_article_stars
     * @example
     * // Get one User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_article_starsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_article_starsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_article_stars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findMany()
     * 
     * // Get first 10 User_article_stars
     * const user_article_stars = await prisma.user_article_stars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_article_starsWithIdOnly = await prisma.user_article_stars.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_article_starsFindManyArgs>(args?: SelectSubset<T, user_article_starsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_article_stars.
     * @param {user_article_starsCreateArgs} args - Arguments to create a User_article_stars.
     * @example
     * // Create one User_article_stars
     * const User_article_stars = await prisma.user_article_stars.create({
     *   data: {
     *     // ... data to create a User_article_stars
     *   }
     * })
     * 
     */
    create<T extends user_article_starsCreateArgs>(args: SelectSubset<T, user_article_starsCreateArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_article_stars.
     * @param {user_article_starsCreateManyArgs} args - Arguments to create many User_article_stars.
     * @example
     * // Create many User_article_stars
     * const user_article_stars = await prisma.user_article_stars.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_article_starsCreateManyArgs>(args?: SelectSubset<T, user_article_starsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_article_stars and returns the data saved in the database.
     * @param {user_article_starsCreateManyAndReturnArgs} args - Arguments to create many User_article_stars.
     * @example
     * // Create many User_article_stars
     * const user_article_stars = await prisma.user_article_stars.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_article_stars and only return the `id`
     * const user_article_starsWithIdOnly = await prisma.user_article_stars.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_article_starsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_article_starsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_article_stars.
     * @param {user_article_starsDeleteArgs} args - Arguments to delete one User_article_stars.
     * @example
     * // Delete one User_article_stars
     * const User_article_stars = await prisma.user_article_stars.delete({
     *   where: {
     *     // ... filter to delete one User_article_stars
     *   }
     * })
     * 
     */
    delete<T extends user_article_starsDeleteArgs>(args: SelectSubset<T, user_article_starsDeleteArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_article_stars.
     * @param {user_article_starsUpdateArgs} args - Arguments to update one User_article_stars.
     * @example
     * // Update one User_article_stars
     * const user_article_stars = await prisma.user_article_stars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_article_starsUpdateArgs>(args: SelectSubset<T, user_article_starsUpdateArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_article_stars.
     * @param {user_article_starsDeleteManyArgs} args - Arguments to filter User_article_stars to delete.
     * @example
     * // Delete a few User_article_stars
     * const { count } = await prisma.user_article_stars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_article_starsDeleteManyArgs>(args?: SelectSubset<T, user_article_starsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_article_stars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_article_stars
     * const user_article_stars = await prisma.user_article_stars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_article_starsUpdateManyArgs>(args: SelectSubset<T, user_article_starsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_article_stars.
     * @param {user_article_starsUpsertArgs} args - Arguments to update or create a User_article_stars.
     * @example
     * // Update or create a User_article_stars
     * const user_article_stars = await prisma.user_article_stars.upsert({
     *   create: {
     *     // ... data to create a User_article_stars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_article_stars we want to update
     *   }
     * })
     */
    upsert<T extends user_article_starsUpsertArgs>(args: SelectSubset<T, user_article_starsUpsertArgs<ExtArgs>>): Prisma__user_article_starsClient<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_article_stars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsCountArgs} args - Arguments to filter User_article_stars to count.
     * @example
     * // Count the number of User_article_stars
     * const count = await prisma.user_article_stars.count({
     *   where: {
     *     // ... the filter for the User_article_stars we want to count
     *   }
     * })
    **/
    count<T extends user_article_starsCountArgs>(
      args?: Subset<T, user_article_starsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_article_starsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_article_stars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_article_starsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_article_starsAggregateArgs>(args: Subset<T, User_article_starsAggregateArgs>): Prisma.PrismaPromise<GetUser_article_starsAggregateType<T>>

    /**
     * Group by User_article_stars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_article_starsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_article_starsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_article_starsGroupByArgs['orderBy'] }
        : { orderBy?: user_article_starsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_article_starsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_article_starsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_article_stars model
   */
  readonly fields: user_article_starsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_article_stars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_article_starsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credit_articles<T extends credit_articlesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, credit_articlesDefaultArgs<ExtArgs>>): Prisma__credit_articlesClient<$Result.GetResult<Prisma.$credit_articlesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_article_stars model
   */ 
  interface user_article_starsFieldRefs {
    readonly id: FieldRef<"user_article_stars", 'Int'>
    readonly user_id: FieldRef<"user_article_stars", 'Int'>
    readonly article_id: FieldRef<"user_article_stars", 'Int'>
    readonly starred_at: FieldRef<"user_article_stars", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_article_stars findUnique
   */
  export type user_article_starsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter, which user_article_stars to fetch.
     */
    where: user_article_starsWhereUniqueInput
  }

  /**
   * user_article_stars findUniqueOrThrow
   */
  export type user_article_starsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter, which user_article_stars to fetch.
     */
    where: user_article_starsWhereUniqueInput
  }

  /**
   * user_article_stars findFirst
   */
  export type user_article_starsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter, which user_article_stars to fetch.
     */
    where?: user_article_starsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_article_stars to fetch.
     */
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_article_stars.
     */
    cursor?: user_article_starsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_article_stars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_article_stars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_article_stars.
     */
    distinct?: User_article_starsScalarFieldEnum | User_article_starsScalarFieldEnum[]
  }

  /**
   * user_article_stars findFirstOrThrow
   */
  export type user_article_starsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter, which user_article_stars to fetch.
     */
    where?: user_article_starsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_article_stars to fetch.
     */
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_article_stars.
     */
    cursor?: user_article_starsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_article_stars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_article_stars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_article_stars.
     */
    distinct?: User_article_starsScalarFieldEnum | User_article_starsScalarFieldEnum[]
  }

  /**
   * user_article_stars findMany
   */
  export type user_article_starsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter, which user_article_stars to fetch.
     */
    where?: user_article_starsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_article_stars to fetch.
     */
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_article_stars.
     */
    cursor?: user_article_starsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_article_stars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_article_stars.
     */
    skip?: number
    distinct?: User_article_starsScalarFieldEnum | User_article_starsScalarFieldEnum[]
  }

  /**
   * user_article_stars create
   */
  export type user_article_starsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_article_stars.
     */
    data: XOR<user_article_starsCreateInput, user_article_starsUncheckedCreateInput>
  }

  /**
   * user_article_stars createMany
   */
  export type user_article_starsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_article_stars.
     */
    data: user_article_starsCreateManyInput | user_article_starsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_article_stars createManyAndReturn
   */
  export type user_article_starsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_article_stars.
     */
    data: user_article_starsCreateManyInput | user_article_starsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_article_stars update
   */
  export type user_article_starsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_article_stars.
     */
    data: XOR<user_article_starsUpdateInput, user_article_starsUncheckedUpdateInput>
    /**
     * Choose, which user_article_stars to update.
     */
    where: user_article_starsWhereUniqueInput
  }

  /**
   * user_article_stars updateMany
   */
  export type user_article_starsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_article_stars.
     */
    data: XOR<user_article_starsUpdateManyMutationInput, user_article_starsUncheckedUpdateManyInput>
    /**
     * Filter which user_article_stars to update
     */
    where?: user_article_starsWhereInput
  }

  /**
   * user_article_stars upsert
   */
  export type user_article_starsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_article_stars to update in case it exists.
     */
    where: user_article_starsWhereUniqueInput
    /**
     * In case the user_article_stars found by the `where` argument doesn't exist, create a new user_article_stars with this data.
     */
    create: XOR<user_article_starsCreateInput, user_article_starsUncheckedCreateInput>
    /**
     * In case the user_article_stars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_article_starsUpdateInput, user_article_starsUncheckedUpdateInput>
  }

  /**
   * user_article_stars delete
   */
  export type user_article_starsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    /**
     * Filter which user_article_stars to delete.
     */
    where: user_article_starsWhereUniqueInput
  }

  /**
   * user_article_stars deleteMany
   */
  export type user_article_starsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_article_stars to delete
     */
    where?: user_article_starsWhereInput
  }

  /**
   * user_article_stars without action
   */
  export type user_article_starsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
  }


  /**
   * Model user_events
   */

  export type AggregateUser_events = {
    _count: User_eventsCountAggregateOutputType | null
    _avg: User_eventsAvgAggregateOutputType | null
    _sum: User_eventsSumAggregateOutputType | null
    _min: User_eventsMinAggregateOutputType | null
    _max: User_eventsMaxAggregateOutputType | null
  }

  export type User_eventsAvgAggregateOutputType = {
    id: number | null
    event_id: number | null
  }

  export type User_eventsSumAggregateOutputType = {
    id: number | null
    event_id: number | null
  }

  export type User_eventsMinAggregateOutputType = {
    id: number | null
    user_email: string | null
    event_id: number | null
    event_title: string | null
    event_date: Date | null
    event_link: string | null
    created_at: Date | null
  }

  export type User_eventsMaxAggregateOutputType = {
    id: number | null
    user_email: string | null
    event_id: number | null
    event_title: string | null
    event_date: Date | null
    event_link: string | null
    created_at: Date | null
  }

  export type User_eventsCountAggregateOutputType = {
    id: number
    user_email: number
    event_id: number
    event_title: number
    event_date: number
    event_link: number
    created_at: number
    _all: number
  }


  export type User_eventsAvgAggregateInputType = {
    id?: true
    event_id?: true
  }

  export type User_eventsSumAggregateInputType = {
    id?: true
    event_id?: true
  }

  export type User_eventsMinAggregateInputType = {
    id?: true
    user_email?: true
    event_id?: true
    event_title?: true
    event_date?: true
    event_link?: true
    created_at?: true
  }

  export type User_eventsMaxAggregateInputType = {
    id?: true
    user_email?: true
    event_id?: true
    event_title?: true
    event_date?: true
    event_link?: true
    created_at?: true
  }

  export type User_eventsCountAggregateInputType = {
    id?: true
    user_email?: true
    event_id?: true
    event_title?: true
    event_date?: true
    event_link?: true
    created_at?: true
    _all?: true
  }

  export type User_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_events to aggregate.
     */
    where?: user_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_events to fetch.
     */
    orderBy?: user_eventsOrderByWithRelationInput | user_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_events
    **/
    _count?: true | User_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_eventsMaxAggregateInputType
  }

  export type GetUser_eventsAggregateType<T extends User_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_events[P]>
      : GetScalarType<T[P], AggregateUser_events[P]>
  }




  export type user_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_eventsWhereInput
    orderBy?: user_eventsOrderByWithAggregationInput | user_eventsOrderByWithAggregationInput[]
    by: User_eventsScalarFieldEnum[] | User_eventsScalarFieldEnum
    having?: user_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_eventsCountAggregateInputType | true
    _avg?: User_eventsAvgAggregateInputType
    _sum?: User_eventsSumAggregateInputType
    _min?: User_eventsMinAggregateInputType
    _max?: User_eventsMaxAggregateInputType
  }

  export type User_eventsGroupByOutputType = {
    id: number
    user_email: string
    event_id: number
    event_title: string
    event_date: Date
    event_link: string | null
    created_at: Date | null
    _count: User_eventsCountAggregateOutputType | null
    _avg: User_eventsAvgAggregateOutputType | null
    _sum: User_eventsSumAggregateOutputType | null
    _min: User_eventsMinAggregateOutputType | null
    _max: User_eventsMaxAggregateOutputType | null
  }

  type GetUser_eventsGroupByPayload<T extends user_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], User_eventsGroupByOutputType[P]>
        }
      >
    >


  export type user_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    event_id?: boolean
    event_title?: boolean
    event_date?: boolean
    event_link?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user_events"]>

  export type user_eventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    event_id?: boolean
    event_title?: boolean
    event_date?: boolean
    event_link?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user_events"]>

  export type user_eventsSelectScalar = {
    id?: boolean
    user_email?: boolean
    event_id?: boolean
    event_title?: boolean
    event_date?: boolean
    event_link?: boolean
    created_at?: boolean
  }


  export type $user_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_email: string
      event_id: number
      event_title: string
      event_date: Date
      event_link: string | null
      created_at: Date | null
    }, ExtArgs["result"]["user_events"]>
    composites: {}
  }

  type user_eventsGetPayload<S extends boolean | null | undefined | user_eventsDefaultArgs> = $Result.GetResult<Prisma.$user_eventsPayload, S>

  type user_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_eventsCountAggregateInputType | true
    }

  export interface user_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_events'], meta: { name: 'user_events' } }
    /**
     * Find zero or one User_events that matches the filter.
     * @param {user_eventsFindUniqueArgs} args - Arguments to find a User_events
     * @example
     * // Get one User_events
     * const user_events = await prisma.user_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_eventsFindUniqueArgs>(args: SelectSubset<T, user_eventsFindUniqueArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_eventsFindUniqueOrThrowArgs} args - Arguments to find a User_events
     * @example
     * // Get one User_events
     * const user_events = await prisma.user_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsFindFirstArgs} args - Arguments to find a User_events
     * @example
     * // Get one User_events
     * const user_events = await prisma.user_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_eventsFindFirstArgs>(args?: SelectSubset<T, user_eventsFindFirstArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsFindFirstOrThrowArgs} args - Arguments to find a User_events
     * @example
     * // Get one User_events
     * const user_events = await prisma.user_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_events
     * const user_events = await prisma.user_events.findMany()
     * 
     * // Get first 10 User_events
     * const user_events = await prisma.user_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_eventsWithIdOnly = await prisma.user_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_eventsFindManyArgs>(args?: SelectSubset<T, user_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_events.
     * @param {user_eventsCreateArgs} args - Arguments to create a User_events.
     * @example
     * // Create one User_events
     * const User_events = await prisma.user_events.create({
     *   data: {
     *     // ... data to create a User_events
     *   }
     * })
     * 
     */
    create<T extends user_eventsCreateArgs>(args: SelectSubset<T, user_eventsCreateArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_events.
     * @param {user_eventsCreateManyArgs} args - Arguments to create many User_events.
     * @example
     * // Create many User_events
     * const user_events = await prisma.user_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_eventsCreateManyArgs>(args?: SelectSubset<T, user_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_events and returns the data saved in the database.
     * @param {user_eventsCreateManyAndReturnArgs} args - Arguments to create many User_events.
     * @example
     * // Create many User_events
     * const user_events = await prisma.user_events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_events and only return the `id`
     * const user_eventsWithIdOnly = await prisma.user_events.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_eventsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_eventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_events.
     * @param {user_eventsDeleteArgs} args - Arguments to delete one User_events.
     * @example
     * // Delete one User_events
     * const User_events = await prisma.user_events.delete({
     *   where: {
     *     // ... filter to delete one User_events
     *   }
     * })
     * 
     */
    delete<T extends user_eventsDeleteArgs>(args: SelectSubset<T, user_eventsDeleteArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_events.
     * @param {user_eventsUpdateArgs} args - Arguments to update one User_events.
     * @example
     * // Update one User_events
     * const user_events = await prisma.user_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_eventsUpdateArgs>(args: SelectSubset<T, user_eventsUpdateArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_events.
     * @param {user_eventsDeleteManyArgs} args - Arguments to filter User_events to delete.
     * @example
     * // Delete a few User_events
     * const { count } = await prisma.user_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_eventsDeleteManyArgs>(args?: SelectSubset<T, user_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_events
     * const user_events = await prisma.user_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_eventsUpdateManyArgs>(args: SelectSubset<T, user_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_events.
     * @param {user_eventsUpsertArgs} args - Arguments to update or create a User_events.
     * @example
     * // Update or create a User_events
     * const user_events = await prisma.user_events.upsert({
     *   create: {
     *     // ... data to create a User_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_events we want to update
     *   }
     * })
     */
    upsert<T extends user_eventsUpsertArgs>(args: SelectSubset<T, user_eventsUpsertArgs<ExtArgs>>): Prisma__user_eventsClient<$Result.GetResult<Prisma.$user_eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsCountArgs} args - Arguments to filter User_events to count.
     * @example
     * // Count the number of User_events
     * const count = await prisma.user_events.count({
     *   where: {
     *     // ... the filter for the User_events we want to count
     *   }
     * })
    **/
    count<T extends user_eventsCountArgs>(
      args?: Subset<T, user_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_eventsAggregateArgs>(args: Subset<T, User_eventsAggregateArgs>): Prisma.PrismaPromise<GetUser_eventsAggregateType<T>>

    /**
     * Group by User_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_eventsGroupByArgs['orderBy'] }
        : { orderBy?: user_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_events model
   */
  readonly fields: user_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_events model
   */ 
  interface user_eventsFieldRefs {
    readonly id: FieldRef<"user_events", 'Int'>
    readonly user_email: FieldRef<"user_events", 'String'>
    readonly event_id: FieldRef<"user_events", 'Int'>
    readonly event_title: FieldRef<"user_events", 'String'>
    readonly event_date: FieldRef<"user_events", 'DateTime'>
    readonly event_link: FieldRef<"user_events", 'String'>
    readonly created_at: FieldRef<"user_events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_events findUnique
   */
  export type user_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter, which user_events to fetch.
     */
    where: user_eventsWhereUniqueInput
  }

  /**
   * user_events findUniqueOrThrow
   */
  export type user_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter, which user_events to fetch.
     */
    where: user_eventsWhereUniqueInput
  }

  /**
   * user_events findFirst
   */
  export type user_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter, which user_events to fetch.
     */
    where?: user_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_events to fetch.
     */
    orderBy?: user_eventsOrderByWithRelationInput | user_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_events.
     */
    cursor?: user_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_events.
     */
    distinct?: User_eventsScalarFieldEnum | User_eventsScalarFieldEnum[]
  }

  /**
   * user_events findFirstOrThrow
   */
  export type user_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter, which user_events to fetch.
     */
    where?: user_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_events to fetch.
     */
    orderBy?: user_eventsOrderByWithRelationInput | user_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_events.
     */
    cursor?: user_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_events.
     */
    distinct?: User_eventsScalarFieldEnum | User_eventsScalarFieldEnum[]
  }

  /**
   * user_events findMany
   */
  export type user_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter, which user_events to fetch.
     */
    where?: user_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_events to fetch.
     */
    orderBy?: user_eventsOrderByWithRelationInput | user_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_events.
     */
    cursor?: user_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_events.
     */
    skip?: number
    distinct?: User_eventsScalarFieldEnum | User_eventsScalarFieldEnum[]
  }

  /**
   * user_events create
   */
  export type user_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * The data needed to create a user_events.
     */
    data: XOR<user_eventsCreateInput, user_eventsUncheckedCreateInput>
  }

  /**
   * user_events createMany
   */
  export type user_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_events.
     */
    data: user_eventsCreateManyInput | user_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_events createManyAndReturn
   */
  export type user_eventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_events.
     */
    data: user_eventsCreateManyInput | user_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_events update
   */
  export type user_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * The data needed to update a user_events.
     */
    data: XOR<user_eventsUpdateInput, user_eventsUncheckedUpdateInput>
    /**
     * Choose, which user_events to update.
     */
    where: user_eventsWhereUniqueInput
  }

  /**
   * user_events updateMany
   */
  export type user_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_events.
     */
    data: XOR<user_eventsUpdateManyMutationInput, user_eventsUncheckedUpdateManyInput>
    /**
     * Filter which user_events to update
     */
    where?: user_eventsWhereInput
  }

  /**
   * user_events upsert
   */
  export type user_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * The filter to search for the user_events to update in case it exists.
     */
    where: user_eventsWhereUniqueInput
    /**
     * In case the user_events found by the `where` argument doesn't exist, create a new user_events with this data.
     */
    create: XOR<user_eventsCreateInput, user_eventsUncheckedCreateInput>
    /**
     * In case the user_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_eventsUpdateInput, user_eventsUncheckedUpdateInput>
  }

  /**
   * user_events delete
   */
  export type user_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
    /**
     * Filter which user_events to delete.
     */
    where: user_eventsWhereUniqueInput
  }

  /**
   * user_events deleteMany
   */
  export type user_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_events to delete
     */
    where?: user_eventsWhereInput
  }

  /**
   * user_events without action
   */
  export type user_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_events
     */
    select?: user_eventsSelect<ExtArgs> | null
  }


  /**
   * Model user_permissions
   */

  export type AggregateUser_permissions = {
    _count: User_permissionsCountAggregateOutputType | null
    _avg: User_permissionsAvgAggregateOutputType | null
    _sum: User_permissionsSumAggregateOutputType | null
    _min: User_permissionsMinAggregateOutputType | null
    _max: User_permissionsMaxAggregateOutputType | null
  }

  export type User_permissionsAvgAggregateOutputType = {
    user_id: number | null
    permission_id: number | null
  }

  export type User_permissionsSumAggregateOutputType = {
    user_id: number | null
    permission_id: number | null
  }

  export type User_permissionsMinAggregateOutputType = {
    user_id: number | null
    permission_id: number | null
  }

  export type User_permissionsMaxAggregateOutputType = {
    user_id: number | null
    permission_id: number | null
  }

  export type User_permissionsCountAggregateOutputType = {
    user_id: number
    permission_id: number
    _all: number
  }


  export type User_permissionsAvgAggregateInputType = {
    user_id?: true
    permission_id?: true
  }

  export type User_permissionsSumAggregateInputType = {
    user_id?: true
    permission_id?: true
  }

  export type User_permissionsMinAggregateInputType = {
    user_id?: true
    permission_id?: true
  }

  export type User_permissionsMaxAggregateInputType = {
    user_id?: true
    permission_id?: true
  }

  export type User_permissionsCountAggregateInputType = {
    user_id?: true
    permission_id?: true
    _all?: true
  }

  export type User_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_permissions to aggregate.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_permissions
    **/
    _count?: true | User_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_permissionsMaxAggregateInputType
  }

  export type GetUser_permissionsAggregateType<T extends User_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_permissions[P]>
      : GetScalarType<T[P], AggregateUser_permissions[P]>
  }




  export type user_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_permissionsWhereInput
    orderBy?: user_permissionsOrderByWithAggregationInput | user_permissionsOrderByWithAggregationInput[]
    by: User_permissionsScalarFieldEnum[] | User_permissionsScalarFieldEnum
    having?: user_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_permissionsCountAggregateInputType | true
    _avg?: User_permissionsAvgAggregateInputType
    _sum?: User_permissionsSumAggregateInputType
    _min?: User_permissionsMinAggregateInputType
    _max?: User_permissionsMaxAggregateInputType
  }

  export type User_permissionsGroupByOutputType = {
    user_id: number
    permission_id: number
    _count: User_permissionsCountAggregateOutputType | null
    _avg: User_permissionsAvgAggregateOutputType | null
    _sum: User_permissionsSumAggregateOutputType | null
    _min: User_permissionsMinAggregateOutputType | null
    _max: User_permissionsMaxAggregateOutputType | null
  }

  type GetUser_permissionsGroupByPayload<T extends user_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], User_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type user_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    permission_id?: boolean
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_permissions"]>

  export type user_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    permission_id?: boolean
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_permissions"]>

  export type user_permissionsSelectScalar = {
    user_id?: boolean
    permission_id?: boolean
  }

  export type user_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type user_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $user_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_permissions"
    objects: {
      permission: Prisma.$permissionPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      permission_id: number
    }, ExtArgs["result"]["user_permissions"]>
    composites: {}
  }

  type user_permissionsGetPayload<S extends boolean | null | undefined | user_permissionsDefaultArgs> = $Result.GetResult<Prisma.$user_permissionsPayload, S>

  type user_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_permissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_permissionsCountAggregateInputType | true
    }

  export interface user_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_permissions'], meta: { name: 'user_permissions' } }
    /**
     * Find zero or one User_permissions that matches the filter.
     * @param {user_permissionsFindUniqueArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_permissionsFindUniqueArgs>(args: SelectSubset<T, user_permissionsFindUniqueArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_permissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_permissionsFindUniqueOrThrowArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindFirstArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_permissionsFindFirstArgs>(args?: SelectSubset<T, user_permissionsFindFirstArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindFirstOrThrowArgs} args - Arguments to find a User_permissions
     * @example
     * // Get one User_permissions
     * const user_permissions = await prisma.user_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_permissions
     * const user_permissions = await prisma.user_permissions.findMany()
     * 
     * // Get first 10 User_permissions
     * const user_permissions = await prisma.user_permissions.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_permissionsWithUser_idOnly = await prisma.user_permissions.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_permissionsFindManyArgs>(args?: SelectSubset<T, user_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_permissions.
     * @param {user_permissionsCreateArgs} args - Arguments to create a User_permissions.
     * @example
     * // Create one User_permissions
     * const User_permissions = await prisma.user_permissions.create({
     *   data: {
     *     // ... data to create a User_permissions
     *   }
     * })
     * 
     */
    create<T extends user_permissionsCreateArgs>(args: SelectSubset<T, user_permissionsCreateArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_permissions.
     * @param {user_permissionsCreateManyArgs} args - Arguments to create many User_permissions.
     * @example
     * // Create many User_permissions
     * const user_permissions = await prisma.user_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_permissionsCreateManyArgs>(args?: SelectSubset<T, user_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_permissions and returns the data saved in the database.
     * @param {user_permissionsCreateManyAndReturnArgs} args - Arguments to create many User_permissions.
     * @example
     * // Create many User_permissions
     * const user_permissions = await prisma.user_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_permissions and only return the `user_id`
     * const user_permissionsWithUser_idOnly = await prisma.user_permissions.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_permissions.
     * @param {user_permissionsDeleteArgs} args - Arguments to delete one User_permissions.
     * @example
     * // Delete one User_permissions
     * const User_permissions = await prisma.user_permissions.delete({
     *   where: {
     *     // ... filter to delete one User_permissions
     *   }
     * })
     * 
     */
    delete<T extends user_permissionsDeleteArgs>(args: SelectSubset<T, user_permissionsDeleteArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_permissions.
     * @param {user_permissionsUpdateArgs} args - Arguments to update one User_permissions.
     * @example
     * // Update one User_permissions
     * const user_permissions = await prisma.user_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_permissionsUpdateArgs>(args: SelectSubset<T, user_permissionsUpdateArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_permissions.
     * @param {user_permissionsDeleteManyArgs} args - Arguments to filter User_permissions to delete.
     * @example
     * // Delete a few User_permissions
     * const { count } = await prisma.user_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_permissionsDeleteManyArgs>(args?: SelectSubset<T, user_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_permissions
     * const user_permissions = await prisma.user_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_permissionsUpdateManyArgs>(args: SelectSubset<T, user_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_permissions.
     * @param {user_permissionsUpsertArgs} args - Arguments to update or create a User_permissions.
     * @example
     * // Update or create a User_permissions
     * const user_permissions = await prisma.user_permissions.upsert({
     *   create: {
     *     // ... data to create a User_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_permissions we want to update
     *   }
     * })
     */
    upsert<T extends user_permissionsUpsertArgs>(args: SelectSubset<T, user_permissionsUpsertArgs<ExtArgs>>): Prisma__user_permissionsClient<$Result.GetResult<Prisma.$user_permissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsCountArgs} args - Arguments to filter User_permissions to count.
     * @example
     * // Count the number of User_permissions
     * const count = await prisma.user_permissions.count({
     *   where: {
     *     // ... the filter for the User_permissions we want to count
     *   }
     * })
    **/
    count<T extends user_permissionsCountArgs>(
      args?: Subset<T, user_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_permissionsAggregateArgs>(args: Subset<T, User_permissionsAggregateArgs>): Prisma.PrismaPromise<GetUser_permissionsAggregateType<T>>

    /**
     * Group by User_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: user_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_permissions model
   */
  readonly fields: user_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends permissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionDefaultArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_permissions model
   */ 
  interface user_permissionsFieldRefs {
    readonly user_id: FieldRef<"user_permissions", 'Int'>
    readonly permission_id: FieldRef<"user_permissions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_permissions findUnique
   */
  export type user_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions findUniqueOrThrow
   */
  export type user_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions findFirst
   */
  export type user_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_permissions.
     */
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions findFirstOrThrow
   */
  export type user_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_permissions.
     */
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions findMany
   */
  export type user_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which user_permissions to fetch.
     */
    where?: user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_permissions to fetch.
     */
    orderBy?: user_permissionsOrderByWithRelationInput | user_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_permissions.
     */
    cursor?: user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_permissions.
     */
    skip?: number
    distinct?: User_permissionsScalarFieldEnum | User_permissionsScalarFieldEnum[]
  }

  /**
   * user_permissions create
   */
  export type user_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_permissions.
     */
    data: XOR<user_permissionsCreateInput, user_permissionsUncheckedCreateInput>
  }

  /**
   * user_permissions createMany
   */
  export type user_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_permissions.
     */
    data: user_permissionsCreateManyInput | user_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_permissions createManyAndReturn
   */
  export type user_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_permissions.
     */
    data: user_permissionsCreateManyInput | user_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_permissions update
   */
  export type user_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_permissions.
     */
    data: XOR<user_permissionsUpdateInput, user_permissionsUncheckedUpdateInput>
    /**
     * Choose, which user_permissions to update.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions updateMany
   */
  export type user_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_permissions.
     */
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which user_permissions to update
     */
    where?: user_permissionsWhereInput
  }

  /**
   * user_permissions upsert
   */
  export type user_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_permissions to update in case it exists.
     */
    where: user_permissionsWhereUniqueInput
    /**
     * In case the user_permissions found by the `where` argument doesn't exist, create a new user_permissions with this data.
     */
    create: XOR<user_permissionsCreateInput, user_permissionsUncheckedCreateInput>
    /**
     * In case the user_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_permissionsUpdateInput, user_permissionsUncheckedUpdateInput>
  }

  /**
   * user_permissions delete
   */
  export type user_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
    /**
     * Filter which user_permissions to delete.
     */
    where: user_permissionsWhereUniqueInput
  }

  /**
   * user_permissions deleteMany
   */
  export type user_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_permissions to delete
     */
    where?: user_permissionsWhereInput
  }

  /**
   * user_permissions without action
   */
  export type user_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_permissions
     */
    select?: user_permissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password_hash: number
    role: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    activity_logs?: boolean | users$activity_logsArgs<ExtArgs>
    ai_assistant_config?: boolean | users$ai_assistant_configArgs<ExtArgs>
    ai_conversations?: boolean | users$ai_conversationsArgs<ExtArgs>
    ai_entity_memory?: boolean | users$ai_entity_memoryArgs<ExtArgs>
    ai_session_memory?: boolean | users$ai_session_memoryArgs<ExtArgs>
    newsletter_subscriptions?: boolean | users$newsletter_subscriptionsArgs<ExtArgs>
    user_activity?: boolean | users$user_activityArgs<ExtArgs>
    user_article_stars?: boolean | users$user_article_starsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_logs?: boolean | users$activity_logsArgs<ExtArgs>
    ai_assistant_config?: boolean | users$ai_assistant_configArgs<ExtArgs>
    ai_conversations?: boolean | users$ai_conversationsArgs<ExtArgs>
    ai_entity_memory?: boolean | users$ai_entity_memoryArgs<ExtArgs>
    ai_session_memory?: boolean | users$ai_session_memoryArgs<ExtArgs>
    newsletter_subscriptions?: boolean | users$newsletter_subscriptionsArgs<ExtArgs>
    user_activity?: boolean | users$user_activityArgs<ExtArgs>
    user_article_stars?: boolean | users$user_article_starsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      activity_logs: Prisma.$activity_logsPayload<ExtArgs>[]
      ai_assistant_config: Prisma.$ai_assistant_configPayload<ExtArgs>[]
      ai_conversations: Prisma.$ai_conversationsPayload<ExtArgs>[]
      ai_entity_memory: Prisma.$ai_entity_memoryPayload<ExtArgs>[]
      ai_session_memory: Prisma.$ai_session_memoryPayload<ExtArgs>[]
      newsletter_subscriptions: Prisma.$newsletter_subscriptionsPayload<ExtArgs>[]
      user_activity: Prisma.$user_activityPayload<ExtArgs>[]
      user_article_stars: Prisma.$user_article_starsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password_hash: string
      role: string
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity_logs<T extends users$activity_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$activity_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activity_logsPayload<ExtArgs>, T, "findMany"> | Null>
    ai_assistant_config<T extends users$ai_assistant_configArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_assistant_configArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_assistant_configPayload<ExtArgs>, T, "findMany"> | Null>
    ai_conversations<T extends users$ai_conversationsArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_conversationsPayload<ExtArgs>, T, "findMany"> | Null>
    ai_entity_memory<T extends users$ai_entity_memoryArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_entity_memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_entity_memoryPayload<ExtArgs>, T, "findMany"> | Null>
    ai_session_memory<T extends users$ai_session_memoryArgs<ExtArgs> = {}>(args?: Subset<T, users$ai_session_memoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ai_session_memoryPayload<ExtArgs>, T, "findMany"> | Null>
    newsletter_subscriptions<T extends users$newsletter_subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, users$newsletter_subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsletter_subscriptionsPayload<ExtArgs>, T, "findMany"> | Null>
    user_activity<T extends users$user_activityArgs<ExtArgs> = {}>(args?: Subset<T, users$user_activityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_activityPayload<ExtArgs>, T, "findMany"> | Null>
    user_article_stars<T extends users$user_article_starsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_article_starsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_article_starsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly is_active: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.activity_logs
   */
  export type users$activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity_logs
     */
    select?: activity_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activity_logsInclude<ExtArgs> | null
    where?: activity_logsWhereInput
    orderBy?: activity_logsOrderByWithRelationInput | activity_logsOrderByWithRelationInput[]
    cursor?: activity_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Activity_logsScalarFieldEnum | Activity_logsScalarFieldEnum[]
  }

  /**
   * users.ai_assistant_config
   */
  export type users$ai_assistant_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_assistant_config
     */
    select?: ai_assistant_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_assistant_configInclude<ExtArgs> | null
    where?: ai_assistant_configWhereInput
    orderBy?: ai_assistant_configOrderByWithRelationInput | ai_assistant_configOrderByWithRelationInput[]
    cursor?: ai_assistant_configWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_assistant_configScalarFieldEnum | Ai_assistant_configScalarFieldEnum[]
  }

  /**
   * users.ai_conversations
   */
  export type users$ai_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_conversations
     */
    select?: ai_conversationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_conversationsInclude<ExtArgs> | null
    where?: ai_conversationsWhereInput
    orderBy?: ai_conversationsOrderByWithRelationInput | ai_conversationsOrderByWithRelationInput[]
    cursor?: ai_conversationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_conversationsScalarFieldEnum | Ai_conversationsScalarFieldEnum[]
  }

  /**
   * users.ai_entity_memory
   */
  export type users$ai_entity_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_entity_memory
     */
    select?: ai_entity_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_entity_memoryInclude<ExtArgs> | null
    where?: ai_entity_memoryWhereInput
    orderBy?: ai_entity_memoryOrderByWithRelationInput | ai_entity_memoryOrderByWithRelationInput[]
    cursor?: ai_entity_memoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_entity_memoryScalarFieldEnum | Ai_entity_memoryScalarFieldEnum[]
  }

  /**
   * users.ai_session_memory
   */
  export type users$ai_session_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ai_session_memory
     */
    select?: ai_session_memorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ai_session_memoryInclude<ExtArgs> | null
    where?: ai_session_memoryWhereInput
    orderBy?: ai_session_memoryOrderByWithRelationInput | ai_session_memoryOrderByWithRelationInput[]
    cursor?: ai_session_memoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ai_session_memoryScalarFieldEnum | Ai_session_memoryScalarFieldEnum[]
  }

  /**
   * users.newsletter_subscriptions
   */
  export type users$newsletter_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsletter_subscriptions
     */
    select?: newsletter_subscriptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsletter_subscriptionsInclude<ExtArgs> | null
    where?: newsletter_subscriptionsWhereInput
    orderBy?: newsletter_subscriptionsOrderByWithRelationInput | newsletter_subscriptionsOrderByWithRelationInput[]
    cursor?: newsletter_subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Newsletter_subscriptionsScalarFieldEnum | Newsletter_subscriptionsScalarFieldEnum[]
  }

  /**
   * users.user_activity
   */
  export type users$user_activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_activity
     */
    select?: user_activitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_activityInclude<ExtArgs> | null
    where?: user_activityWhereInput
    orderBy?: user_activityOrderByWithRelationInput | user_activityOrderByWithRelationInput[]
    cursor?: user_activityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_activityScalarFieldEnum | User_activityScalarFieldEnum[]
  }

  /**
   * users.user_article_stars
   */
  export type users$user_article_starsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_article_stars
     */
    select?: user_article_starsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_article_starsInclude<ExtArgs> | null
    where?: user_article_starsWhereInput
    orderBy?: user_article_starsOrderByWithRelationInput | user_article_starsOrderByWithRelationInput[]
    cursor?: user_article_starsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_article_starsScalarFieldEnum | User_article_starsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model usersession
   */

  export type AggregateUsersession = {
    _count: UsersessionCountAggregateOutputType | null
    _avg: UsersessionAvgAggregateOutputType | null
    _sum: UsersessionSumAggregateOutputType | null
    _min: UsersessionMinAggregateOutputType | null
    _max: UsersessionMaxAggregateOutputType | null
  }

  export type UsersessionAvgAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type UsersessionSumAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type UsersessionMinAggregateOutputType = {
    user_id: number | null
    session_id: string | null
    ip_address: string | null
    user_agent: string | null
    last_activity: Date | null
    expires_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersessionMaxAggregateOutputType = {
    user_id: number | null
    session_id: string | null
    ip_address: string | null
    user_agent: string | null
    last_activity: Date | null
    expires_at: Date | null
    id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersessionCountAggregateOutputType = {
    user_id: number
    session_id: number
    ip_address: number
    user_agent: number
    last_activity: number
    expires_at: number
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersessionAvgAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type UsersessionSumAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type UsersessionMinAggregateInputType = {
    user_id?: true
    session_id?: true
    ip_address?: true
    user_agent?: true
    last_activity?: true
    expires_at?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersessionMaxAggregateInputType = {
    user_id?: true
    session_id?: true
    ip_address?: true
    user_agent?: true
    last_activity?: true
    expires_at?: true
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersessionCountAggregateInputType = {
    user_id?: true
    session_id?: true
    ip_address?: true
    user_agent?: true
    last_activity?: true
    expires_at?: true
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersession to aggregate.
     */
    where?: usersessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersessions to fetch.
     */
    orderBy?: usersessionOrderByWithRelationInput | usersessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usersessions
    **/
    _count?: true | UsersessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersessionMaxAggregateInputType
  }

  export type GetUsersessionAggregateType<T extends UsersessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersession[P]>
      : GetScalarType<T[P], AggregateUsersession[P]>
  }




  export type usersessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersessionWhereInput
    orderBy?: usersessionOrderByWithAggregationInput | usersessionOrderByWithAggregationInput[]
    by: UsersessionScalarFieldEnum[] | UsersessionScalarFieldEnum
    having?: usersessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersessionCountAggregateInputType | true
    _avg?: UsersessionAvgAggregateInputType
    _sum?: UsersessionSumAggregateInputType
    _min?: UsersessionMinAggregateInputType
    _max?: UsersessionMaxAggregateInputType
  }

  export type UsersessionGroupByOutputType = {
    user_id: number
    session_id: string
    ip_address: string | null
    user_agent: string | null
    last_activity: Date
    expires_at: Date
    id: number
    created_at: Date
    updated_at: Date
    _count: UsersessionCountAggregateOutputType | null
    _avg: UsersessionAvgAggregateOutputType | null
    _sum: UsersessionSumAggregateOutputType | null
    _min: UsersessionMinAggregateOutputType | null
    _max: UsersessionMaxAggregateOutputType | null
  }

  type GetUsersessionGroupByPayload<T extends usersessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersessionGroupByOutputType[P]>
            : GetScalarType<T[P], UsersessionGroupByOutputType[P]>
        }
      >
    >


  export type usersessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    session_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    last_activity?: boolean
    expires_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersession"]>

  export type usersessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    session_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    last_activity?: boolean
    expires_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersession"]>

  export type usersessionSelectScalar = {
    user_id?: boolean
    session_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    last_activity?: boolean
    expires_at?: boolean
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type usersessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $usersessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usersession"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      session_id: string
      ip_address: string | null
      user_agent: string | null
      last_activity: Date
      expires_at: Date
      id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["usersession"]>
    composites: {}
  }

  type usersessionGetPayload<S extends boolean | null | undefined | usersessionDefaultArgs> = $Result.GetResult<Prisma.$usersessionPayload, S>

  type usersessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersessionCountAggregateInputType | true
    }

  export interface usersessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usersession'], meta: { name: 'usersession' } }
    /**
     * Find zero or one Usersession that matches the filter.
     * @param {usersessionFindUniqueArgs} args - Arguments to find a Usersession
     * @example
     * // Get one Usersession
     * const usersession = await prisma.usersession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersessionFindUniqueArgs>(args: SelectSubset<T, usersessionFindUniqueArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usersession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersessionFindUniqueOrThrowArgs} args - Arguments to find a Usersession
     * @example
     * // Get one Usersession
     * const usersession = await prisma.usersession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersessionFindUniqueOrThrowArgs>(args: SelectSubset<T, usersessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usersession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionFindFirstArgs} args - Arguments to find a Usersession
     * @example
     * // Get one Usersession
     * const usersession = await prisma.usersession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersessionFindFirstArgs>(args?: SelectSubset<T, usersessionFindFirstArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usersession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionFindFirstOrThrowArgs} args - Arguments to find a Usersession
     * @example
     * // Get one Usersession
     * const usersession = await prisma.usersession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersessionFindFirstOrThrowArgs>(args?: SelectSubset<T, usersessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usersessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usersessions
     * const usersessions = await prisma.usersession.findMany()
     * 
     * // Get first 10 Usersessions
     * const usersessions = await prisma.usersession.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersessionWithUser_idOnly = await prisma.usersession.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersessionFindManyArgs>(args?: SelectSubset<T, usersessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usersession.
     * @param {usersessionCreateArgs} args - Arguments to create a Usersession.
     * @example
     * // Create one Usersession
     * const Usersession = await prisma.usersession.create({
     *   data: {
     *     // ... data to create a Usersession
     *   }
     * })
     * 
     */
    create<T extends usersessionCreateArgs>(args: SelectSubset<T, usersessionCreateArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usersessions.
     * @param {usersessionCreateManyArgs} args - Arguments to create many Usersessions.
     * @example
     * // Create many Usersessions
     * const usersession = await prisma.usersession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersessionCreateManyArgs>(args?: SelectSubset<T, usersessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usersessions and returns the data saved in the database.
     * @param {usersessionCreateManyAndReturnArgs} args - Arguments to create many Usersessions.
     * @example
     * // Create many Usersessions
     * const usersession = await prisma.usersession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usersessions and only return the `user_id`
     * const usersessionWithUser_idOnly = await prisma.usersession.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersessionCreateManyAndReturnArgs>(args?: SelectSubset<T, usersessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usersession.
     * @param {usersessionDeleteArgs} args - Arguments to delete one Usersession.
     * @example
     * // Delete one Usersession
     * const Usersession = await prisma.usersession.delete({
     *   where: {
     *     // ... filter to delete one Usersession
     *   }
     * })
     * 
     */
    delete<T extends usersessionDeleteArgs>(args: SelectSubset<T, usersessionDeleteArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usersession.
     * @param {usersessionUpdateArgs} args - Arguments to update one Usersession.
     * @example
     * // Update one Usersession
     * const usersession = await prisma.usersession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersessionUpdateArgs>(args: SelectSubset<T, usersessionUpdateArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usersessions.
     * @param {usersessionDeleteManyArgs} args - Arguments to filter Usersessions to delete.
     * @example
     * // Delete a few Usersessions
     * const { count } = await prisma.usersession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersessionDeleteManyArgs>(args?: SelectSubset<T, usersessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usersessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usersessions
     * const usersession = await prisma.usersession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersessionUpdateManyArgs>(args: SelectSubset<T, usersessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usersession.
     * @param {usersessionUpsertArgs} args - Arguments to update or create a Usersession.
     * @example
     * // Update or create a Usersession
     * const usersession = await prisma.usersession.upsert({
     *   create: {
     *     // ... data to create a Usersession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usersession we want to update
     *   }
     * })
     */
    upsert<T extends usersessionUpsertArgs>(args: SelectSubset<T, usersessionUpsertArgs<ExtArgs>>): Prisma__usersessionClient<$Result.GetResult<Prisma.$usersessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usersessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionCountArgs} args - Arguments to filter Usersessions to count.
     * @example
     * // Count the number of Usersessions
     * const count = await prisma.usersession.count({
     *   where: {
     *     // ... the filter for the Usersessions we want to count
     *   }
     * })
    **/
    count<T extends usersessionCountArgs>(
      args?: Subset<T, usersessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usersession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersessionAggregateArgs>(args: Subset<T, UsersessionAggregateArgs>): Prisma.PrismaPromise<GetUsersessionAggregateType<T>>

    /**
     * Group by Usersession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersessionGroupByArgs['orderBy'] }
        : { orderBy?: usersessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usersession model
   */
  readonly fields: usersessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usersession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usersession model
   */ 
  interface usersessionFieldRefs {
    readonly user_id: FieldRef<"usersession", 'Int'>
    readonly session_id: FieldRef<"usersession", 'String'>
    readonly ip_address: FieldRef<"usersession", 'String'>
    readonly user_agent: FieldRef<"usersession", 'String'>
    readonly last_activity: FieldRef<"usersession", 'DateTime'>
    readonly expires_at: FieldRef<"usersession", 'DateTime'>
    readonly id: FieldRef<"usersession", 'Int'>
    readonly created_at: FieldRef<"usersession", 'DateTime'>
    readonly updated_at: FieldRef<"usersession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usersession findUnique
   */
  export type usersessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter, which usersession to fetch.
     */
    where: usersessionWhereUniqueInput
  }

  /**
   * usersession findUniqueOrThrow
   */
  export type usersessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter, which usersession to fetch.
     */
    where: usersessionWhereUniqueInput
  }

  /**
   * usersession findFirst
   */
  export type usersessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter, which usersession to fetch.
     */
    where?: usersessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersessions to fetch.
     */
    orderBy?: usersessionOrderByWithRelationInput | usersessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersessions.
     */
    cursor?: usersessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersessions.
     */
    distinct?: UsersessionScalarFieldEnum | UsersessionScalarFieldEnum[]
  }

  /**
   * usersession findFirstOrThrow
   */
  export type usersessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter, which usersession to fetch.
     */
    where?: usersessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersessions to fetch.
     */
    orderBy?: usersessionOrderByWithRelationInput | usersessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usersessions.
     */
    cursor?: usersessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usersessions.
     */
    distinct?: UsersessionScalarFieldEnum | UsersessionScalarFieldEnum[]
  }

  /**
   * usersession findMany
   */
  export type usersessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter, which usersessions to fetch.
     */
    where?: usersessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usersessions to fetch.
     */
    orderBy?: usersessionOrderByWithRelationInput | usersessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usersessions.
     */
    cursor?: usersessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usersessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usersessions.
     */
    skip?: number
    distinct?: UsersessionScalarFieldEnum | UsersessionScalarFieldEnum[]
  }

  /**
   * usersession create
   */
  export type usersessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * The data needed to create a usersession.
     */
    data: XOR<usersessionCreateInput, usersessionUncheckedCreateInput>
  }

  /**
   * usersession createMany
   */
  export type usersessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usersessions.
     */
    data: usersessionCreateManyInput | usersessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usersession createManyAndReturn
   */
  export type usersessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many usersessions.
     */
    data: usersessionCreateManyInput | usersessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usersession update
   */
  export type usersessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * The data needed to update a usersession.
     */
    data: XOR<usersessionUpdateInput, usersessionUncheckedUpdateInput>
    /**
     * Choose, which usersession to update.
     */
    where: usersessionWhereUniqueInput
  }

  /**
   * usersession updateMany
   */
  export type usersessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usersessions.
     */
    data: XOR<usersessionUpdateManyMutationInput, usersessionUncheckedUpdateManyInput>
    /**
     * Filter which usersessions to update
     */
    where?: usersessionWhereInput
  }

  /**
   * usersession upsert
   */
  export type usersessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * The filter to search for the usersession to update in case it exists.
     */
    where: usersessionWhereUniqueInput
    /**
     * In case the usersession found by the `where` argument doesn't exist, create a new usersession with this data.
     */
    create: XOR<usersessionCreateInput, usersessionUncheckedCreateInput>
    /**
     * In case the usersession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersessionUpdateInput, usersessionUncheckedUpdateInput>
  }

  /**
   * usersession delete
   */
  export type usersessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
    /**
     * Filter which usersession to delete.
     */
    where: usersessionWhereUniqueInput
  }

  /**
   * usersession deleteMany
   */
  export type usersessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usersessions to delete
     */
    where?: usersessionWhereInput
  }

  /**
   * usersession without action
   */
  export type usersessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usersession
     */
    select?: usersessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Activity_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    action: 'action',
    details: 'details',
    ip_address: 'ip_address',
    timestamp: 'timestamp'
  };

  export type Activity_logsScalarFieldEnum = (typeof Activity_logsScalarFieldEnum)[keyof typeof Activity_logsScalarFieldEnum]


  export const ActivitylogScalarFieldEnum: {
    user_id: 'user_id',
    action: 'action',
    resource: 'resource',
    resource_id: 'resource_id',
    details: 'details',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    status: 'status',
    error: 'error',
    request_id: 'request_id',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivitylogScalarFieldEnum = (typeof ActivitylogScalarFieldEnum)[keyof typeof ActivitylogScalarFieldEnum]


  export const Ai_assistant_configScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    config_key: 'config_key',
    config_value: 'config_value',
    updated_at: 'updated_at'
  };

  export type Ai_assistant_configScalarFieldEnum = (typeof Ai_assistant_configScalarFieldEnum)[keyof typeof Ai_assistant_configScalarFieldEnum]


  export const Ai_conversationsScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    user_id: 'user_id',
    title: 'title',
    summary: 'summary',
    total_messages: 'total_messages',
    tokens_used: 'tokens_used',
    cost_usd: 'cost_usd',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_conversationsScalarFieldEnum = (typeof Ai_conversationsScalarFieldEnum)[keyof typeof Ai_conversationsScalarFieldEnum]


  export const Ai_entity_memoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    entity_type: 'entity_type',
    entity_key: 'entity_key',
    entity_data: 'entity_data',
    confidence_score: 'confidence_score',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_entity_memoryScalarFieldEnum = (typeof Ai_entity_memoryScalarFieldEnum)[keyof typeof Ai_entity_memoryScalarFieldEnum]


  export const Ai_knowledge_baseScalarFieldEnum: {
    id: 'id',
    knowledge_type: 'knowledge_type',
    topic: 'topic',
    title: 'title',
    content: 'content',
    source: 'source',
    confidence_score: 'confidence_score',
    usage_count: 'usage_count',
    last_used: 'last_used',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ai_knowledge_baseScalarFieldEnum = (typeof Ai_knowledge_baseScalarFieldEnum)[keyof typeof Ai_knowledge_baseScalarFieldEnum]


  export const Ai_session_memoryScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    user_id: 'user_id',
    message_index: 'message_index',
    role: 'role',
    content: 'content',
    metadata: 'metadata',
    created_at: 'created_at',
    expires_at: 'expires_at'
  };

  export type Ai_session_memoryScalarFieldEnum = (typeof Ai_session_memoryScalarFieldEnum)[keyof typeof Ai_session_memoryScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    title: 'title',
    slug: 'slug',
    summary: 'summary',
    content: 'content',
    source: 'source',
    source_url: 'source_url',
    published_at: 'published_at',
    category: 'category',
    region: 'region',
    sector: 'sector',
    keywords: 'keywords',
    sentiment_score: 'sentiment_score',
    relevance_score: 'relevance_score',
    author_id: 'author_id',
    author_name: 'author_name',
    is_published: 'is_published',
    is_featured: 'is_featured',
    view_count: 'view_count',
    unique_viewers: 'unique_viewers',
    ai_summary: 'ai_summary',
    ai_summary_provider: 'ai_summary_provider',
    ai_summary_generated_at: 'ai_summary_generated_at',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const Article_tagsScalarFieldEnum: {
    article_id: 'article_id',
    tag_id: 'tag_id'
  };

  export type Article_tagsScalarFieldEnum = (typeof Article_tagsScalarFieldEnum)[keyof typeof Article_tagsScalarFieldEnum]


  export const ArticlestarScalarFieldEnum: {
    user_id: 'user_id',
    article_id: 'article_id',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ArticlestarScalarFieldEnum = (typeof ArticlestarScalarFieldEnum)[keyof typeof ArticlestarScalarFieldEnum]


  export const ArticleviewScalarFieldEnum: {
    article_id: 'article_id',
    user_id: 'user_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    referrer: 'referrer',
    view_duration: 'view_duration',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ArticleviewScalarFieldEnum = (typeof ArticleviewScalarFieldEnum)[keyof typeof ArticleviewScalarFieldEnum]


  export const Credit_articlesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    content: 'content',
    link: 'link',
    source: 'source',
    matched_keywords: 'matched_keywords',
    region: 'region',
    sector: 'sector',
    starred: 'starred',
    starred_at: 'starred_at',
    summary: 'summary',
    url: 'url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Credit_articlesScalarFieldEnum = (typeof Credit_articlesScalarFieldEnum)[keyof typeof Credit_articlesScalarFieldEnum]


  export const Email_alertsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    alert_type: 'alert_type',
    subscription_date: 'subscription_date',
    active: 'active'
  };

  export type Email_alertsScalarFieldEnum = (typeof Email_alertsScalarFieldEnum)[keyof typeof Email_alertsScalarFieldEnum]


  export const EventScalarFieldEnum: {
    title: 'title',
    slug: 'slug',
    description: 'description',
    event_type: 'event_type',
    location: 'location',
    venue: 'venue',
    is_virtual: 'is_virtual',
    virtual_link: 'virtual_link',
    start_date: 'start_date',
    end_date: 'end_date',
    timezone: 'timezone',
    registration_link: 'registration_link',
    registration_deadline: 'registration_deadline',
    max_attendees: 'max_attendees',
    price: 'price',
    currency: 'currency',
    organizer: 'organizer',
    organizer_email: 'organizer_email',
    organizer_phone: 'organizer_phone',
    sponsors: 'sponsors',
    agenda: 'agenda',
    speakers: 'speakers',
    tags: 'tags',
    source: 'source',
    source_url: 'source_url',
    is_published: 'is_published',
    is_featured: 'is_featured',
    is_cancelled: 'is_cancelled',
    cancellation_reason: 'cancellation_reason',
    created_by_id: 'created_by_id',
    view_count: 'view_count',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventregistrationScalarFieldEnum: {
    event_id: 'event_id',
    user_id: 'user_id',
    registered_at: 'registered_at',
    is_confirmed: 'is_confirmed',
    is_cancelled: 'is_cancelled',
    cancelled_at: 'cancelled_at',
    cancellation_reason: 'cancellation_reason',
    attended: 'attended',
    check_in_time: 'check_in_time',
    dietary_requirements: 'dietary_requirements',
    special_requirements: 'special_requirements',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EventregistrationScalarFieldEnum = (typeof EventregistrationScalarFieldEnum)[keyof typeof EventregistrationScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    location: 'location',
    details: 'details',
    link: 'link',
    source: 'source',
    created_at: 'created_at'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const MethodologiesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    published_date: 'published_date',
    abstract: 'abstract',
    description: 'description',
    link: 'link',
    source: 'source',
    permalink: 'permalink',
    created_at: 'created_at',
    report_url: 'report_url'
  };

  export type MethodologiesScalarFieldEnum = (typeof MethodologiesScalarFieldEnum)[keyof typeof MethodologiesScalarFieldEnum]


  export const Newsletter_logsScalarFieldEnum: {
    id: 'id',
    subscription_id: 'subscription_id',
    sent_at: 'sent_at',
    email_to: 'email_to',
    email_subject: 'email_subject',
    articles_count: 'articles_count',
    success: 'success',
    error_message: 'error_message',
    articles_included: 'articles_included',
    email_content_preview: 'email_content_preview'
  };

  export type Newsletter_logsScalarFieldEnum = (typeof Newsletter_logsScalarFieldEnum)[keyof typeof Newsletter_logsScalarFieldEnum]


  export const Newsletter_preferencesScalarFieldEnum: {
    id: 'id',
    subscription_id: 'subscription_id',
    sources: 'sources',
    regions: 'regions',
    sectors: 'sectors',
    include_starred_only: 'include_starred_only',
    frequency: 'frequency',
    day_of_week: 'day_of_week',
    time_of_day: 'time_of_day',
    timezone: 'timezone',
    max_articles_per_email: 'max_articles_per_email',
    include_summary: 'include_summary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Newsletter_preferencesScalarFieldEnum = (typeof Newsletter_preferencesScalarFieldEnum)[keyof typeof Newsletter_preferencesScalarFieldEnum]


  export const Newsletter_subscriptionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    subscription_type: 'subscription_type',
    is_active: 'is_active',
    email: 'email',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Newsletter_subscriptionsScalarFieldEnum = (typeof Newsletter_subscriptionsScalarFieldEnum)[keyof typeof Newsletter_subscriptionsScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    name: 'name',
    description: 'description',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const PublicationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    description: 'description',
    link: 'link',
    image_url: 'image_url',
    source: 'source',
    created_at: 'created_at'
  };

  export type PublicationsScalarFieldEnum = (typeof PublicationsScalarFieldEnum)[keyof typeof PublicationsScalarFieldEnum]


  export const RefreshtokenScalarFieldEnum: {
    token: 'token',
    user_id: 'user_id',
    expires_at: 'expires_at',
    revoked: 'revoked',
    revoked_at: 'revoked_at',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RefreshtokenScalarFieldEnum = (typeof RefreshtokenScalarFieldEnum)[keyof typeof RefreshtokenScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const TagScalarFieldEnum: {
    name: 'name',
    slug: 'slug',
    description: 'description',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const UserScalarFieldEnum: {
    email: 'email',
    username: 'username',
    full_name: 'full_name',
    hashed_password: 'hashed_password',
    is_active: 'is_active',
    is_verified: 'is_verified',
    role: 'role',
    bio: 'bio',
    avatar_url: 'avatar_url',
    phone_number: 'phone_number',
    last_login_at: 'last_login_at',
    last_login_ip: 'last_login_ip',
    failed_login_attempts: 'failed_login_attempts',
    locked_until: 'locked_until',
    two_factor_enabled: 'two_factor_enabled',
    two_factor_secret: 'two_factor_secret',
    email_verified_at: 'email_verified_at',
    email_verification_token: 'email_verification_token',
    password_reset_token: 'password_reset_token',
    password_reset_expires: 'password_reset_expires',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_activityScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    action: 'action',
    resource_type: 'resource_type',
    resource_id: 'resource_id',
    details: 'details',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    timestamp: 'timestamp',
    created_at: 'created_at'
  };

  export type User_activityScalarFieldEnum = (typeof User_activityScalarFieldEnum)[keyof typeof User_activityScalarFieldEnum]


  export const User_alertsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    sources: 'sources',
    sectors: 'sectors',
    created_at: 'created_at'
  };

  export type User_alertsScalarFieldEnum = (typeof User_alertsScalarFieldEnum)[keyof typeof User_alertsScalarFieldEnum]


  export const User_article_starsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    article_id: 'article_id',
    starred_at: 'starred_at'
  };

  export type User_article_starsScalarFieldEnum = (typeof User_article_starsScalarFieldEnum)[keyof typeof User_article_starsScalarFieldEnum]


  export const User_eventsScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    event_id: 'event_id',
    event_title: 'event_title',
    event_date: 'event_date',
    event_link: 'event_link',
    created_at: 'created_at'
  };

  export type User_eventsScalarFieldEnum = (typeof User_eventsScalarFieldEnum)[keyof typeof User_eventsScalarFieldEnum]


  export const User_permissionsScalarFieldEnum: {
    user_id: 'user_id',
    permission_id: 'permission_id'
  };

  export type User_permissionsScalarFieldEnum = (typeof User_permissionsScalarFieldEnum)[keyof typeof User_permissionsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const UsersessionScalarFieldEnum: {
    user_id: 'user_id',
    session_id: 'session_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    last_activity: 'last_activity',
    expires_at: 'expires_at',
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersessionScalarFieldEnum = (typeof UsersessionScalarFieldEnum)[keyof typeof UsersessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'permissiontype'
   */
  export type EnumpermissiontypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'permissiontype'>
    


  /**
   * Reference to a field of type 'permissiontype[]'
   */
  export type ListEnumpermissiontypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'permissiontype[]'>
    


  /**
   * Reference to a field of type 'userrole'
   */
  export type EnumuserroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userrole'>
    


  /**
   * Reference to a field of type 'userrole[]'
   */
  export type ListEnumuserroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userrole[]'>
    
  /**
   * Deep Input Types
   */


  export type activity_logsWhereInput = {
    AND?: activity_logsWhereInput | activity_logsWhereInput[]
    OR?: activity_logsWhereInput[]
    NOT?: activity_logsWhereInput | activity_logsWhereInput[]
    id?: IntFilter<"activity_logs"> | number
    user_id?: IntNullableFilter<"activity_logs"> | number | null
    action?: StringFilter<"activity_logs"> | string
    details?: StringNullableFilter<"activity_logs"> | string | null
    ip_address?: StringNullableFilter<"activity_logs"> | string | null
    timestamp?: DateTimeNullableFilter<"activity_logs"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type activity_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type activity_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: activity_logsWhereInput | activity_logsWhereInput[]
    OR?: activity_logsWhereInput[]
    NOT?: activity_logsWhereInput | activity_logsWhereInput[]
    user_id?: IntNullableFilter<"activity_logs"> | number | null
    action?: StringFilter<"activity_logs"> | string
    details?: StringNullableFilter<"activity_logs"> | string | null
    ip_address?: StringNullableFilter<"activity_logs"> | string | null
    timestamp?: DateTimeNullableFilter<"activity_logs"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type activity_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: activity_logsCountOrderByAggregateInput
    _avg?: activity_logsAvgOrderByAggregateInput
    _max?: activity_logsMaxOrderByAggregateInput
    _min?: activity_logsMinOrderByAggregateInput
    _sum?: activity_logsSumOrderByAggregateInput
  }

  export type activity_logsScalarWhereWithAggregatesInput = {
    AND?: activity_logsScalarWhereWithAggregatesInput | activity_logsScalarWhereWithAggregatesInput[]
    OR?: activity_logsScalarWhereWithAggregatesInput[]
    NOT?: activity_logsScalarWhereWithAggregatesInput | activity_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"activity_logs"> | number
    user_id?: IntNullableWithAggregatesFilter<"activity_logs"> | number | null
    action?: StringWithAggregatesFilter<"activity_logs"> | string
    details?: StringNullableWithAggregatesFilter<"activity_logs"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"activity_logs"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"activity_logs"> | Date | string | null
  }

  export type activitylogWhereInput = {
    AND?: activitylogWhereInput | activitylogWhereInput[]
    OR?: activitylogWhereInput[]
    NOT?: activitylogWhereInput | activitylogWhereInput[]
    user_id?: IntNullableFilter<"activitylog"> | number | null
    action?: StringFilter<"activitylog"> | string
    resource?: StringNullableFilter<"activitylog"> | string | null
    resource_id?: StringNullableFilter<"activitylog"> | string | null
    details?: StringNullableFilter<"activitylog"> | string | null
    ip_address?: StringNullableFilter<"activitylog"> | string | null
    user_agent?: StringNullableFilter<"activitylog"> | string | null
    status?: StringFilter<"activitylog"> | string
    error?: StringNullableFilter<"activitylog"> | string | null
    request_id?: StringNullableFilter<"activitylog"> | string | null
    id?: IntFilter<"activitylog"> | number
    created_at?: DateTimeFilter<"activitylog"> | Date | string
    updated_at?: DateTimeFilter<"activitylog"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type activitylogOrderByWithRelationInput = {
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type activitylogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: activitylogWhereInput | activitylogWhereInput[]
    OR?: activitylogWhereInput[]
    NOT?: activitylogWhereInput | activitylogWhereInput[]
    user_id?: IntNullableFilter<"activitylog"> | number | null
    action?: StringFilter<"activitylog"> | string
    resource?: StringNullableFilter<"activitylog"> | string | null
    resource_id?: StringNullableFilter<"activitylog"> | string | null
    details?: StringNullableFilter<"activitylog"> | string | null
    ip_address?: StringNullableFilter<"activitylog"> | string | null
    user_agent?: StringNullableFilter<"activitylog"> | string | null
    status?: StringFilter<"activitylog"> | string
    error?: StringNullableFilter<"activitylog"> | string | null
    request_id?: StringNullableFilter<"activitylog"> | string | null
    created_at?: DateTimeFilter<"activitylog"> | Date | string
    updated_at?: DateTimeFilter<"activitylog"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type activitylogOrderByWithAggregationInput = {
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: activitylogCountOrderByAggregateInput
    _avg?: activitylogAvgOrderByAggregateInput
    _max?: activitylogMaxOrderByAggregateInput
    _min?: activitylogMinOrderByAggregateInput
    _sum?: activitylogSumOrderByAggregateInput
  }

  export type activitylogScalarWhereWithAggregatesInput = {
    AND?: activitylogScalarWhereWithAggregatesInput | activitylogScalarWhereWithAggregatesInput[]
    OR?: activitylogScalarWhereWithAggregatesInput[]
    NOT?: activitylogScalarWhereWithAggregatesInput | activitylogScalarWhereWithAggregatesInput[]
    user_id?: IntNullableWithAggregatesFilter<"activitylog"> | number | null
    action?: StringWithAggregatesFilter<"activitylog"> | string
    resource?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    resource_id?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    details?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    status?: StringWithAggregatesFilter<"activitylog"> | string
    error?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    request_id?: StringNullableWithAggregatesFilter<"activitylog"> | string | null
    id?: IntWithAggregatesFilter<"activitylog"> | number
    created_at?: DateTimeWithAggregatesFilter<"activitylog"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"activitylog"> | Date | string
  }

  export type ai_assistant_configWhereInput = {
    AND?: ai_assistant_configWhereInput | ai_assistant_configWhereInput[]
    OR?: ai_assistant_configWhereInput[]
    NOT?: ai_assistant_configWhereInput | ai_assistant_configWhereInput[]
    id?: IntFilter<"ai_assistant_config"> | number
    user_id?: IntNullableFilter<"ai_assistant_config"> | number | null
    config_key?: StringFilter<"ai_assistant_config"> | string
    config_value?: StringFilter<"ai_assistant_config"> | string
    updated_at?: DateTimeNullableFilter<"ai_assistant_config"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type ai_assistant_configOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    config_key?: SortOrder
    config_value?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ai_assistant_configWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_config_key?: ai_assistant_configUser_idConfig_keyCompoundUniqueInput
    AND?: ai_assistant_configWhereInput | ai_assistant_configWhereInput[]
    OR?: ai_assistant_configWhereInput[]
    NOT?: ai_assistant_configWhereInput | ai_assistant_configWhereInput[]
    user_id?: IntNullableFilter<"ai_assistant_config"> | number | null
    config_key?: StringFilter<"ai_assistant_config"> | string
    config_value?: StringFilter<"ai_assistant_config"> | string
    updated_at?: DateTimeNullableFilter<"ai_assistant_config"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id" | "user_id_config_key">

  export type ai_assistant_configOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    config_key?: SortOrder
    config_value?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ai_assistant_configCountOrderByAggregateInput
    _avg?: ai_assistant_configAvgOrderByAggregateInput
    _max?: ai_assistant_configMaxOrderByAggregateInput
    _min?: ai_assistant_configMinOrderByAggregateInput
    _sum?: ai_assistant_configSumOrderByAggregateInput
  }

  export type ai_assistant_configScalarWhereWithAggregatesInput = {
    AND?: ai_assistant_configScalarWhereWithAggregatesInput | ai_assistant_configScalarWhereWithAggregatesInput[]
    OR?: ai_assistant_configScalarWhereWithAggregatesInput[]
    NOT?: ai_assistant_configScalarWhereWithAggregatesInput | ai_assistant_configScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_assistant_config"> | number
    user_id?: IntNullableWithAggregatesFilter<"ai_assistant_config"> | number | null
    config_key?: StringWithAggregatesFilter<"ai_assistant_config"> | string
    config_value?: StringWithAggregatesFilter<"ai_assistant_config"> | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"ai_assistant_config"> | Date | string | null
  }

  export type ai_conversationsWhereInput = {
    AND?: ai_conversationsWhereInput | ai_conversationsWhereInput[]
    OR?: ai_conversationsWhereInput[]
    NOT?: ai_conversationsWhereInput | ai_conversationsWhereInput[]
    id?: IntFilter<"ai_conversations"> | number
    session_id?: StringFilter<"ai_conversations"> | string
    user_id?: IntNullableFilter<"ai_conversations"> | number | null
    title?: StringNullableFilter<"ai_conversations"> | string | null
    summary?: StringNullableFilter<"ai_conversations"> | string | null
    total_messages?: IntNullableFilter<"ai_conversations"> | number | null
    tokens_used?: IntNullableFilter<"ai_conversations"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_conversations"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"ai_conversations"> | string | null
    created_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type ai_conversationsOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    total_messages?: SortOrderInput | SortOrder
    tokens_used?: SortOrderInput | SortOrder
    cost_usd?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ai_conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_conversationsWhereInput | ai_conversationsWhereInput[]
    OR?: ai_conversationsWhereInput[]
    NOT?: ai_conversationsWhereInput | ai_conversationsWhereInput[]
    session_id?: StringFilter<"ai_conversations"> | string
    user_id?: IntNullableFilter<"ai_conversations"> | number | null
    title?: StringNullableFilter<"ai_conversations"> | string | null
    summary?: StringNullableFilter<"ai_conversations"> | string | null
    total_messages?: IntNullableFilter<"ai_conversations"> | number | null
    tokens_used?: IntNullableFilter<"ai_conversations"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_conversations"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"ai_conversations"> | string | null
    created_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type ai_conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    total_messages?: SortOrderInput | SortOrder
    tokens_used?: SortOrderInput | SortOrder
    cost_usd?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ai_conversationsCountOrderByAggregateInput
    _avg?: ai_conversationsAvgOrderByAggregateInput
    _max?: ai_conversationsMaxOrderByAggregateInput
    _min?: ai_conversationsMinOrderByAggregateInput
    _sum?: ai_conversationsSumOrderByAggregateInput
  }

  export type ai_conversationsScalarWhereWithAggregatesInput = {
    AND?: ai_conversationsScalarWhereWithAggregatesInput | ai_conversationsScalarWhereWithAggregatesInput[]
    OR?: ai_conversationsScalarWhereWithAggregatesInput[]
    NOT?: ai_conversationsScalarWhereWithAggregatesInput | ai_conversationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_conversations"> | number
    session_id?: StringWithAggregatesFilter<"ai_conversations"> | string
    user_id?: IntNullableWithAggregatesFilter<"ai_conversations"> | number | null
    title?: StringNullableWithAggregatesFilter<"ai_conversations"> | string | null
    summary?: StringNullableWithAggregatesFilter<"ai_conversations"> | string | null
    total_messages?: IntNullableWithAggregatesFilter<"ai_conversations"> | number | null
    tokens_used?: IntNullableWithAggregatesFilter<"ai_conversations"> | number | null
    cost_usd?: DecimalNullableWithAggregatesFilter<"ai_conversations"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter<"ai_conversations"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ai_conversations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ai_conversations"> | Date | string | null
  }

  export type ai_entity_memoryWhereInput = {
    AND?: ai_entity_memoryWhereInput | ai_entity_memoryWhereInput[]
    OR?: ai_entity_memoryWhereInput[]
    NOT?: ai_entity_memoryWhereInput | ai_entity_memoryWhereInput[]
    id?: IntFilter<"ai_entity_memory"> | number
    user_id?: IntNullableFilter<"ai_entity_memory"> | number | null
    entity_type?: StringFilter<"ai_entity_memory"> | string
    entity_key?: StringFilter<"ai_entity_memory"> | string
    entity_data?: JsonFilter<"ai_entity_memory">
    confidence_score?: DecimalNullableFilter<"ai_entity_memory"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type ai_entity_memoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    entity_key?: SortOrder
    entity_data?: SortOrder
    confidence_score?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ai_entity_memoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_entity_type_entity_key?: ai_entity_memoryUser_idEntity_typeEntity_keyCompoundUniqueInput
    AND?: ai_entity_memoryWhereInput | ai_entity_memoryWhereInput[]
    OR?: ai_entity_memoryWhereInput[]
    NOT?: ai_entity_memoryWhereInput | ai_entity_memoryWhereInput[]
    user_id?: IntNullableFilter<"ai_entity_memory"> | number | null
    entity_type?: StringFilter<"ai_entity_memory"> | string
    entity_key?: StringFilter<"ai_entity_memory"> | string
    entity_data?: JsonFilter<"ai_entity_memory">
    confidence_score?: DecimalNullableFilter<"ai_entity_memory"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id" | "user_id_entity_type_entity_key">

  export type ai_entity_memoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    entity_key?: SortOrder
    entity_data?: SortOrder
    confidence_score?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ai_entity_memoryCountOrderByAggregateInput
    _avg?: ai_entity_memoryAvgOrderByAggregateInput
    _max?: ai_entity_memoryMaxOrderByAggregateInput
    _min?: ai_entity_memoryMinOrderByAggregateInput
    _sum?: ai_entity_memorySumOrderByAggregateInput
  }

  export type ai_entity_memoryScalarWhereWithAggregatesInput = {
    AND?: ai_entity_memoryScalarWhereWithAggregatesInput | ai_entity_memoryScalarWhereWithAggregatesInput[]
    OR?: ai_entity_memoryScalarWhereWithAggregatesInput[]
    NOT?: ai_entity_memoryScalarWhereWithAggregatesInput | ai_entity_memoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_entity_memory"> | number
    user_id?: IntNullableWithAggregatesFilter<"ai_entity_memory"> | number | null
    entity_type?: StringWithAggregatesFilter<"ai_entity_memory"> | string
    entity_key?: StringWithAggregatesFilter<"ai_entity_memory"> | string
    entity_data?: JsonWithAggregatesFilter<"ai_entity_memory">
    confidence_score?: DecimalNullableWithAggregatesFilter<"ai_entity_memory"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ai_entity_memory"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ai_entity_memory"> | Date | string | null
  }

  export type ai_knowledge_baseWhereInput = {
    AND?: ai_knowledge_baseWhereInput | ai_knowledge_baseWhereInput[]
    OR?: ai_knowledge_baseWhereInput[]
    NOT?: ai_knowledge_baseWhereInput | ai_knowledge_baseWhereInput[]
    id?: IntFilter<"ai_knowledge_base"> | number
    knowledge_type?: StringFilter<"ai_knowledge_base"> | string
    topic?: StringFilter<"ai_knowledge_base"> | string
    title?: StringFilter<"ai_knowledge_base"> | string
    content?: StringFilter<"ai_knowledge_base"> | string
    source?: StringNullableFilter<"ai_knowledge_base"> | string | null
    confidence_score?: DecimalNullableFilter<"ai_knowledge_base"> | Decimal | DecimalJsLike | number | string | null
    usage_count?: IntNullableFilter<"ai_knowledge_base"> | number | null
    last_used?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
  }

  export type ai_knowledge_baseOrderByWithRelationInput = {
    id?: SortOrder
    knowledge_type?: SortOrder
    topic?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    usage_count?: SortOrderInput | SortOrder
    last_used?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type ai_knowledge_baseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_knowledge_baseWhereInput | ai_knowledge_baseWhereInput[]
    OR?: ai_knowledge_baseWhereInput[]
    NOT?: ai_knowledge_baseWhereInput | ai_knowledge_baseWhereInput[]
    knowledge_type?: StringFilter<"ai_knowledge_base"> | string
    topic?: StringFilter<"ai_knowledge_base"> | string
    title?: StringFilter<"ai_knowledge_base"> | string
    content?: StringFilter<"ai_knowledge_base"> | string
    source?: StringNullableFilter<"ai_knowledge_base"> | string | null
    confidence_score?: DecimalNullableFilter<"ai_knowledge_base"> | Decimal | DecimalJsLike | number | string | null
    usage_count?: IntNullableFilter<"ai_knowledge_base"> | number | null
    last_used?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_knowledge_base"> | Date | string | null
  }, "id">

  export type ai_knowledge_baseOrderByWithAggregationInput = {
    id?: SortOrder
    knowledge_type?: SortOrder
    topic?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    usage_count?: SortOrderInput | SortOrder
    last_used?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ai_knowledge_baseCountOrderByAggregateInput
    _avg?: ai_knowledge_baseAvgOrderByAggregateInput
    _max?: ai_knowledge_baseMaxOrderByAggregateInput
    _min?: ai_knowledge_baseMinOrderByAggregateInput
    _sum?: ai_knowledge_baseSumOrderByAggregateInput
  }

  export type ai_knowledge_baseScalarWhereWithAggregatesInput = {
    AND?: ai_knowledge_baseScalarWhereWithAggregatesInput | ai_knowledge_baseScalarWhereWithAggregatesInput[]
    OR?: ai_knowledge_baseScalarWhereWithAggregatesInput[]
    NOT?: ai_knowledge_baseScalarWhereWithAggregatesInput | ai_knowledge_baseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_knowledge_base"> | number
    knowledge_type?: StringWithAggregatesFilter<"ai_knowledge_base"> | string
    topic?: StringWithAggregatesFilter<"ai_knowledge_base"> | string
    title?: StringWithAggregatesFilter<"ai_knowledge_base"> | string
    content?: StringWithAggregatesFilter<"ai_knowledge_base"> | string
    source?: StringNullableWithAggregatesFilter<"ai_knowledge_base"> | string | null
    confidence_score?: DecimalNullableWithAggregatesFilter<"ai_knowledge_base"> | Decimal | DecimalJsLike | number | string | null
    usage_count?: IntNullableWithAggregatesFilter<"ai_knowledge_base"> | number | null
    last_used?: DateTimeNullableWithAggregatesFilter<"ai_knowledge_base"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ai_knowledge_base"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ai_knowledge_base"> | Date | string | null
  }

  export type ai_session_memoryWhereInput = {
    AND?: ai_session_memoryWhereInput | ai_session_memoryWhereInput[]
    OR?: ai_session_memoryWhereInput[]
    NOT?: ai_session_memoryWhereInput | ai_session_memoryWhereInput[]
    id?: IntFilter<"ai_session_memory"> | number
    session_id?: StringFilter<"ai_session_memory"> | string
    user_id?: IntNullableFilter<"ai_session_memory"> | number | null
    message_index?: IntFilter<"ai_session_memory"> | number
    role?: StringFilter<"ai_session_memory"> | string
    content?: StringFilter<"ai_session_memory"> | string
    metadata?: JsonNullableFilter<"ai_session_memory">
    created_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type ai_session_memoryOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    message_index?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ai_session_memoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ai_session_memoryWhereInput | ai_session_memoryWhereInput[]
    OR?: ai_session_memoryWhereInput[]
    NOT?: ai_session_memoryWhereInput | ai_session_memoryWhereInput[]
    session_id?: StringFilter<"ai_session_memory"> | string
    user_id?: IntNullableFilter<"ai_session_memory"> | number | null
    message_index?: IntFilter<"ai_session_memory"> | number
    role?: StringFilter<"ai_session_memory"> | string
    content?: StringFilter<"ai_session_memory"> | string
    metadata?: JsonNullableFilter<"ai_session_memory">
    created_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type ai_session_memoryOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    message_index?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    _count?: ai_session_memoryCountOrderByAggregateInput
    _avg?: ai_session_memoryAvgOrderByAggregateInput
    _max?: ai_session_memoryMaxOrderByAggregateInput
    _min?: ai_session_memoryMinOrderByAggregateInput
    _sum?: ai_session_memorySumOrderByAggregateInput
  }

  export type ai_session_memoryScalarWhereWithAggregatesInput = {
    AND?: ai_session_memoryScalarWhereWithAggregatesInput | ai_session_memoryScalarWhereWithAggregatesInput[]
    OR?: ai_session_memoryScalarWhereWithAggregatesInput[]
    NOT?: ai_session_memoryScalarWhereWithAggregatesInput | ai_session_memoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ai_session_memory"> | number
    session_id?: StringWithAggregatesFilter<"ai_session_memory"> | string
    user_id?: IntNullableWithAggregatesFilter<"ai_session_memory"> | number | null
    message_index?: IntWithAggregatesFilter<"ai_session_memory"> | number
    role?: StringWithAggregatesFilter<"ai_session_memory"> | string
    content?: StringWithAggregatesFilter<"ai_session_memory"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ai_session_memory">
    created_at?: DateTimeNullableWithAggregatesFilter<"ai_session_memory"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"ai_session_memory"> | Date | string | null
  }

  export type articleWhereInput = {
    AND?: articleWhereInput | articleWhereInput[]
    OR?: articleWhereInput[]
    NOT?: articleWhereInput | articleWhereInput[]
    title?: StringFilter<"article"> | string
    slug?: StringFilter<"article"> | string
    summary?: StringNullableFilter<"article"> | string | null
    content?: StringNullableFilter<"article"> | string | null
    source?: StringNullableFilter<"article"> | string | null
    source_url?: StringNullableFilter<"article"> | string | null
    published_at?: DateTimeNullableFilter<"article"> | Date | string | null
    category?: StringNullableFilter<"article"> | string | null
    region?: StringNullableFilter<"article"> | string | null
    sector?: StringNullableFilter<"article"> | string | null
    keywords?: JsonNullableFilter<"article">
    sentiment_score?: FloatNullableFilter<"article"> | number | null
    relevance_score?: FloatNullableFilter<"article"> | number | null
    author_id?: IntNullableFilter<"article"> | number | null
    author_name?: StringNullableFilter<"article"> | string | null
    is_published?: BoolFilter<"article"> | boolean
    is_featured?: BoolFilter<"article"> | boolean
    view_count?: IntFilter<"article"> | number
    unique_viewers?: IntFilter<"article"> | number
    ai_summary?: StringNullableFilter<"article"> | string | null
    ai_summary_provider?: StringNullableFilter<"article"> | string | null
    ai_summary_generated_at?: DateTimeNullableFilter<"article"> | Date | string | null
    id?: IntFilter<"article"> | number
    created_at?: DateTimeFilter<"article"> | Date | string
    updated_at?: DateTimeFilter<"article"> | Date | string
    is_deleted?: BoolFilter<"article"> | boolean
    deleted_at?: DateTimeNullableFilter<"article"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    article_tags?: Article_tagsListRelationFilter
    articlestar?: ArticlestarListRelationFilter
    articleview?: ArticleviewListRelationFilter
  }

  export type articleOrderByWithRelationInput = {
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    source_url?: SortOrderInput | SortOrder
    published_at?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    sentiment_score?: SortOrderInput | SortOrder
    relevance_score?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    ai_summary?: SortOrderInput | SortOrder
    ai_summary_provider?: SortOrderInput | SortOrder
    ai_summary_generated_at?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    article_tags?: article_tagsOrderByRelationAggregateInput
    articlestar?: articlestarOrderByRelationAggregateInput
    articleview?: articleviewOrderByRelationAggregateInput
  }

  export type articleWhereUniqueInput = Prisma.AtLeast<{
    slug?: string
    id?: number
    AND?: articleWhereInput | articleWhereInput[]
    OR?: articleWhereInput[]
    NOT?: articleWhereInput | articleWhereInput[]
    title?: StringFilter<"article"> | string
    summary?: StringNullableFilter<"article"> | string | null
    content?: StringNullableFilter<"article"> | string | null
    source?: StringNullableFilter<"article"> | string | null
    source_url?: StringNullableFilter<"article"> | string | null
    published_at?: DateTimeNullableFilter<"article"> | Date | string | null
    category?: StringNullableFilter<"article"> | string | null
    region?: StringNullableFilter<"article"> | string | null
    sector?: StringNullableFilter<"article"> | string | null
    keywords?: JsonNullableFilter<"article">
    sentiment_score?: FloatNullableFilter<"article"> | number | null
    relevance_score?: FloatNullableFilter<"article"> | number | null
    author_id?: IntNullableFilter<"article"> | number | null
    author_name?: StringNullableFilter<"article"> | string | null
    is_published?: BoolFilter<"article"> | boolean
    is_featured?: BoolFilter<"article"> | boolean
    view_count?: IntFilter<"article"> | number
    unique_viewers?: IntFilter<"article"> | number
    ai_summary?: StringNullableFilter<"article"> | string | null
    ai_summary_provider?: StringNullableFilter<"article"> | string | null
    ai_summary_generated_at?: DateTimeNullableFilter<"article"> | Date | string | null
    created_at?: DateTimeFilter<"article"> | Date | string
    updated_at?: DateTimeFilter<"article"> | Date | string
    is_deleted?: BoolFilter<"article"> | boolean
    deleted_at?: DateTimeNullableFilter<"article"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    article_tags?: Article_tagsListRelationFilter
    articlestar?: ArticlestarListRelationFilter
    articleview?: ArticleviewListRelationFilter
  }, "id" | "slug">

  export type articleOrderByWithAggregationInput = {
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    source_url?: SortOrderInput | SortOrder
    published_at?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    sentiment_score?: SortOrderInput | SortOrder
    relevance_score?: SortOrderInput | SortOrder
    author_id?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    ai_summary?: SortOrderInput | SortOrder
    ai_summary_provider?: SortOrderInput | SortOrder
    ai_summary_generated_at?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: articleCountOrderByAggregateInput
    _avg?: articleAvgOrderByAggregateInput
    _max?: articleMaxOrderByAggregateInput
    _min?: articleMinOrderByAggregateInput
    _sum?: articleSumOrderByAggregateInput
  }

  export type articleScalarWhereWithAggregatesInput = {
    AND?: articleScalarWhereWithAggregatesInput | articleScalarWhereWithAggregatesInput[]
    OR?: articleScalarWhereWithAggregatesInput[]
    NOT?: articleScalarWhereWithAggregatesInput | articleScalarWhereWithAggregatesInput[]
    title?: StringWithAggregatesFilter<"article"> | string
    slug?: StringWithAggregatesFilter<"article"> | string
    summary?: StringNullableWithAggregatesFilter<"article"> | string | null
    content?: StringNullableWithAggregatesFilter<"article"> | string | null
    source?: StringNullableWithAggregatesFilter<"article"> | string | null
    source_url?: StringNullableWithAggregatesFilter<"article"> | string | null
    published_at?: DateTimeNullableWithAggregatesFilter<"article"> | Date | string | null
    category?: StringNullableWithAggregatesFilter<"article"> | string | null
    region?: StringNullableWithAggregatesFilter<"article"> | string | null
    sector?: StringNullableWithAggregatesFilter<"article"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"article">
    sentiment_score?: FloatNullableWithAggregatesFilter<"article"> | number | null
    relevance_score?: FloatNullableWithAggregatesFilter<"article"> | number | null
    author_id?: IntNullableWithAggregatesFilter<"article"> | number | null
    author_name?: StringNullableWithAggregatesFilter<"article"> | string | null
    is_published?: BoolWithAggregatesFilter<"article"> | boolean
    is_featured?: BoolWithAggregatesFilter<"article"> | boolean
    view_count?: IntWithAggregatesFilter<"article"> | number
    unique_viewers?: IntWithAggregatesFilter<"article"> | number
    ai_summary?: StringNullableWithAggregatesFilter<"article"> | string | null
    ai_summary_provider?: StringNullableWithAggregatesFilter<"article"> | string | null
    ai_summary_generated_at?: DateTimeNullableWithAggregatesFilter<"article"> | Date | string | null
    id?: IntWithAggregatesFilter<"article"> | number
    created_at?: DateTimeWithAggregatesFilter<"article"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"article"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"article"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"article"> | Date | string | null
  }

  export type article_tagsWhereInput = {
    AND?: article_tagsWhereInput | article_tagsWhereInput[]
    OR?: article_tagsWhereInput[]
    NOT?: article_tagsWhereInput | article_tagsWhereInput[]
    article_id?: IntFilter<"article_tags"> | number
    tag_id?: IntFilter<"article_tags"> | number
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    tag?: XOR<TagRelationFilter, tagWhereInput>
  }

  export type article_tagsOrderByWithRelationInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
    article?: articleOrderByWithRelationInput
    tag?: tagOrderByWithRelationInput
  }

  export type article_tagsWhereUniqueInput = Prisma.AtLeast<{
    article_id_tag_id?: article_tagsArticle_idTag_idCompoundUniqueInput
    AND?: article_tagsWhereInput | article_tagsWhereInput[]
    OR?: article_tagsWhereInput[]
    NOT?: article_tagsWhereInput | article_tagsWhereInput[]
    article_id?: IntFilter<"article_tags"> | number
    tag_id?: IntFilter<"article_tags"> | number
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    tag?: XOR<TagRelationFilter, tagWhereInput>
  }, "article_id_tag_id">

  export type article_tagsOrderByWithAggregationInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
    _count?: article_tagsCountOrderByAggregateInput
    _avg?: article_tagsAvgOrderByAggregateInput
    _max?: article_tagsMaxOrderByAggregateInput
    _min?: article_tagsMinOrderByAggregateInput
    _sum?: article_tagsSumOrderByAggregateInput
  }

  export type article_tagsScalarWhereWithAggregatesInput = {
    AND?: article_tagsScalarWhereWithAggregatesInput | article_tagsScalarWhereWithAggregatesInput[]
    OR?: article_tagsScalarWhereWithAggregatesInput[]
    NOT?: article_tagsScalarWhereWithAggregatesInput | article_tagsScalarWhereWithAggregatesInput[]
    article_id?: IntWithAggregatesFilter<"article_tags"> | number
    tag_id?: IntWithAggregatesFilter<"article_tags"> | number
  }

  export type articlestarWhereInput = {
    AND?: articlestarWhereInput | articlestarWhereInput[]
    OR?: articlestarWhereInput[]
    NOT?: articlestarWhereInput | articlestarWhereInput[]
    user_id?: IntFilter<"articlestar"> | number
    article_id?: IntFilter<"articlestar"> | number
    id?: IntFilter<"articlestar"> | number
    created_at?: DateTimeFilter<"articlestar"> | Date | string
    updated_at?: DateTimeFilter<"articlestar"> | Date | string
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type articlestarOrderByWithRelationInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    article?: articleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type articlestarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: articlestarWhereInput | articlestarWhereInput[]
    OR?: articlestarWhereInput[]
    NOT?: articlestarWhereInput | articlestarWhereInput[]
    user_id?: IntFilter<"articlestar"> | number
    article_id?: IntFilter<"articlestar"> | number
    created_at?: DateTimeFilter<"articlestar"> | Date | string
    updated_at?: DateTimeFilter<"articlestar"> | Date | string
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type articlestarOrderByWithAggregationInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: articlestarCountOrderByAggregateInput
    _avg?: articlestarAvgOrderByAggregateInput
    _max?: articlestarMaxOrderByAggregateInput
    _min?: articlestarMinOrderByAggregateInput
    _sum?: articlestarSumOrderByAggregateInput
  }

  export type articlestarScalarWhereWithAggregatesInput = {
    AND?: articlestarScalarWhereWithAggregatesInput | articlestarScalarWhereWithAggregatesInput[]
    OR?: articlestarScalarWhereWithAggregatesInput[]
    NOT?: articlestarScalarWhereWithAggregatesInput | articlestarScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"articlestar"> | number
    article_id?: IntWithAggregatesFilter<"articlestar"> | number
    id?: IntWithAggregatesFilter<"articlestar"> | number
    created_at?: DateTimeWithAggregatesFilter<"articlestar"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"articlestar"> | Date | string
  }

  export type articleviewWhereInput = {
    AND?: articleviewWhereInput | articleviewWhereInput[]
    OR?: articleviewWhereInput[]
    NOT?: articleviewWhereInput | articleviewWhereInput[]
    article_id?: IntFilter<"articleview"> | number
    user_id?: IntNullableFilter<"articleview"> | number | null
    ip_address?: StringNullableFilter<"articleview"> | string | null
    user_agent?: StringNullableFilter<"articleview"> | string | null
    referrer?: StringNullableFilter<"articleview"> | string | null
    view_duration?: IntNullableFilter<"articleview"> | number | null
    id?: IntFilter<"articleview"> | number
    created_at?: DateTimeFilter<"articleview"> | Date | string
    updated_at?: DateTimeFilter<"articleview"> | Date | string
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type articleviewOrderByWithRelationInput = {
    article_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    view_duration?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    article?: articleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type articleviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: articleviewWhereInput | articleviewWhereInput[]
    OR?: articleviewWhereInput[]
    NOT?: articleviewWhereInput | articleviewWhereInput[]
    article_id?: IntFilter<"articleview"> | number
    user_id?: IntNullableFilter<"articleview"> | number | null
    ip_address?: StringNullableFilter<"articleview"> | string | null
    user_agent?: StringNullableFilter<"articleview"> | string | null
    referrer?: StringNullableFilter<"articleview"> | string | null
    view_duration?: IntNullableFilter<"articleview"> | number | null
    created_at?: DateTimeFilter<"articleview"> | Date | string
    updated_at?: DateTimeFilter<"articleview"> | Date | string
    article?: XOR<ArticleRelationFilter, articleWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type articleviewOrderByWithAggregationInput = {
    article_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    view_duration?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: articleviewCountOrderByAggregateInput
    _avg?: articleviewAvgOrderByAggregateInput
    _max?: articleviewMaxOrderByAggregateInput
    _min?: articleviewMinOrderByAggregateInput
    _sum?: articleviewSumOrderByAggregateInput
  }

  export type articleviewScalarWhereWithAggregatesInput = {
    AND?: articleviewScalarWhereWithAggregatesInput | articleviewScalarWhereWithAggregatesInput[]
    OR?: articleviewScalarWhereWithAggregatesInput[]
    NOT?: articleviewScalarWhereWithAggregatesInput | articleviewScalarWhereWithAggregatesInput[]
    article_id?: IntWithAggregatesFilter<"articleview"> | number
    user_id?: IntNullableWithAggregatesFilter<"articleview"> | number | null
    ip_address?: StringNullableWithAggregatesFilter<"articleview"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"articleview"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"articleview"> | string | null
    view_duration?: IntNullableWithAggregatesFilter<"articleview"> | number | null
    id?: IntWithAggregatesFilter<"articleview"> | number
    created_at?: DateTimeWithAggregatesFilter<"articleview"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"articleview"> | Date | string
  }

  export type credit_articlesWhereInput = {
    AND?: credit_articlesWhereInput | credit_articlesWhereInput[]
    OR?: credit_articlesWhereInput[]
    NOT?: credit_articlesWhereInput | credit_articlesWhereInput[]
    id?: IntFilter<"credit_articles"> | number
    title?: StringNullableFilter<"credit_articles"> | string | null
    date?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    content?: StringNullableFilter<"credit_articles"> | string | null
    link?: StringNullableFilter<"credit_articles"> | string | null
    source?: StringNullableFilter<"credit_articles"> | string | null
    matched_keywords?: StringNullableFilter<"credit_articles"> | string | null
    region?: StringNullableFilter<"credit_articles"> | string | null
    sector?: StringNullableFilter<"credit_articles"> | string | null
    starred?: BoolNullableFilter<"credit_articles"> | boolean | null
    starred_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    summary?: StringNullableFilter<"credit_articles"> | string | null
    url?: StringNullableFilter<"credit_articles"> | string | null
    created_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    user_article_stars?: User_article_starsListRelationFilter
  }

  export type credit_articlesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    matched_keywords?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    starred?: SortOrderInput | SortOrder
    starred_at?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_article_stars?: user_article_starsOrderByRelationAggregateInput
  }

  export type credit_articlesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    link_region_sector_source?: credit_articlesLinkRegionSectorSourceCompoundUniqueInput
    AND?: credit_articlesWhereInput | credit_articlesWhereInput[]
    OR?: credit_articlesWhereInput[]
    NOT?: credit_articlesWhereInput | credit_articlesWhereInput[]
    title?: StringNullableFilter<"credit_articles"> | string | null
    date?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    content?: StringNullableFilter<"credit_articles"> | string | null
    link?: StringNullableFilter<"credit_articles"> | string | null
    source?: StringNullableFilter<"credit_articles"> | string | null
    matched_keywords?: StringNullableFilter<"credit_articles"> | string | null
    region?: StringNullableFilter<"credit_articles"> | string | null
    sector?: StringNullableFilter<"credit_articles"> | string | null
    starred?: BoolNullableFilter<"credit_articles"> | boolean | null
    starred_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    summary?: StringNullableFilter<"credit_articles"> | string | null
    url?: StringNullableFilter<"credit_articles"> | string | null
    created_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"credit_articles"> | Date | string | null
    user_article_stars?: User_article_starsListRelationFilter
  }, "id" | "link_region_sector_source">

  export type credit_articlesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    matched_keywords?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    starred?: SortOrderInput | SortOrder
    starred_at?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: credit_articlesCountOrderByAggregateInput
    _avg?: credit_articlesAvgOrderByAggregateInput
    _max?: credit_articlesMaxOrderByAggregateInput
    _min?: credit_articlesMinOrderByAggregateInput
    _sum?: credit_articlesSumOrderByAggregateInput
  }

  export type credit_articlesScalarWhereWithAggregatesInput = {
    AND?: credit_articlesScalarWhereWithAggregatesInput | credit_articlesScalarWhereWithAggregatesInput[]
    OR?: credit_articlesScalarWhereWithAggregatesInput[]
    NOT?: credit_articlesScalarWhereWithAggregatesInput | credit_articlesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"credit_articles"> | number
    title?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"credit_articles"> | Date | string | null
    content?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    link?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    source?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    matched_keywords?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    region?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    sector?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    starred?: BoolNullableWithAggregatesFilter<"credit_articles"> | boolean | null
    starred_at?: DateTimeNullableWithAggregatesFilter<"credit_articles"> | Date | string | null
    summary?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    url?: StringNullableWithAggregatesFilter<"credit_articles"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"credit_articles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"credit_articles"> | Date | string | null
  }

  export type email_alertsWhereInput = {
    AND?: email_alertsWhereInput | email_alertsWhereInput[]
    OR?: email_alertsWhereInput[]
    NOT?: email_alertsWhereInput | email_alertsWhereInput[]
    id?: IntFilter<"email_alerts"> | number
    email?: StringFilter<"email_alerts"> | string
    alert_type?: StringFilter<"email_alerts"> | string
    subscription_date?: DateTimeFilter<"email_alerts"> | Date | string
    active?: BoolFilter<"email_alerts"> | boolean
  }

  export type email_alertsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    alert_type?: SortOrder
    subscription_date?: SortOrder
    active?: SortOrder
  }

  export type email_alertsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: email_alertsWhereInput | email_alertsWhereInput[]
    OR?: email_alertsWhereInput[]
    NOT?: email_alertsWhereInput | email_alertsWhereInput[]
    email?: StringFilter<"email_alerts"> | string
    alert_type?: StringFilter<"email_alerts"> | string
    subscription_date?: DateTimeFilter<"email_alerts"> | Date | string
    active?: BoolFilter<"email_alerts"> | boolean
  }, "id">

  export type email_alertsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    alert_type?: SortOrder
    subscription_date?: SortOrder
    active?: SortOrder
    _count?: email_alertsCountOrderByAggregateInput
    _avg?: email_alertsAvgOrderByAggregateInput
    _max?: email_alertsMaxOrderByAggregateInput
    _min?: email_alertsMinOrderByAggregateInput
    _sum?: email_alertsSumOrderByAggregateInput
  }

  export type email_alertsScalarWhereWithAggregatesInput = {
    AND?: email_alertsScalarWhereWithAggregatesInput | email_alertsScalarWhereWithAggregatesInput[]
    OR?: email_alertsScalarWhereWithAggregatesInput[]
    NOT?: email_alertsScalarWhereWithAggregatesInput | email_alertsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"email_alerts"> | number
    email?: StringWithAggregatesFilter<"email_alerts"> | string
    alert_type?: StringWithAggregatesFilter<"email_alerts"> | string
    subscription_date?: DateTimeWithAggregatesFilter<"email_alerts"> | Date | string
    active?: BoolWithAggregatesFilter<"email_alerts"> | boolean
  }

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    title?: StringFilter<"event"> | string
    slug?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    event_type?: StringNullableFilter<"event"> | string | null
    location?: StringNullableFilter<"event"> | string | null
    venue?: StringNullableFilter<"event"> | string | null
    is_virtual?: BoolFilter<"event"> | boolean
    virtual_link?: StringNullableFilter<"event"> | string | null
    start_date?: DateTimeFilter<"event"> | Date | string
    end_date?: DateTimeNullableFilter<"event"> | Date | string | null
    timezone?: StringNullableFilter<"event"> | string | null
    registration_link?: StringNullableFilter<"event"> | string | null
    registration_deadline?: DateTimeNullableFilter<"event"> | Date | string | null
    max_attendees?: IntNullableFilter<"event"> | number | null
    price?: FloatNullableFilter<"event"> | number | null
    currency?: StringNullableFilter<"event"> | string | null
    organizer?: StringNullableFilter<"event"> | string | null
    organizer_email?: StringNullableFilter<"event"> | string | null
    organizer_phone?: StringNullableFilter<"event"> | string | null
    sponsors?: JsonNullableFilter<"event">
    agenda?: StringNullableFilter<"event"> | string | null
    speakers?: JsonNullableFilter<"event">
    tags?: JsonNullableFilter<"event">
    source?: StringNullableFilter<"event"> | string | null
    source_url?: StringNullableFilter<"event"> | string | null
    is_published?: BoolFilter<"event"> | boolean
    is_featured?: BoolFilter<"event"> | boolean
    is_cancelled?: BoolFilter<"event"> | boolean
    cancellation_reason?: StringNullableFilter<"event"> | string | null
    created_by_id?: IntNullableFilter<"event"> | number | null
    view_count?: IntFilter<"event"> | number
    id?: IntFilter<"event"> | number
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    is_deleted?: BoolFilter<"event"> | boolean
    deleted_at?: DateTimeNullableFilter<"event"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    eventregistration?: EventregistrationListRelationFilter
  }

  export type eventOrderByWithRelationInput = {
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    is_virtual?: SortOrder
    virtual_link?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    registration_link?: SortOrderInput | SortOrder
    registration_deadline?: SortOrderInput | SortOrder
    max_attendees?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    organizer_email?: SortOrderInput | SortOrder
    organizer_phone?: SortOrderInput | SortOrder
    sponsors?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    speakers?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    source_url?: SortOrderInput | SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    is_cancelled?: SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    created_by_id?: SortOrderInput | SortOrder
    view_count?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    eventregistration?: eventregistrationOrderByRelationAggregateInput
  }

  export type eventWhereUniqueInput = Prisma.AtLeast<{
    slug?: string
    id?: number
    AND?: eventWhereInput | eventWhereInput[]
    OR?: eventWhereInput[]
    NOT?: eventWhereInput | eventWhereInput[]
    title?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    event_type?: StringNullableFilter<"event"> | string | null
    location?: StringNullableFilter<"event"> | string | null
    venue?: StringNullableFilter<"event"> | string | null
    is_virtual?: BoolFilter<"event"> | boolean
    virtual_link?: StringNullableFilter<"event"> | string | null
    start_date?: DateTimeFilter<"event"> | Date | string
    end_date?: DateTimeNullableFilter<"event"> | Date | string | null
    timezone?: StringNullableFilter<"event"> | string | null
    registration_link?: StringNullableFilter<"event"> | string | null
    registration_deadline?: DateTimeNullableFilter<"event"> | Date | string | null
    max_attendees?: IntNullableFilter<"event"> | number | null
    price?: FloatNullableFilter<"event"> | number | null
    currency?: StringNullableFilter<"event"> | string | null
    organizer?: StringNullableFilter<"event"> | string | null
    organizer_email?: StringNullableFilter<"event"> | string | null
    organizer_phone?: StringNullableFilter<"event"> | string | null
    sponsors?: JsonNullableFilter<"event">
    agenda?: StringNullableFilter<"event"> | string | null
    speakers?: JsonNullableFilter<"event">
    tags?: JsonNullableFilter<"event">
    source?: StringNullableFilter<"event"> | string | null
    source_url?: StringNullableFilter<"event"> | string | null
    is_published?: BoolFilter<"event"> | boolean
    is_featured?: BoolFilter<"event"> | boolean
    is_cancelled?: BoolFilter<"event"> | boolean
    cancellation_reason?: StringNullableFilter<"event"> | string | null
    created_by_id?: IntNullableFilter<"event"> | number | null
    view_count?: IntFilter<"event"> | number
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    is_deleted?: BoolFilter<"event"> | boolean
    deleted_at?: DateTimeNullableFilter<"event"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    eventregistration?: EventregistrationListRelationFilter
  }, "id" | "slug">

  export type eventOrderByWithAggregationInput = {
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    event_type?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    is_virtual?: SortOrder
    virtual_link?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    registration_link?: SortOrderInput | SortOrder
    registration_deadline?: SortOrderInput | SortOrder
    max_attendees?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    organizer?: SortOrderInput | SortOrder
    organizer_email?: SortOrderInput | SortOrder
    organizer_phone?: SortOrderInput | SortOrder
    sponsors?: SortOrderInput | SortOrder
    agenda?: SortOrderInput | SortOrder
    speakers?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    source_url?: SortOrderInput | SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    is_cancelled?: SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    created_by_id?: SortOrderInput | SortOrder
    view_count?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: eventCountOrderByAggregateInput
    _avg?: eventAvgOrderByAggregateInput
    _max?: eventMaxOrderByAggregateInput
    _min?: eventMinOrderByAggregateInput
    _sum?: eventSumOrderByAggregateInput
  }

  export type eventScalarWhereWithAggregatesInput = {
    AND?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    OR?: eventScalarWhereWithAggregatesInput[]
    NOT?: eventScalarWhereWithAggregatesInput | eventScalarWhereWithAggregatesInput[]
    title?: StringWithAggregatesFilter<"event"> | string
    slug?: StringWithAggregatesFilter<"event"> | string
    description?: StringNullableWithAggregatesFilter<"event"> | string | null
    event_type?: StringNullableWithAggregatesFilter<"event"> | string | null
    location?: StringNullableWithAggregatesFilter<"event"> | string | null
    venue?: StringNullableWithAggregatesFilter<"event"> | string | null
    is_virtual?: BoolWithAggregatesFilter<"event"> | boolean
    virtual_link?: StringNullableWithAggregatesFilter<"event"> | string | null
    start_date?: DateTimeWithAggregatesFilter<"event"> | Date | string
    end_date?: DateTimeNullableWithAggregatesFilter<"event"> | Date | string | null
    timezone?: StringNullableWithAggregatesFilter<"event"> | string | null
    registration_link?: StringNullableWithAggregatesFilter<"event"> | string | null
    registration_deadline?: DateTimeNullableWithAggregatesFilter<"event"> | Date | string | null
    max_attendees?: IntNullableWithAggregatesFilter<"event"> | number | null
    price?: FloatNullableWithAggregatesFilter<"event"> | number | null
    currency?: StringNullableWithAggregatesFilter<"event"> | string | null
    organizer?: StringNullableWithAggregatesFilter<"event"> | string | null
    organizer_email?: StringNullableWithAggregatesFilter<"event"> | string | null
    organizer_phone?: StringNullableWithAggregatesFilter<"event"> | string | null
    sponsors?: JsonNullableWithAggregatesFilter<"event">
    agenda?: StringNullableWithAggregatesFilter<"event"> | string | null
    speakers?: JsonNullableWithAggregatesFilter<"event">
    tags?: JsonNullableWithAggregatesFilter<"event">
    source?: StringNullableWithAggregatesFilter<"event"> | string | null
    source_url?: StringNullableWithAggregatesFilter<"event"> | string | null
    is_published?: BoolWithAggregatesFilter<"event"> | boolean
    is_featured?: BoolWithAggregatesFilter<"event"> | boolean
    is_cancelled?: BoolWithAggregatesFilter<"event"> | boolean
    cancellation_reason?: StringNullableWithAggregatesFilter<"event"> | string | null
    created_by_id?: IntNullableWithAggregatesFilter<"event"> | number | null
    view_count?: IntWithAggregatesFilter<"event"> | number
    id?: IntWithAggregatesFilter<"event"> | number
    created_at?: DateTimeWithAggregatesFilter<"event"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"event"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"event"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"event"> | Date | string | null
  }

  export type eventregistrationWhereInput = {
    AND?: eventregistrationWhereInput | eventregistrationWhereInput[]
    OR?: eventregistrationWhereInput[]
    NOT?: eventregistrationWhereInput | eventregistrationWhereInput[]
    event_id?: IntFilter<"eventregistration"> | number
    user_id?: IntFilter<"eventregistration"> | number
    registered_at?: DateTimeFilter<"eventregistration"> | Date | string
    is_confirmed?: BoolFilter<"eventregistration"> | boolean
    is_cancelled?: BoolFilter<"eventregistration"> | boolean
    cancelled_at?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"eventregistration"> | string | null
    attended?: BoolFilter<"eventregistration"> | boolean
    check_in_time?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    dietary_requirements?: StringNullableFilter<"eventregistration"> | string | null
    special_requirements?: StringNullableFilter<"eventregistration"> | string | null
    id?: IntFilter<"eventregistration"> | number
    created_at?: DateTimeFilter<"eventregistration"> | Date | string
    updated_at?: DateTimeFilter<"eventregistration"> | Date | string
    event?: XOR<EventRelationFilter, eventWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type eventregistrationOrderByWithRelationInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    is_confirmed?: SortOrder
    is_cancelled?: SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    attended?: SortOrder
    check_in_time?: SortOrderInput | SortOrder
    dietary_requirements?: SortOrderInput | SortOrder
    special_requirements?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    event?: eventOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type eventregistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: eventregistrationWhereInput | eventregistrationWhereInput[]
    OR?: eventregistrationWhereInput[]
    NOT?: eventregistrationWhereInput | eventregistrationWhereInput[]
    event_id?: IntFilter<"eventregistration"> | number
    user_id?: IntFilter<"eventregistration"> | number
    registered_at?: DateTimeFilter<"eventregistration"> | Date | string
    is_confirmed?: BoolFilter<"eventregistration"> | boolean
    is_cancelled?: BoolFilter<"eventregistration"> | boolean
    cancelled_at?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"eventregistration"> | string | null
    attended?: BoolFilter<"eventregistration"> | boolean
    check_in_time?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    dietary_requirements?: StringNullableFilter<"eventregistration"> | string | null
    special_requirements?: StringNullableFilter<"eventregistration"> | string | null
    created_at?: DateTimeFilter<"eventregistration"> | Date | string
    updated_at?: DateTimeFilter<"eventregistration"> | Date | string
    event?: XOR<EventRelationFilter, eventWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type eventregistrationOrderByWithAggregationInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    is_confirmed?: SortOrder
    is_cancelled?: SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    attended?: SortOrder
    check_in_time?: SortOrderInput | SortOrder
    dietary_requirements?: SortOrderInput | SortOrder
    special_requirements?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: eventregistrationCountOrderByAggregateInput
    _avg?: eventregistrationAvgOrderByAggregateInput
    _max?: eventregistrationMaxOrderByAggregateInput
    _min?: eventregistrationMinOrderByAggregateInput
    _sum?: eventregistrationSumOrderByAggregateInput
  }

  export type eventregistrationScalarWhereWithAggregatesInput = {
    AND?: eventregistrationScalarWhereWithAggregatesInput | eventregistrationScalarWhereWithAggregatesInput[]
    OR?: eventregistrationScalarWhereWithAggregatesInput[]
    NOT?: eventregistrationScalarWhereWithAggregatesInput | eventregistrationScalarWhereWithAggregatesInput[]
    event_id?: IntWithAggregatesFilter<"eventregistration"> | number
    user_id?: IntWithAggregatesFilter<"eventregistration"> | number
    registered_at?: DateTimeWithAggregatesFilter<"eventregistration"> | Date | string
    is_confirmed?: BoolWithAggregatesFilter<"eventregistration"> | boolean
    is_cancelled?: BoolWithAggregatesFilter<"eventregistration"> | boolean
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"eventregistration"> | Date | string | null
    cancellation_reason?: StringNullableWithAggregatesFilter<"eventregistration"> | string | null
    attended?: BoolWithAggregatesFilter<"eventregistration"> | boolean
    check_in_time?: DateTimeNullableWithAggregatesFilter<"eventregistration"> | Date | string | null
    dietary_requirements?: StringNullableWithAggregatesFilter<"eventregistration"> | string | null
    special_requirements?: StringNullableWithAggregatesFilter<"eventregistration"> | string | null
    id?: IntWithAggregatesFilter<"eventregistration"> | number
    created_at?: DateTimeWithAggregatesFilter<"eventregistration"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"eventregistration"> | Date | string
  }

  export type eventsWhereInput = {
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    id?: IntFilter<"events"> | number
    title?: StringFilter<"events"> | string
    date?: DateTimeNullableFilter<"events"> | Date | string | null
    location?: StringNullableFilter<"events"> | string | null
    details?: StringNullableFilter<"events"> | string | null
    link?: StringNullableFilter<"events"> | string | null
    source?: StringNullableFilter<"events"> | string | null
    created_at?: DateTimeNullableFilter<"events"> | Date | string | null
  }

  export type eventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    title?: StringFilter<"events"> | string
    date?: DateTimeNullableFilter<"events"> | Date | string | null
    location?: StringNullableFilter<"events"> | string | null
    details?: StringNullableFilter<"events"> | string | null
    link?: StringNullableFilter<"events"> | string | null
    source?: StringNullableFilter<"events"> | string | null
    created_at?: DateTimeNullableFilter<"events"> | Date | string | null
  }, "id">

  export type eventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: eventsCountOrderByAggregateInput
    _avg?: eventsAvgOrderByAggregateInput
    _max?: eventsMaxOrderByAggregateInput
    _min?: eventsMinOrderByAggregateInput
    _sum?: eventsSumOrderByAggregateInput
  }

  export type eventsScalarWhereWithAggregatesInput = {
    AND?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    OR?: eventsScalarWhereWithAggregatesInput[]
    NOT?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"events"> | number
    title?: StringWithAggregatesFilter<"events"> | string
    date?: DateTimeNullableWithAggregatesFilter<"events"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"events"> | string | null
    details?: StringNullableWithAggregatesFilter<"events"> | string | null
    link?: StringNullableWithAggregatesFilter<"events"> | string | null
    source?: StringNullableWithAggregatesFilter<"events"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"events"> | Date | string | null
  }

  export type methodologiesWhereInput = {
    AND?: methodologiesWhereInput | methodologiesWhereInput[]
    OR?: methodologiesWhereInput[]
    NOT?: methodologiesWhereInput | methodologiesWhereInput[]
    id?: IntFilter<"methodologies"> | number
    title?: StringNullableFilter<"methodologies"> | string | null
    published_date?: DateTimeNullableFilter<"methodologies"> | Date | string | null
    abstract?: StringNullableFilter<"methodologies"> | string | null
    description?: StringNullableFilter<"methodologies"> | string | null
    link?: StringNullableFilter<"methodologies"> | string | null
    source?: StringNullableFilter<"methodologies"> | string | null
    permalink?: StringNullableFilter<"methodologies"> | string | null
    created_at?: DateTimeNullableFilter<"methodologies"> | Date | string | null
    report_url?: StringNullableFilter<"methodologies"> | string | null
  }

  export type methodologiesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    published_date?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    permalink?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    report_url?: SortOrderInput | SortOrder
  }

  export type methodologiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    link?: string
    report_url?: string
    AND?: methodologiesWhereInput | methodologiesWhereInput[]
    OR?: methodologiesWhereInput[]
    NOT?: methodologiesWhereInput | methodologiesWhereInput[]
    title?: StringNullableFilter<"methodologies"> | string | null
    published_date?: DateTimeNullableFilter<"methodologies"> | Date | string | null
    abstract?: StringNullableFilter<"methodologies"> | string | null
    description?: StringNullableFilter<"methodologies"> | string | null
    source?: StringNullableFilter<"methodologies"> | string | null
    permalink?: StringNullableFilter<"methodologies"> | string | null
    created_at?: DateTimeNullableFilter<"methodologies"> | Date | string | null
  }, "id" | "link" | "report_url">

  export type methodologiesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    published_date?: SortOrderInput | SortOrder
    abstract?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    permalink?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    report_url?: SortOrderInput | SortOrder
    _count?: methodologiesCountOrderByAggregateInput
    _avg?: methodologiesAvgOrderByAggregateInput
    _max?: methodologiesMaxOrderByAggregateInput
    _min?: methodologiesMinOrderByAggregateInput
    _sum?: methodologiesSumOrderByAggregateInput
  }

  export type methodologiesScalarWhereWithAggregatesInput = {
    AND?: methodologiesScalarWhereWithAggregatesInput | methodologiesScalarWhereWithAggregatesInput[]
    OR?: methodologiesScalarWhereWithAggregatesInput[]
    NOT?: methodologiesScalarWhereWithAggregatesInput | methodologiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"methodologies"> | number
    title?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    published_date?: DateTimeNullableWithAggregatesFilter<"methodologies"> | Date | string | null
    abstract?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    description?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    link?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    source?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    permalink?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"methodologies"> | Date | string | null
    report_url?: StringNullableWithAggregatesFilter<"methodologies"> | string | null
  }

  export type newsletter_logsWhereInput = {
    AND?: newsletter_logsWhereInput | newsletter_logsWhereInput[]
    OR?: newsletter_logsWhereInput[]
    NOT?: newsletter_logsWhereInput | newsletter_logsWhereInput[]
    id?: IntFilter<"newsletter_logs"> | number
    subscription_id?: IntFilter<"newsletter_logs"> | number
    sent_at?: DateTimeNullableFilter<"newsletter_logs"> | Date | string | null
    email_to?: StringFilter<"newsletter_logs"> | string
    email_subject?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_count?: IntNullableFilter<"newsletter_logs"> | number | null
    success?: BoolNullableFilter<"newsletter_logs"> | boolean | null
    error_message?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_included?: JsonNullableFilter<"newsletter_logs">
    email_content_preview?: StringNullableFilter<"newsletter_logs"> | string | null
    newsletter_subscriptions?: XOR<Newsletter_subscriptionsRelationFilter, newsletter_subscriptionsWhereInput>
  }

  export type newsletter_logsOrderByWithRelationInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    email_to?: SortOrder
    email_subject?: SortOrderInput | SortOrder
    articles_count?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    articles_included?: SortOrderInput | SortOrder
    email_content_preview?: SortOrderInput | SortOrder
    newsletter_subscriptions?: newsletter_subscriptionsOrderByWithRelationInput
  }

  export type newsletter_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: newsletter_logsWhereInput | newsletter_logsWhereInput[]
    OR?: newsletter_logsWhereInput[]
    NOT?: newsletter_logsWhereInput | newsletter_logsWhereInput[]
    subscription_id?: IntFilter<"newsletter_logs"> | number
    sent_at?: DateTimeNullableFilter<"newsletter_logs"> | Date | string | null
    email_to?: StringFilter<"newsletter_logs"> | string
    email_subject?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_count?: IntNullableFilter<"newsletter_logs"> | number | null
    success?: BoolNullableFilter<"newsletter_logs"> | boolean | null
    error_message?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_included?: JsonNullableFilter<"newsletter_logs">
    email_content_preview?: StringNullableFilter<"newsletter_logs"> | string | null
    newsletter_subscriptions?: XOR<Newsletter_subscriptionsRelationFilter, newsletter_subscriptionsWhereInput>
  }, "id">

  export type newsletter_logsOrderByWithAggregationInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    email_to?: SortOrder
    email_subject?: SortOrderInput | SortOrder
    articles_count?: SortOrderInput | SortOrder
    success?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    articles_included?: SortOrderInput | SortOrder
    email_content_preview?: SortOrderInput | SortOrder
    _count?: newsletter_logsCountOrderByAggregateInput
    _avg?: newsletter_logsAvgOrderByAggregateInput
    _max?: newsletter_logsMaxOrderByAggregateInput
    _min?: newsletter_logsMinOrderByAggregateInput
    _sum?: newsletter_logsSumOrderByAggregateInput
  }

  export type newsletter_logsScalarWhereWithAggregatesInput = {
    AND?: newsletter_logsScalarWhereWithAggregatesInput | newsletter_logsScalarWhereWithAggregatesInput[]
    OR?: newsletter_logsScalarWhereWithAggregatesInput[]
    NOT?: newsletter_logsScalarWhereWithAggregatesInput | newsletter_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"newsletter_logs"> | number
    subscription_id?: IntWithAggregatesFilter<"newsletter_logs"> | number
    sent_at?: DateTimeNullableWithAggregatesFilter<"newsletter_logs"> | Date | string | null
    email_to?: StringWithAggregatesFilter<"newsletter_logs"> | string
    email_subject?: StringNullableWithAggregatesFilter<"newsletter_logs"> | string | null
    articles_count?: IntNullableWithAggregatesFilter<"newsletter_logs"> | number | null
    success?: BoolNullableWithAggregatesFilter<"newsletter_logs"> | boolean | null
    error_message?: StringNullableWithAggregatesFilter<"newsletter_logs"> | string | null
    articles_included?: JsonNullableWithAggregatesFilter<"newsletter_logs">
    email_content_preview?: StringNullableWithAggregatesFilter<"newsletter_logs"> | string | null
  }

  export type newsletter_preferencesWhereInput = {
    AND?: newsletter_preferencesWhereInput | newsletter_preferencesWhereInput[]
    OR?: newsletter_preferencesWhereInput[]
    NOT?: newsletter_preferencesWhereInput | newsletter_preferencesWhereInput[]
    id?: IntFilter<"newsletter_preferences"> | number
    subscription_id?: IntFilter<"newsletter_preferences"> | number
    sources?: StringNullableListFilter<"newsletter_preferences">
    regions?: StringNullableListFilter<"newsletter_preferences">
    sectors?: StringNullableListFilter<"newsletter_preferences">
    include_starred_only?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    frequency?: StringFilter<"newsletter_preferences"> | string
    day_of_week?: IntNullableFilter<"newsletter_preferences"> | number | null
    time_of_day?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    timezone?: StringNullableFilter<"newsletter_preferences"> | string | null
    max_articles_per_email?: IntNullableFilter<"newsletter_preferences"> | number | null
    include_summary?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    created_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    newsletter_subscriptions?: XOR<Newsletter_subscriptionsRelationFilter, newsletter_subscriptionsWhereInput>
  }

  export type newsletter_preferencesOrderByWithRelationInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sources?: SortOrder
    regions?: SortOrder
    sectors?: SortOrder
    include_starred_only?: SortOrderInput | SortOrder
    frequency?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    time_of_day?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    max_articles_per_email?: SortOrderInput | SortOrder
    include_summary?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    newsletter_subscriptions?: newsletter_subscriptionsOrderByWithRelationInput
  }

  export type newsletter_preferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: newsletter_preferencesWhereInput | newsletter_preferencesWhereInput[]
    OR?: newsletter_preferencesWhereInput[]
    NOT?: newsletter_preferencesWhereInput | newsletter_preferencesWhereInput[]
    subscription_id?: IntFilter<"newsletter_preferences"> | number
    sources?: StringNullableListFilter<"newsletter_preferences">
    regions?: StringNullableListFilter<"newsletter_preferences">
    sectors?: StringNullableListFilter<"newsletter_preferences">
    include_starred_only?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    frequency?: StringFilter<"newsletter_preferences"> | string
    day_of_week?: IntNullableFilter<"newsletter_preferences"> | number | null
    time_of_day?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    timezone?: StringNullableFilter<"newsletter_preferences"> | string | null
    max_articles_per_email?: IntNullableFilter<"newsletter_preferences"> | number | null
    include_summary?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    created_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    newsletter_subscriptions?: XOR<Newsletter_subscriptionsRelationFilter, newsletter_subscriptionsWhereInput>
  }, "id">

  export type newsletter_preferencesOrderByWithAggregationInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sources?: SortOrder
    regions?: SortOrder
    sectors?: SortOrder
    include_starred_only?: SortOrderInput | SortOrder
    frequency?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    time_of_day?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    max_articles_per_email?: SortOrderInput | SortOrder
    include_summary?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: newsletter_preferencesCountOrderByAggregateInput
    _avg?: newsletter_preferencesAvgOrderByAggregateInput
    _max?: newsletter_preferencesMaxOrderByAggregateInput
    _min?: newsletter_preferencesMinOrderByAggregateInput
    _sum?: newsletter_preferencesSumOrderByAggregateInput
  }

  export type newsletter_preferencesScalarWhereWithAggregatesInput = {
    AND?: newsletter_preferencesScalarWhereWithAggregatesInput | newsletter_preferencesScalarWhereWithAggregatesInput[]
    OR?: newsletter_preferencesScalarWhereWithAggregatesInput[]
    NOT?: newsletter_preferencesScalarWhereWithAggregatesInput | newsletter_preferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"newsletter_preferences"> | number
    subscription_id?: IntWithAggregatesFilter<"newsletter_preferences"> | number
    sources?: StringNullableListFilter<"newsletter_preferences">
    regions?: StringNullableListFilter<"newsletter_preferences">
    sectors?: StringNullableListFilter<"newsletter_preferences">
    include_starred_only?: BoolNullableWithAggregatesFilter<"newsletter_preferences"> | boolean | null
    frequency?: StringWithAggregatesFilter<"newsletter_preferences"> | string
    day_of_week?: IntNullableWithAggregatesFilter<"newsletter_preferences"> | number | null
    time_of_day?: DateTimeNullableWithAggregatesFilter<"newsletter_preferences"> | Date | string | null
    timezone?: StringNullableWithAggregatesFilter<"newsletter_preferences"> | string | null
    max_articles_per_email?: IntNullableWithAggregatesFilter<"newsletter_preferences"> | number | null
    include_summary?: BoolNullableWithAggregatesFilter<"newsletter_preferences"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"newsletter_preferences"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"newsletter_preferences"> | Date | string | null
  }

  export type newsletter_subscriptionsWhereInput = {
    AND?: newsletter_subscriptionsWhereInput | newsletter_subscriptionsWhereInput[]
    OR?: newsletter_subscriptionsWhereInput[]
    NOT?: newsletter_subscriptionsWhereInput | newsletter_subscriptionsWhereInput[]
    id?: IntFilter<"newsletter_subscriptions"> | number
    user_id?: IntFilter<"newsletter_subscriptions"> | number
    subscription_type?: StringFilter<"newsletter_subscriptions"> | string
    is_active?: BoolNullableFilter<"newsletter_subscriptions"> | boolean | null
    email?: StringNullableFilter<"newsletter_subscriptions"> | string | null
    created_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
    newsletter_logs?: Newsletter_logsListRelationFilter
    newsletter_preferences?: Newsletter_preferencesListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type newsletter_subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_type?: SortOrder
    is_active?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    newsletter_logs?: newsletter_logsOrderByRelationAggregateInput
    newsletter_preferences?: newsletter_preferencesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type newsletter_subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_subscription_type?: newsletter_subscriptionsUser_idSubscription_typeCompoundUniqueInput
    AND?: newsletter_subscriptionsWhereInput | newsletter_subscriptionsWhereInput[]
    OR?: newsletter_subscriptionsWhereInput[]
    NOT?: newsletter_subscriptionsWhereInput | newsletter_subscriptionsWhereInput[]
    user_id?: IntFilter<"newsletter_subscriptions"> | number
    subscription_type?: StringFilter<"newsletter_subscriptions"> | string
    is_active?: BoolNullableFilter<"newsletter_subscriptions"> | boolean | null
    email?: StringNullableFilter<"newsletter_subscriptions"> | string | null
    created_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
    newsletter_logs?: Newsletter_logsListRelationFilter
    newsletter_preferences?: Newsletter_preferencesListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id_subscription_type">

  export type newsletter_subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_type?: SortOrder
    is_active?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: newsletter_subscriptionsCountOrderByAggregateInput
    _avg?: newsletter_subscriptionsAvgOrderByAggregateInput
    _max?: newsletter_subscriptionsMaxOrderByAggregateInput
    _min?: newsletter_subscriptionsMinOrderByAggregateInput
    _sum?: newsletter_subscriptionsSumOrderByAggregateInput
  }

  export type newsletter_subscriptionsScalarWhereWithAggregatesInput = {
    AND?: newsletter_subscriptionsScalarWhereWithAggregatesInput | newsletter_subscriptionsScalarWhereWithAggregatesInput[]
    OR?: newsletter_subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: newsletter_subscriptionsScalarWhereWithAggregatesInput | newsletter_subscriptionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"newsletter_subscriptions"> | number
    user_id?: IntWithAggregatesFilter<"newsletter_subscriptions"> | number
    subscription_type?: StringWithAggregatesFilter<"newsletter_subscriptions"> | string
    is_active?: BoolNullableWithAggregatesFilter<"newsletter_subscriptions"> | boolean | null
    email?: StringNullableWithAggregatesFilter<"newsletter_subscriptions"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"newsletter_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"newsletter_subscriptions"> | Date | string | null
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    name?: EnumpermissiontypeFilter<"permission"> | $Enums.permissiontype
    description?: StringNullableFilter<"permission"> | string | null
    id?: IntFilter<"permission"> | number
    created_at?: DateTimeFilter<"permission"> | Date | string
    updated_at?: DateTimeFilter<"permission"> | Date | string
    user_permissions?: User_permissionsListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_permissions?: user_permissionsOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    name?: $Enums.permissiontype
    id?: number
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    description?: StringNullableFilter<"permission"> | string | null
    created_at?: DateTimeFilter<"permission"> | Date | string
    updated_at?: DateTimeFilter<"permission"> | Date | string
    user_permissions?: User_permissionsListRelationFilter
  }, "id" | "name">

  export type permissionOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: permissionCountOrderByAggregateInput
    _avg?: permissionAvgOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
    _sum?: permissionSumOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    name?: EnumpermissiontypeWithAggregatesFilter<"permission"> | $Enums.permissiontype
    description?: StringNullableWithAggregatesFilter<"permission"> | string | null
    id?: IntWithAggregatesFilter<"permission"> | number
    created_at?: DateTimeWithAggregatesFilter<"permission"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"permission"> | Date | string
  }

  export type publicationsWhereInput = {
    AND?: publicationsWhereInput | publicationsWhereInput[]
    OR?: publicationsWhereInput[]
    NOT?: publicationsWhereInput | publicationsWhereInput[]
    id?: IntFilter<"publications"> | number
    title?: StringNullableFilter<"publications"> | string | null
    date?: DateTimeNullableFilter<"publications"> | Date | string | null
    description?: StringNullableFilter<"publications"> | string | null
    link?: StringNullableFilter<"publications"> | string | null
    image_url?: StringNullableFilter<"publications"> | string | null
    source?: StringNullableFilter<"publications"> | string | null
    created_at?: DateTimeNullableFilter<"publications"> | Date | string | null
  }

  export type publicationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type publicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    link?: string
    AND?: publicationsWhereInput | publicationsWhereInput[]
    OR?: publicationsWhereInput[]
    NOT?: publicationsWhereInput | publicationsWhereInput[]
    title?: StringNullableFilter<"publications"> | string | null
    date?: DateTimeNullableFilter<"publications"> | Date | string | null
    description?: StringNullableFilter<"publications"> | string | null
    image_url?: StringNullableFilter<"publications"> | string | null
    source?: StringNullableFilter<"publications"> | string | null
    created_at?: DateTimeNullableFilter<"publications"> | Date | string | null
  }, "id" | "link">

  export type publicationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: publicationsCountOrderByAggregateInput
    _avg?: publicationsAvgOrderByAggregateInput
    _max?: publicationsMaxOrderByAggregateInput
    _min?: publicationsMinOrderByAggregateInput
    _sum?: publicationsSumOrderByAggregateInput
  }

  export type publicationsScalarWhereWithAggregatesInput = {
    AND?: publicationsScalarWhereWithAggregatesInput | publicationsScalarWhereWithAggregatesInput[]
    OR?: publicationsScalarWhereWithAggregatesInput[]
    NOT?: publicationsScalarWhereWithAggregatesInput | publicationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"publications"> | number
    title?: StringNullableWithAggregatesFilter<"publications"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"publications"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"publications"> | string | null
    link?: StringNullableWithAggregatesFilter<"publications"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"publications"> | string | null
    source?: StringNullableWithAggregatesFilter<"publications"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"publications"> | Date | string | null
  }

  export type refreshtokenWhereInput = {
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    token?: StringFilter<"refreshtoken"> | string
    user_id?: IntFilter<"refreshtoken"> | number
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    revoked?: BoolFilter<"refreshtoken"> | boolean
    revoked_at?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    id?: IntFilter<"refreshtoken"> | number
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    updated_at?: DateTimeFilter<"refreshtoken"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type refreshtokenOrderByWithRelationInput = {
    token?: SortOrder
    user_id?: SortOrder
    expires_at?: SortOrder
    revoked?: SortOrder
    revoked_at?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type refreshtokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    id?: number
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    user_id?: IntFilter<"refreshtoken"> | number
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    revoked?: BoolFilter<"refreshtoken"> | boolean
    revoked_at?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    updated_at?: DateTimeFilter<"refreshtoken"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "token">

  export type refreshtokenOrderByWithAggregationInput = {
    token?: SortOrder
    user_id?: SortOrder
    expires_at?: SortOrder
    revoked?: SortOrder
    revoked_at?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: refreshtokenCountOrderByAggregateInput
    _avg?: refreshtokenAvgOrderByAggregateInput
    _max?: refreshtokenMaxOrderByAggregateInput
    _min?: refreshtokenMinOrderByAggregateInput
    _sum?: refreshtokenSumOrderByAggregateInput
  }

  export type refreshtokenScalarWhereWithAggregatesInput = {
    AND?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    OR?: refreshtokenScalarWhereWithAggregatesInput[]
    NOT?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    token?: StringWithAggregatesFilter<"refreshtoken"> | string
    user_id?: IntWithAggregatesFilter<"refreshtoken"> | number
    expires_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"refreshtoken"> | boolean
    revoked_at?: DateTimeNullableWithAggregatesFilter<"refreshtoken"> | Date | string | null
    id?: IntWithAggregatesFilter<"refreshtoken"> | number
    created_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: StringFilter<"roles"> | string
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: StringWithAggregatesFilter<"roles"> | string
  }

  export type tagWhereInput = {
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    name?: StringFilter<"tag"> | string
    slug?: StringFilter<"tag"> | string
    description?: StringNullableFilter<"tag"> | string | null
    id?: IntFilter<"tag"> | number
    created_at?: DateTimeFilter<"tag"> | Date | string
    updated_at?: DateTimeFilter<"tag"> | Date | string
    article_tags?: Article_tagsListRelationFilter
  }

  export type tagOrderByWithRelationInput = {
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    article_tags?: article_tagsOrderByRelationAggregateInput
  }

  export type tagWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    slug?: string
    id?: number
    AND?: tagWhereInput | tagWhereInput[]
    OR?: tagWhereInput[]
    NOT?: tagWhereInput | tagWhereInput[]
    description?: StringNullableFilter<"tag"> | string | null
    created_at?: DateTimeFilter<"tag"> | Date | string
    updated_at?: DateTimeFilter<"tag"> | Date | string
    article_tags?: Article_tagsListRelationFilter
  }, "id" | "name" | "slug">

  export type tagOrderByWithAggregationInput = {
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tagCountOrderByAggregateInput
    _avg?: tagAvgOrderByAggregateInput
    _max?: tagMaxOrderByAggregateInput
    _min?: tagMinOrderByAggregateInput
    _sum?: tagSumOrderByAggregateInput
  }

  export type tagScalarWhereWithAggregatesInput = {
    AND?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    OR?: tagScalarWhereWithAggregatesInput[]
    NOT?: tagScalarWhereWithAggregatesInput | tagScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"tag"> | string
    slug?: StringWithAggregatesFilter<"tag"> | string
    description?: StringNullableWithAggregatesFilter<"tag"> | string | null
    id?: IntWithAggregatesFilter<"tag"> | number
    created_at?: DateTimeWithAggregatesFilter<"tag"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tag"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    email?: StringFilter<"user"> | string
    username?: StringNullableFilter<"user"> | string | null
    full_name?: StringNullableFilter<"user"> | string | null
    hashed_password?: StringFilter<"user"> | string
    is_active?: BoolFilter<"user"> | boolean
    is_verified?: BoolFilter<"user"> | boolean
    role?: EnumuserroleFilter<"user"> | $Enums.userrole
    bio?: StringNullableFilter<"user"> | string | null
    avatar_url?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    last_login_at?: DateTimeNullableFilter<"user"> | Date | string | null
    last_login_ip?: StringNullableFilter<"user"> | string | null
    failed_login_attempts?: IntFilter<"user"> | number
    locked_until?: DateTimeNullableFilter<"user"> | Date | string | null
    two_factor_enabled?: BoolFilter<"user"> | boolean
    two_factor_secret?: StringNullableFilter<"user"> | string | null
    email_verified_at?: DateTimeNullableFilter<"user"> | Date | string | null
    email_verification_token?: StringNullableFilter<"user"> | string | null
    password_reset_token?: StringNullableFilter<"user"> | string | null
    password_reset_expires?: DateTimeNullableFilter<"user"> | Date | string | null
    id?: IntFilter<"user"> | number
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    is_deleted?: BoolFilter<"user"> | boolean
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    activitylog?: ActivitylogListRelationFilter
    article?: ArticleListRelationFilter
    articlestar?: ArticlestarListRelationFilter
    articleview?: ArticleviewListRelationFilter
    event?: EventListRelationFilter
    eventregistration?: EventregistrationListRelationFilter
    refreshtoken?: RefreshtokenListRelationFilter
    user_permissions?: User_permissionsListRelationFilter
    usersession?: UsersessionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    role?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar_url?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    last_login_ip?: SortOrderInput | SortOrder
    failed_login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    two_factor_enabled?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    password_reset_token?: SortOrderInput | SortOrder
    password_reset_expires?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    activitylog?: activitylogOrderByRelationAggregateInput
    article?: articleOrderByRelationAggregateInput
    articlestar?: articlestarOrderByRelationAggregateInput
    articleview?: articleviewOrderByRelationAggregateInput
    event?: eventOrderByRelationAggregateInput
    eventregistration?: eventregistrationOrderByRelationAggregateInput
    refreshtoken?: refreshtokenOrderByRelationAggregateInput
    user_permissions?: user_permissionsOrderByRelationAggregateInput
    usersession?: usersessionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    username?: string
    id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    full_name?: StringNullableFilter<"user"> | string | null
    hashed_password?: StringFilter<"user"> | string
    is_active?: BoolFilter<"user"> | boolean
    is_verified?: BoolFilter<"user"> | boolean
    role?: EnumuserroleFilter<"user"> | $Enums.userrole
    bio?: StringNullableFilter<"user"> | string | null
    avatar_url?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    last_login_at?: DateTimeNullableFilter<"user"> | Date | string | null
    last_login_ip?: StringNullableFilter<"user"> | string | null
    failed_login_attempts?: IntFilter<"user"> | number
    locked_until?: DateTimeNullableFilter<"user"> | Date | string | null
    two_factor_enabled?: BoolFilter<"user"> | boolean
    two_factor_secret?: StringNullableFilter<"user"> | string | null
    email_verified_at?: DateTimeNullableFilter<"user"> | Date | string | null
    email_verification_token?: StringNullableFilter<"user"> | string | null
    password_reset_token?: StringNullableFilter<"user"> | string | null
    password_reset_expires?: DateTimeNullableFilter<"user"> | Date | string | null
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    is_deleted?: BoolFilter<"user"> | boolean
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    activitylog?: ActivitylogListRelationFilter
    article?: ArticleListRelationFilter
    articlestar?: ArticlestarListRelationFilter
    articleview?: ArticleviewListRelationFilter
    event?: EventListRelationFilter
    eventregistration?: EventregistrationListRelationFilter
    refreshtoken?: RefreshtokenListRelationFilter
    user_permissions?: User_permissionsListRelationFilter
    usersession?: UsersessionListRelationFilter
  }, "id" | "email" | "username">

  export type userOrderByWithAggregationInput = {
    email?: SortOrder
    username?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    role?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatar_url?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    last_login_ip?: SortOrderInput | SortOrder
    failed_login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    two_factor_enabled?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    email_verification_token?: SortOrderInput | SortOrder
    password_reset_token?: SortOrderInput | SortOrder
    password_reset_expires?: SortOrderInput | SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"user"> | string
    username?: StringNullableWithAggregatesFilter<"user"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"user"> | string | null
    hashed_password?: StringWithAggregatesFilter<"user"> | string
    is_active?: BoolWithAggregatesFilter<"user"> | boolean
    is_verified?: BoolWithAggregatesFilter<"user"> | boolean
    role?: EnumuserroleWithAggregatesFilter<"user"> | $Enums.userrole
    bio?: StringNullableWithAggregatesFilter<"user"> | string | null
    avatar_url?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"user"> | string | null
    last_login_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    last_login_ip?: StringNullableWithAggregatesFilter<"user"> | string | null
    failed_login_attempts?: IntWithAggregatesFilter<"user"> | number
    locked_until?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    two_factor_enabled?: BoolWithAggregatesFilter<"user"> | boolean
    two_factor_secret?: StringNullableWithAggregatesFilter<"user"> | string | null
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    email_verification_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    password_reset_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    password_reset_expires?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    id?: IntWithAggregatesFilter<"user"> | number
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"user"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type user_activityWhereInput = {
    AND?: user_activityWhereInput | user_activityWhereInput[]
    OR?: user_activityWhereInput[]
    NOT?: user_activityWhereInput | user_activityWhereInput[]
    id?: IntFilter<"user_activity"> | number
    user_id?: IntFilter<"user_activity"> | number
    action?: StringFilter<"user_activity"> | string
    resource_type?: StringNullableFilter<"user_activity"> | string | null
    resource_id?: IntNullableFilter<"user_activity"> | number | null
    details?: StringNullableFilter<"user_activity"> | string | null
    ip_address?: StringNullableFilter<"user_activity"> | string | null
    user_agent?: StringNullableFilter<"user_activity"> | string | null
    timestamp?: DateTimeNullableFilter<"user_activity"> | Date | string | null
    created_at?: DateTimeNullableFilter<"user_activity"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_activityOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource_type?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_activityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_activityWhereInput | user_activityWhereInput[]
    OR?: user_activityWhereInput[]
    NOT?: user_activityWhereInput | user_activityWhereInput[]
    user_id?: IntFilter<"user_activity"> | number
    action?: StringFilter<"user_activity"> | string
    resource_type?: StringNullableFilter<"user_activity"> | string | null
    resource_id?: IntNullableFilter<"user_activity"> | number | null
    details?: StringNullableFilter<"user_activity"> | string | null
    ip_address?: StringNullableFilter<"user_activity"> | string | null
    user_agent?: StringNullableFilter<"user_activity"> | string | null
    timestamp?: DateTimeNullableFilter<"user_activity"> | Date | string | null
    created_at?: DateTimeNullableFilter<"user_activity"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type user_activityOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource_type?: SortOrderInput | SortOrder
    resource_id?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: user_activityCountOrderByAggregateInput
    _avg?: user_activityAvgOrderByAggregateInput
    _max?: user_activityMaxOrderByAggregateInput
    _min?: user_activityMinOrderByAggregateInput
    _sum?: user_activitySumOrderByAggregateInput
  }

  export type user_activityScalarWhereWithAggregatesInput = {
    AND?: user_activityScalarWhereWithAggregatesInput | user_activityScalarWhereWithAggregatesInput[]
    OR?: user_activityScalarWhereWithAggregatesInput[]
    NOT?: user_activityScalarWhereWithAggregatesInput | user_activityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_activity"> | number
    user_id?: IntWithAggregatesFilter<"user_activity"> | number
    action?: StringWithAggregatesFilter<"user_activity"> | string
    resource_type?: StringNullableWithAggregatesFilter<"user_activity"> | string | null
    resource_id?: IntNullableWithAggregatesFilter<"user_activity"> | number | null
    details?: StringNullableWithAggregatesFilter<"user_activity"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"user_activity"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"user_activity"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"user_activity"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user_activity"> | Date | string | null
  }

  export type user_alertsWhereInput = {
    AND?: user_alertsWhereInput | user_alertsWhereInput[]
    OR?: user_alertsWhereInput[]
    NOT?: user_alertsWhereInput | user_alertsWhereInput[]
    id?: IntFilter<"user_alerts"> | number
    email?: StringFilter<"user_alerts"> | string
    sources?: StringNullableFilter<"user_alerts"> | string | null
    sectors?: StringNullableFilter<"user_alerts"> | string | null
    created_at?: DateTimeNullableFilter<"user_alerts"> | Date | string | null
  }

  export type user_alertsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    sources?: SortOrderInput | SortOrder
    sectors?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type user_alertsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_alertsWhereInput | user_alertsWhereInput[]
    OR?: user_alertsWhereInput[]
    NOT?: user_alertsWhereInput | user_alertsWhereInput[]
    email?: StringFilter<"user_alerts"> | string
    sources?: StringNullableFilter<"user_alerts"> | string | null
    sectors?: StringNullableFilter<"user_alerts"> | string | null
    created_at?: DateTimeNullableFilter<"user_alerts"> | Date | string | null
  }, "id">

  export type user_alertsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    sources?: SortOrderInput | SortOrder
    sectors?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: user_alertsCountOrderByAggregateInput
    _avg?: user_alertsAvgOrderByAggregateInput
    _max?: user_alertsMaxOrderByAggregateInput
    _min?: user_alertsMinOrderByAggregateInput
    _sum?: user_alertsSumOrderByAggregateInput
  }

  export type user_alertsScalarWhereWithAggregatesInput = {
    AND?: user_alertsScalarWhereWithAggregatesInput | user_alertsScalarWhereWithAggregatesInput[]
    OR?: user_alertsScalarWhereWithAggregatesInput[]
    NOT?: user_alertsScalarWhereWithAggregatesInput | user_alertsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_alerts"> | number
    email?: StringWithAggregatesFilter<"user_alerts"> | string
    sources?: StringNullableWithAggregatesFilter<"user_alerts"> | string | null
    sectors?: StringNullableWithAggregatesFilter<"user_alerts"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user_alerts"> | Date | string | null
  }

  export type user_article_starsWhereInput = {
    AND?: user_article_starsWhereInput | user_article_starsWhereInput[]
    OR?: user_article_starsWhereInput[]
    NOT?: user_article_starsWhereInput | user_article_starsWhereInput[]
    id?: IntFilter<"user_article_stars"> | number
    user_id?: IntFilter<"user_article_stars"> | number
    article_id?: IntFilter<"user_article_stars"> | number
    starred_at?: DateTimeFilter<"user_article_stars"> | Date | string
    credit_articles?: XOR<Credit_articlesRelationFilter, credit_articlesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_article_starsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
    starred_at?: SortOrder
    credit_articles?: credit_articlesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type user_article_starsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_article_starsWhereInput | user_article_starsWhereInput[]
    OR?: user_article_starsWhereInput[]
    NOT?: user_article_starsWhereInput | user_article_starsWhereInput[]
    user_id?: IntFilter<"user_article_stars"> | number
    article_id?: IntFilter<"user_article_stars"> | number
    starred_at?: DateTimeFilter<"user_article_stars"> | Date | string
    credit_articles?: XOR<Credit_articlesRelationFilter, credit_articlesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type user_article_starsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
    starred_at?: SortOrder
    _count?: user_article_starsCountOrderByAggregateInput
    _avg?: user_article_starsAvgOrderByAggregateInput
    _max?: user_article_starsMaxOrderByAggregateInput
    _min?: user_article_starsMinOrderByAggregateInput
    _sum?: user_article_starsSumOrderByAggregateInput
  }

  export type user_article_starsScalarWhereWithAggregatesInput = {
    AND?: user_article_starsScalarWhereWithAggregatesInput | user_article_starsScalarWhereWithAggregatesInput[]
    OR?: user_article_starsScalarWhereWithAggregatesInput[]
    NOT?: user_article_starsScalarWhereWithAggregatesInput | user_article_starsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_article_stars"> | number
    user_id?: IntWithAggregatesFilter<"user_article_stars"> | number
    article_id?: IntWithAggregatesFilter<"user_article_stars"> | number
    starred_at?: DateTimeWithAggregatesFilter<"user_article_stars"> | Date | string
  }

  export type user_eventsWhereInput = {
    AND?: user_eventsWhereInput | user_eventsWhereInput[]
    OR?: user_eventsWhereInput[]
    NOT?: user_eventsWhereInput | user_eventsWhereInput[]
    id?: IntFilter<"user_events"> | number
    user_email?: StringFilter<"user_events"> | string
    event_id?: IntFilter<"user_events"> | number
    event_title?: StringFilter<"user_events"> | string
    event_date?: DateTimeFilter<"user_events"> | Date | string
    event_link?: StringNullableFilter<"user_events"> | string | null
    created_at?: DateTimeNullableFilter<"user_events"> | Date | string | null
  }

  export type user_eventsOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    event_id?: SortOrder
    event_title?: SortOrder
    event_date?: SortOrder
    event_link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type user_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_eventsWhereInput | user_eventsWhereInput[]
    OR?: user_eventsWhereInput[]
    NOT?: user_eventsWhereInput | user_eventsWhereInput[]
    user_email?: StringFilter<"user_events"> | string
    event_id?: IntFilter<"user_events"> | number
    event_title?: StringFilter<"user_events"> | string
    event_date?: DateTimeFilter<"user_events"> | Date | string
    event_link?: StringNullableFilter<"user_events"> | string | null
    created_at?: DateTimeNullableFilter<"user_events"> | Date | string | null
  }, "id">

  export type user_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    event_id?: SortOrder
    event_title?: SortOrder
    event_date?: SortOrder
    event_link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: user_eventsCountOrderByAggregateInput
    _avg?: user_eventsAvgOrderByAggregateInput
    _max?: user_eventsMaxOrderByAggregateInput
    _min?: user_eventsMinOrderByAggregateInput
    _sum?: user_eventsSumOrderByAggregateInput
  }

  export type user_eventsScalarWhereWithAggregatesInput = {
    AND?: user_eventsScalarWhereWithAggregatesInput | user_eventsScalarWhereWithAggregatesInput[]
    OR?: user_eventsScalarWhereWithAggregatesInput[]
    NOT?: user_eventsScalarWhereWithAggregatesInput | user_eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_events"> | number
    user_email?: StringWithAggregatesFilter<"user_events"> | string
    event_id?: IntWithAggregatesFilter<"user_events"> | number
    event_title?: StringWithAggregatesFilter<"user_events"> | string
    event_date?: DateTimeWithAggregatesFilter<"user_events"> | Date | string
    event_link?: StringNullableWithAggregatesFilter<"user_events"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user_events"> | Date | string | null
  }

  export type user_permissionsWhereInput = {
    AND?: user_permissionsWhereInput | user_permissionsWhereInput[]
    OR?: user_permissionsWhereInput[]
    NOT?: user_permissionsWhereInput | user_permissionsWhereInput[]
    user_id?: IntFilter<"user_permissions"> | number
    permission_id?: IntFilter<"user_permissions"> | number
    permission?: XOR<PermissionRelationFilter, permissionWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_permissionsOrderByWithRelationInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
    permission?: permissionOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type user_permissionsWhereUniqueInput = Prisma.AtLeast<{
    user_id_permission_id?: user_permissionsUser_idPermission_idCompoundUniqueInput
    AND?: user_permissionsWhereInput | user_permissionsWhereInput[]
    OR?: user_permissionsWhereInput[]
    NOT?: user_permissionsWhereInput | user_permissionsWhereInput[]
    user_id?: IntFilter<"user_permissions"> | number
    permission_id?: IntFilter<"user_permissions"> | number
    permission?: XOR<PermissionRelationFilter, permissionWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "user_id_permission_id">

  export type user_permissionsOrderByWithAggregationInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
    _count?: user_permissionsCountOrderByAggregateInput
    _avg?: user_permissionsAvgOrderByAggregateInput
    _max?: user_permissionsMaxOrderByAggregateInput
    _min?: user_permissionsMinOrderByAggregateInput
    _sum?: user_permissionsSumOrderByAggregateInput
  }

  export type user_permissionsScalarWhereWithAggregatesInput = {
    AND?: user_permissionsScalarWhereWithAggregatesInput | user_permissionsScalarWhereWithAggregatesInput[]
    OR?: user_permissionsScalarWhereWithAggregatesInput[]
    NOT?: user_permissionsScalarWhereWithAggregatesInput | user_permissionsScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user_permissions"> | number
    permission_id?: IntWithAggregatesFilter<"user_permissions"> | number
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    is_active?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    activity_logs?: Activity_logsListRelationFilter
    ai_assistant_config?: Ai_assistant_configListRelationFilter
    ai_conversations?: Ai_conversationsListRelationFilter
    ai_entity_memory?: Ai_entity_memoryListRelationFilter
    ai_session_memory?: Ai_session_memoryListRelationFilter
    newsletter_subscriptions?: Newsletter_subscriptionsListRelationFilter
    user_activity?: User_activityListRelationFilter
    user_article_stars?: User_article_starsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    activity_logs?: activity_logsOrderByRelationAggregateInput
    ai_assistant_config?: ai_assistant_configOrderByRelationAggregateInput
    ai_conversations?: ai_conversationsOrderByRelationAggregateInput
    ai_entity_memory?: ai_entity_memoryOrderByRelationAggregateInput
    ai_session_memory?: ai_session_memoryOrderByRelationAggregateInput
    newsletter_subscriptions?: newsletter_subscriptionsOrderByRelationAggregateInput
    user_activity?: user_activityOrderByRelationAggregateInput
    user_article_stars?: user_article_starsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    is_active?: BoolFilter<"users"> | boolean
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    activity_logs?: Activity_logsListRelationFilter
    ai_assistant_config?: Ai_assistant_configListRelationFilter
    ai_conversations?: Ai_conversationsListRelationFilter
    ai_entity_memory?: Ai_entity_memoryListRelationFilter
    ai_session_memory?: Ai_session_memoryListRelationFilter
    newsletter_subscriptions?: Newsletter_subscriptionsListRelationFilter
    user_activity?: User_activityListRelationFilter
    user_article_stars?: User_article_starsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    role?: StringWithAggregatesFilter<"users"> | string
    is_active?: BoolWithAggregatesFilter<"users"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type usersessionWhereInput = {
    AND?: usersessionWhereInput | usersessionWhereInput[]
    OR?: usersessionWhereInput[]
    NOT?: usersessionWhereInput | usersessionWhereInput[]
    user_id?: IntFilter<"usersession"> | number
    session_id?: StringFilter<"usersession"> | string
    ip_address?: StringNullableFilter<"usersession"> | string | null
    user_agent?: StringNullableFilter<"usersession"> | string | null
    last_activity?: DateTimeFilter<"usersession"> | Date | string
    expires_at?: DateTimeFilter<"usersession"> | Date | string
    id?: IntFilter<"usersession"> | number
    created_at?: DateTimeFilter<"usersession"> | Date | string
    updated_at?: DateTimeFilter<"usersession"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type usersessionOrderByWithRelationInput = {
    user_id?: SortOrder
    session_id?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    last_activity?: SortOrder
    expires_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type usersessionWhereUniqueInput = Prisma.AtLeast<{
    session_id?: string
    id?: number
    AND?: usersessionWhereInput | usersessionWhereInput[]
    OR?: usersessionWhereInput[]
    NOT?: usersessionWhereInput | usersessionWhereInput[]
    user_id?: IntFilter<"usersession"> | number
    ip_address?: StringNullableFilter<"usersession"> | string | null
    user_agent?: StringNullableFilter<"usersession"> | string | null
    last_activity?: DateTimeFilter<"usersession"> | Date | string
    expires_at?: DateTimeFilter<"usersession"> | Date | string
    created_at?: DateTimeFilter<"usersession"> | Date | string
    updated_at?: DateTimeFilter<"usersession"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "session_id">

  export type usersessionOrderByWithAggregationInput = {
    user_id?: SortOrder
    session_id?: SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    last_activity?: SortOrder
    expires_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usersessionCountOrderByAggregateInput
    _avg?: usersessionAvgOrderByAggregateInput
    _max?: usersessionMaxOrderByAggregateInput
    _min?: usersessionMinOrderByAggregateInput
    _sum?: usersessionSumOrderByAggregateInput
  }

  export type usersessionScalarWhereWithAggregatesInput = {
    AND?: usersessionScalarWhereWithAggregatesInput | usersessionScalarWhereWithAggregatesInput[]
    OR?: usersessionScalarWhereWithAggregatesInput[]
    NOT?: usersessionScalarWhereWithAggregatesInput | usersessionScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"usersession"> | number
    session_id?: StringWithAggregatesFilter<"usersession"> | string
    ip_address?: StringNullableWithAggregatesFilter<"usersession"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"usersession"> | string | null
    last_activity?: DateTimeWithAggregatesFilter<"usersession"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"usersession"> | Date | string
    id?: IntWithAggregatesFilter<"usersession"> | number
    created_at?: DateTimeWithAggregatesFilter<"usersession"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"usersession"> | Date | string
  }

  export type activity_logsCreateInput = {
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
    users?: usersCreateNestedOneWithoutActivity_logsInput
  }

  export type activity_logsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
  }

  export type activity_logsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutActivity_logsNestedInput
  }

  export type activity_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logsCreateManyInput = {
    id?: number
    user_id?: number | null
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
  }

  export type activity_logsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activitylogCreateInput = {
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: userCreateNestedOneWithoutActivitylogInput
  }

  export type activitylogUncheckedCreateInput = {
    user_id?: number | null
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activitylogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutActivitylogNestedInput
  }

  export type activitylogUncheckedUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogCreateManyInput = {
    user_id?: number | null
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activitylogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateManyInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ai_assistant_configCreateInput = {
    config_key: string
    config_value: string
    updated_at?: Date | string | null
    users?: usersCreateNestedOneWithoutAi_assistant_configInput
  }

  export type ai_assistant_configUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    config_key: string
    config_value: string
    updated_at?: Date | string | null
  }

  export type ai_assistant_configUpdateInput = {
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutAi_assistant_configNestedInput
  }

  export type ai_assistant_configUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_assistant_configCreateManyInput = {
    id?: number
    user_id?: number | null
    config_key: string
    config_value: string
    updated_at?: Date | string | null
  }

  export type ai_assistant_configUpdateManyMutationInput = {
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_assistant_configUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsCreateInput = {
    session_id: string
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users?: usersCreateNestedOneWithoutAi_conversationsInput
  }

  export type ai_conversationsUncheckedCreateInput = {
    id?: number
    session_id: string
    user_id?: number | null
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_conversationsUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutAi_conversationsNestedInput
  }

  export type ai_conversationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsCreateManyInput = {
    id?: number
    session_id: string
    user_id?: number | null
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_conversationsUpdateManyMutationInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryCreateInput = {
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users?: usersCreateNestedOneWithoutAi_entity_memoryInput
  }

  export type ai_entity_memoryUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_entity_memoryUpdateInput = {
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutAi_entity_memoryNestedInput
  }

  export type ai_entity_memoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryCreateManyInput = {
    id?: number
    user_id?: number | null
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_entity_memoryUpdateManyMutationInput = {
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_knowledge_baseCreateInput = {
    knowledge_type: string
    topic: string
    title: string
    content: string
    source?: string | null
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    usage_count?: number | null
    last_used?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_knowledge_baseUncheckedCreateInput = {
    id?: number
    knowledge_type: string
    topic: string
    title: string
    content: string
    source?: string | null
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    usage_count?: number | null
    last_used?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_knowledge_baseUpdateInput = {
    knowledge_type?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usage_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_knowledge_baseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    knowledge_type?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usage_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_knowledge_baseCreateManyInput = {
    id?: number
    knowledge_type: string
    topic: string
    title: string
    content: string
    source?: string | null
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    usage_count?: number | null
    last_used?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_knowledge_baseUpdateManyMutationInput = {
    knowledge_type?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usage_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_knowledge_baseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    knowledge_type?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    usage_count?: NullableIntFieldUpdateOperationsInput | number | null
    last_used?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryCreateInput = {
    session_id: string
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
    users?: usersCreateNestedOneWithoutAi_session_memoryInput
  }

  export type ai_session_memoryUncheckedCreateInput = {
    id?: number
    session_id: string
    user_id?: number | null
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type ai_session_memoryUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutAi_session_memoryNestedInput
  }

  export type ai_session_memoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryCreateManyInput = {
    id?: number
    session_id: string
    user_id?: number | null
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type ai_session_memoryUpdateManyMutationInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type articleCreateInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutArticleInput
    article_tags?: article_tagsCreateNestedManyWithoutArticleInput
    articlestar?: articlestarCreateNestedManyWithoutArticleInput
    articleview?: articleviewCreateNestedManyWithoutArticleInput
  }

  export type articleUncheckedCreateInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_id?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article_tags?: article_tagsUncheckedCreateNestedManyWithoutArticleInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutArticleInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutArticleInput
  }

  export type articleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutArticleNestedInput
    article_tags?: article_tagsUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article_tags?: article_tagsUncheckedUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type articleCreateManyInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_id?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type articleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type articleUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type article_tagsCreateInput = {
    article: articleCreateNestedOneWithoutArticle_tagsInput
    tag: tagCreateNestedOneWithoutArticle_tagsInput
  }

  export type article_tagsUncheckedCreateInput = {
    article_id: number
    tag_id: number
  }

  export type article_tagsUpdateInput = {
    article?: articleUpdateOneRequiredWithoutArticle_tagsNestedInput
    tag?: tagUpdateOneRequiredWithoutArticle_tagsNestedInput
  }

  export type article_tagsUncheckedUpdateInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type article_tagsCreateManyInput = {
    article_id: number
    tag_id: number
  }

  export type article_tagsUpdateManyMutationInput = {

  }

  export type article_tagsUncheckedUpdateManyInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type articlestarCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    article: articleCreateNestedOneWithoutArticlestarInput
    user: userCreateNestedOneWithoutArticlestarInput
  }

  export type articlestarUncheckedCreateInput = {
    user_id: number
    article_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articlestarUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: articleUpdateOneRequiredWithoutArticlestarNestedInput
    user?: userUpdateOneRequiredWithoutArticlestarNestedInput
  }

  export type articlestarUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlestarCreateManyInput = {
    user_id: number
    article_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articlestarUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlestarUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewCreateInput = {
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    article: articleCreateNestedOneWithoutArticleviewInput
    user?: userCreateNestedOneWithoutArticleviewInput
  }

  export type articleviewUncheckedCreateInput = {
    article_id: number
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewUpdateInput = {
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: articleUpdateOneRequiredWithoutArticleviewNestedInput
    user?: userUpdateOneWithoutArticleviewNestedInput
  }

  export type articleviewUncheckedUpdateInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewCreateManyInput = {
    article_id: number
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewUpdateManyMutationInput = {
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewUncheckedUpdateManyInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type credit_articlesCreateInput = {
    title?: string | null
    date?: Date | string | null
    content?: string | null
    link?: string | null
    source?: string | null
    matched_keywords?: string | null
    region?: string | null
    sector?: string | null
    starred?: boolean | null
    starred_at?: Date | string | null
    summary?: string | null
    url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_article_stars?: user_article_starsCreateNestedManyWithoutCredit_articlesInput
  }

  export type credit_articlesUncheckedCreateInput = {
    id?: number
    title?: string | null
    date?: Date | string | null
    content?: string | null
    link?: string | null
    source?: string | null
    matched_keywords?: string | null
    region?: string | null
    sector?: string | null
    starred?: boolean | null
    starred_at?: Date | string | null
    summary?: string | null
    url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutCredit_articlesInput
  }

  export type credit_articlesUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_article_stars?: user_article_starsUpdateManyWithoutCredit_articlesNestedInput
  }

  export type credit_articlesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutCredit_articlesNestedInput
  }

  export type credit_articlesCreateManyInput = {
    id?: number
    title?: string | null
    date?: Date | string | null
    content?: string | null
    link?: string | null
    source?: string | null
    matched_keywords?: string | null
    region?: string | null
    sector?: string | null
    starred?: boolean | null
    starred_at?: Date | string | null
    summary?: string | null
    url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type credit_articlesUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type credit_articlesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_alertsCreateInput = {
    email: string
    alert_type: string
    subscription_date?: Date | string
    active?: boolean
  }

  export type email_alertsUncheckedCreateInput = {
    id?: number
    email: string
    alert_type: string
    subscription_date?: Date | string
    active?: boolean
  }

  export type email_alertsUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    alert_type?: StringFieldUpdateOperationsInput | string
    subscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type email_alertsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    alert_type?: StringFieldUpdateOperationsInput | string
    subscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type email_alertsCreateManyInput = {
    id?: number
    email: string
    alert_type: string
    subscription_date?: Date | string
    active?: boolean
  }

  export type email_alertsUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    alert_type?: StringFieldUpdateOperationsInput | string
    subscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type email_alertsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    alert_type?: StringFieldUpdateOperationsInput | string
    subscription_date?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type eventCreateInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    view_count: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutEventInput
    eventregistration?: eventregistrationCreateNestedManyWithoutEventInput
  }

  export type eventUncheckedCreateInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    created_by_id?: number | null
    view_count: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutEventNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutEventNestedInput
  }

  export type eventUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    view_count?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type eventCreateManyInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    created_by_id?: number | null
    view_count: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type eventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    view_count?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventregistrationCreateInput = {
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    event: eventCreateNestedOneWithoutEventregistrationInput
    user: userCreateNestedOneWithoutEventregistrationInput
  }

  export type eventregistrationUncheckedCreateInput = {
    event_id: number
    user_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventregistrationUpdateInput = {
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventUpdateOneRequiredWithoutEventregistrationNestedInput
    user?: userUpdateOneRequiredWithoutEventregistrationNestedInput
  }

  export type eventregistrationUncheckedUpdateInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventregistrationCreateManyInput = {
    event_id: number
    user_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventregistrationUpdateManyMutationInput = {
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventregistrationUncheckedUpdateManyInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsCreateInput = {
    title: string
    date?: Date | string | null
    location?: string | null
    details?: string | null
    link?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type eventsUncheckedCreateInput = {
    id?: number
    title: string
    date?: Date | string | null
    location?: string | null
    details?: string | null
    link?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type eventsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsCreateManyInput = {
    id?: number
    title: string
    date?: Date | string | null
    location?: string | null
    details?: string | null
    link?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type eventsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type methodologiesCreateInput = {
    title?: string | null
    published_date?: Date | string | null
    abstract?: string | null
    description?: string | null
    link?: string | null
    source?: string | null
    permalink?: string | null
    created_at?: Date | string | null
    report_url?: string | null
  }

  export type methodologiesUncheckedCreateInput = {
    id?: number
    title?: string | null
    published_date?: Date | string | null
    abstract?: string | null
    description?: string | null
    link?: string | null
    source?: string | null
    permalink?: string | null
    created_at?: Date | string | null
    report_url?: string | null
  }

  export type methodologiesUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    report_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type methodologiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    report_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type methodologiesCreateManyInput = {
    id?: number
    title?: string | null
    published_date?: Date | string | null
    abstract?: string | null
    description?: string | null
    link?: string | null
    source?: string | null
    permalink?: string | null
    created_at?: Date | string | null
    report_url?: string | null
  }

  export type methodologiesUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    report_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type methodologiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    permalink?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    report_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_logsCreateInput = {
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
    newsletter_subscriptions: newsletter_subscriptionsCreateNestedOneWithoutNewsletter_logsInput
  }

  export type newsletter_logsUncheckedCreateInput = {
    id?: number
    subscription_id: number
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
  }

  export type newsletter_logsUpdateInput = {
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter_subscriptions?: newsletter_subscriptionsUpdateOneRequiredWithoutNewsletter_logsNestedInput
  }

  export type newsletter_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_logsCreateManyInput = {
    id?: number
    subscription_id: number
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
  }

  export type newsletter_logsUpdateManyMutationInput = {
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_preferencesCreateInput = {
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_subscriptions: newsletter_subscriptionsCreateNestedOneWithoutNewsletter_preferencesInput
  }

  export type newsletter_preferencesUncheckedCreateInput = {
    id?: number
    subscription_id: number
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_preferencesUpdateInput = {
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_subscriptions?: newsletter_subscriptionsUpdateOneRequiredWithoutNewsletter_preferencesNestedInput
  }

  export type newsletter_preferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_preferencesCreateManyInput = {
    id?: number
    subscription_id: number
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_preferencesUpdateManyMutationInput = {
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_preferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_id?: IntFieldUpdateOperationsInput | number
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_subscriptionsCreateInput = {
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsCreateNestedManyWithoutNewsletter_subscriptionsInput
    newsletter_preferences?: newsletter_preferencesCreateNestedManyWithoutNewsletter_subscriptionsInput
    users: usersCreateNestedOneWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsUncheckedCreateInput = {
    id?: number
    user_id: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
    newsletter_preferences?: newsletter_preferencesUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsUpdateInput = {
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUpdateManyWithoutNewsletter_subscriptionsNestedInput
    newsletter_preferences?: newsletter_preferencesUpdateManyWithoutNewsletter_subscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
    newsletter_preferences?: newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsCreateManyInput = {
    id?: number
    user_id: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_subscriptionsUpdateManyMutationInput = {
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_subscriptionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionCreateInput = {
    name: $Enums.permissiontype
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user_permissions?: user_permissionsCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    name: $Enums.permissiontype
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionUpdateInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_permissions?: user_permissionsUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionCreateManyInput = {
    name: $Enums.permissiontype
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type permissionUpdateManyMutationInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionUncheckedUpdateManyInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type publicationsCreateInput = {
    title?: string | null
    date?: Date | string | null
    description?: string | null
    link?: string | null
    image_url?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type publicationsUncheckedCreateInput = {
    id?: number
    title?: string | null
    date?: Date | string | null
    description?: string | null
    link?: string | null
    image_url?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type publicationsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type publicationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type publicationsCreateManyInput = {
    id?: number
    title?: string | null
    date?: Date | string | null
    description?: string | null
    link?: string | null
    image_url?: string | null
    source?: string | null
    created_at?: Date | string | null
  }

  export type publicationsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type publicationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenCreateInput = {
    token: string
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutRefreshtokenInput
  }

  export type refreshtokenUncheckedCreateInput = {
    token: string
    user_id: number
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type refreshtokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRefreshtokenNestedInput
  }

  export type refreshtokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenCreateManyInput = {
    token: string
    user_id: number
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type refreshtokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesCreateInput = {
    name: string
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesCreateManyInput = {
    id?: number
    name: string
  }

  export type rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tagCreateInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    article_tags?: article_tagsCreateNestedManyWithoutTagInput
  }

  export type tagUncheckedCreateInput = {
    name: string
    slug: string
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    article_tags?: article_tagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type tagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article_tags?: article_tagsUpdateManyWithoutTagNestedInput
  }

  export type tagUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article_tags?: article_tagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type tagCreateManyInput = {
    name: string
    slug: string
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityCreateInput = {
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
    users: usersCreateNestedOneWithoutUser_activityInput
  }

  export type user_activityUncheckedCreateInput = {
    id?: number
    user_id: number
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
  }

  export type user_activityUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUser_activityNestedInput
  }

  export type user_activityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityCreateManyInput = {
    id?: number
    user_id: number
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
  }

  export type user_activityUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_alertsCreateInput = {
    email: string
    sources?: string | null
    sectors?: string | null
    created_at?: Date | string | null
  }

  export type user_alertsUncheckedCreateInput = {
    id?: number
    email: string
    sources?: string | null
    sectors?: string | null
    created_at?: Date | string | null
  }

  export type user_alertsUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sectors?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_alertsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sectors?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_alertsCreateManyInput = {
    id?: number
    email: string
    sources?: string | null
    sectors?: string | null
    created_at?: Date | string | null
  }

  export type user_alertsUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sectors?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_alertsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sectors?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_article_starsCreateInput = {
    starred_at?: Date | string
    credit_articles: credit_articlesCreateNestedOneWithoutUser_article_starsInput
    users: usersCreateNestedOneWithoutUser_article_starsInput
  }

  export type user_article_starsUncheckedCreateInput = {
    id?: number
    user_id: number
    article_id: number
    starred_at?: Date | string
  }

  export type user_article_starsUpdateInput = {
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
    credit_articles?: credit_articlesUpdateOneRequiredWithoutUser_article_starsNestedInput
    users?: usersUpdateOneRequiredWithoutUser_article_starsNestedInput
  }

  export type user_article_starsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_article_starsCreateManyInput = {
    id?: number
    user_id: number
    article_id: number
    starred_at?: Date | string
  }

  export type user_article_starsUpdateManyMutationInput = {
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_article_starsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_eventsCreateInput = {
    user_email: string
    event_id: number
    event_title: string
    event_date: Date | string
    event_link?: string | null
    created_at?: Date | string | null
  }

  export type user_eventsUncheckedCreateInput = {
    id?: number
    user_email: string
    event_id: number
    event_title: string
    event_date: Date | string
    event_link?: string | null
    created_at?: Date | string | null
  }

  export type user_eventsUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_title?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_title?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_eventsCreateManyInput = {
    id?: number
    user_email: string
    event_id: number
    event_title: string
    event_date: Date | string
    event_link?: string | null
    created_at?: Date | string | null
  }

  export type user_eventsUpdateManyMutationInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_title?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    event_title?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_permissionsCreateInput = {
    permission: permissionCreateNestedOneWithoutUser_permissionsInput
    user: userCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateInput = {
    user_id: number
    permission_id: number
  }

  export type user_permissionsUpdateInput = {
    permission?: permissionUpdateOneRequiredWithoutUser_permissionsNestedInput
    user?: userUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_permissionsCreateManyInput = {
    user_id: number
    permission_id: number
  }

  export type user_permissionsUpdateManyMutationInput = {

  }

  export type user_permissionsUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersessionCreateInput = {
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutUsersessionInput
  }

  export type usersessionUncheckedCreateInput = {
    user_id: number
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersessionUpdateInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUsersessionNestedInput
  }

  export type usersessionUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersessionCreateManyInput = {
    user_id: number
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersessionUpdateManyMutationInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersessionUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activity_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    timestamp?: SortOrder
  }

  export type activity_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type activity_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    timestamp?: SortOrder
  }

  export type activity_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    timestamp?: SortOrder
  }

  export type activity_logsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type activitylogCountOrderByAggregateInput = {
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    error?: SortOrder
    request_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activitylogAvgOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type activitylogMaxOrderByAggregateInput = {
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    error?: SortOrder
    request_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activitylogMinOrderByAggregateInput = {
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status?: SortOrder
    error?: SortOrder
    request_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type activitylogSumOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ai_assistant_configUser_idConfig_keyCompoundUniqueInput = {
    user_id: number
    config_key: string
  }

  export type ai_assistant_configCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    config_key?: SortOrder
    config_value?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_assistant_configAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ai_assistant_configMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    config_key?: SortOrder
    config_value?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_assistant_configMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    config_key?: SortOrder
    config_value?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_assistant_configSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ai_conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    total_messages?: SortOrder
    tokens_used?: SortOrder
    cost_usd?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_conversationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    total_messages?: SortOrder
    tokens_used?: SortOrder
    cost_usd?: SortOrder
  }

  export type ai_conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    total_messages?: SortOrder
    tokens_used?: SortOrder
    cost_usd?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    total_messages?: SortOrder
    tokens_used?: SortOrder
    cost_usd?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_conversationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    total_messages?: SortOrder
    tokens_used?: SortOrder
    cost_usd?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ai_entity_memoryUser_idEntity_typeEntity_keyCompoundUniqueInput = {
    user_id: number
    entity_type: string
    entity_key: string
  }

  export type ai_entity_memoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    entity_type?: SortOrder
    entity_key?: SortOrder
    entity_data?: SortOrder
    confidence_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_entity_memoryAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    confidence_score?: SortOrder
  }

  export type ai_entity_memoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    entity_type?: SortOrder
    entity_key?: SortOrder
    confidence_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_entity_memoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    entity_type?: SortOrder
    entity_key?: SortOrder
    confidence_score?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_entity_memorySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    confidence_score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ai_knowledge_baseCountOrderByAggregateInput = {
    id?: SortOrder
    knowledge_type?: SortOrder
    topic?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    confidence_score?: SortOrder
    usage_count?: SortOrder
    last_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_knowledge_baseAvgOrderByAggregateInput = {
    id?: SortOrder
    confidence_score?: SortOrder
    usage_count?: SortOrder
  }

  export type ai_knowledge_baseMaxOrderByAggregateInput = {
    id?: SortOrder
    knowledge_type?: SortOrder
    topic?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    confidence_score?: SortOrder
    usage_count?: SortOrder
    last_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_knowledge_baseMinOrderByAggregateInput = {
    id?: SortOrder
    knowledge_type?: SortOrder
    topic?: SortOrder
    title?: SortOrder
    content?: SortOrder
    source?: SortOrder
    confidence_score?: SortOrder
    usage_count?: SortOrder
    last_used?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ai_knowledge_baseSumOrderByAggregateInput = {
    id?: SortOrder
    confidence_score?: SortOrder
    usage_count?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ai_session_memoryCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    message_index?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_session_memoryAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message_index?: SortOrder
  }

  export type ai_session_memoryMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    message_index?: SortOrder
    role?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_session_memoryMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
    message_index?: SortOrder
    role?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
  }

  export type ai_session_memorySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message_index?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Article_tagsListRelationFilter = {
    every?: article_tagsWhereInput
    some?: article_tagsWhereInput
    none?: article_tagsWhereInput
  }

  export type ArticlestarListRelationFilter = {
    every?: articlestarWhereInput
    some?: articlestarWhereInput
    none?: articlestarWhereInput
  }

  export type ArticleviewListRelationFilter = {
    every?: articleviewWhereInput
    some?: articleviewWhereInput
    none?: articleviewWhereInput
  }

  export type article_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type articlestarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type articleviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type articleCountOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    published_at?: SortOrder
    category?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    keywords?: SortOrder
    sentiment_score?: SortOrder
    relevance_score?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    ai_summary?: SortOrder
    ai_summary_provider?: SortOrder
    ai_summary_generated_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type articleAvgOrderByAggregateInput = {
    sentiment_score?: SortOrder
    relevance_score?: SortOrder
    author_id?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    id?: SortOrder
  }

  export type articleMaxOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    published_at?: SortOrder
    category?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    sentiment_score?: SortOrder
    relevance_score?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    ai_summary?: SortOrder
    ai_summary_provider?: SortOrder
    ai_summary_generated_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type articleMinOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    published_at?: SortOrder
    category?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    sentiment_score?: SortOrder
    relevance_score?: SortOrder
    author_id?: SortOrder
    author_name?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    ai_summary?: SortOrder
    ai_summary_provider?: SortOrder
    ai_summary_generated_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type articleSumOrderByAggregateInput = {
    sentiment_score?: SortOrder
    relevance_score?: SortOrder
    author_id?: SortOrder
    view_count?: SortOrder
    unique_viewers?: SortOrder
    id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ArticleRelationFilter = {
    is?: articleWhereInput
    isNot?: articleWhereInput
  }

  export type TagRelationFilter = {
    is?: tagWhereInput
    isNot?: tagWhereInput
  }

  export type article_tagsArticle_idTag_idCompoundUniqueInput = {
    article_id: number
    tag_id: number
  }

  export type article_tagsCountOrderByAggregateInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
  }

  export type article_tagsAvgOrderByAggregateInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
  }

  export type article_tagsMaxOrderByAggregateInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
  }

  export type article_tagsMinOrderByAggregateInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
  }

  export type article_tagsSumOrderByAggregateInput = {
    article_id?: SortOrder
    tag_id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type articlestarCountOrderByAggregateInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articlestarAvgOrderByAggregateInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
  }

  export type articlestarMaxOrderByAggregateInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articlestarMinOrderByAggregateInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articlestarSumOrderByAggregateInput = {
    user_id?: SortOrder
    article_id?: SortOrder
    id?: SortOrder
  }

  export type articleviewCountOrderByAggregateInput = {
    article_id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    view_duration?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articleviewAvgOrderByAggregateInput = {
    article_id?: SortOrder
    user_id?: SortOrder
    view_duration?: SortOrder
    id?: SortOrder
  }

  export type articleviewMaxOrderByAggregateInput = {
    article_id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    view_duration?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articleviewMinOrderByAggregateInput = {
    article_id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    referrer?: SortOrder
    view_duration?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type articleviewSumOrderByAggregateInput = {
    article_id?: SortOrder
    user_id?: SortOrder
    view_duration?: SortOrder
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type User_article_starsListRelationFilter = {
    every?: user_article_starsWhereInput
    some?: user_article_starsWhereInput
    none?: user_article_starsWhereInput
  }

  export type user_article_starsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type credit_articlesLinkRegionSectorSourceCompoundUniqueInput = {
    link: string
    region: string
    sector: string
    source: string
  }

  export type credit_articlesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    content?: SortOrder
    link?: SortOrder
    source?: SortOrder
    matched_keywords?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    starred?: SortOrder
    starred_at?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type credit_articlesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type credit_articlesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    content?: SortOrder
    link?: SortOrder
    source?: SortOrder
    matched_keywords?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    starred?: SortOrder
    starred_at?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type credit_articlesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    content?: SortOrder
    link?: SortOrder
    source?: SortOrder
    matched_keywords?: SortOrder
    region?: SortOrder
    sector?: SortOrder
    starred?: SortOrder
    starred_at?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type credit_articlesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type email_alertsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    alert_type?: SortOrder
    subscription_date?: SortOrder
    active?: SortOrder
  }

  export type email_alertsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type email_alertsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    alert_type?: SortOrder
    subscription_date?: SortOrder
    active?: SortOrder
  }

  export type email_alertsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    alert_type?: SortOrder
    subscription_date?: SortOrder
    active?: SortOrder
  }

  export type email_alertsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventregistrationListRelationFilter = {
    every?: eventregistrationWhereInput
    some?: eventregistrationWhereInput
    none?: eventregistrationWhereInput
  }

  export type eventregistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventCountOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    event_type?: SortOrder
    location?: SortOrder
    venue?: SortOrder
    is_virtual?: SortOrder
    virtual_link?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    timezone?: SortOrder
    registration_link?: SortOrder
    registration_deadline?: SortOrder
    max_attendees?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    organizer?: SortOrder
    organizer_email?: SortOrder
    organizer_phone?: SortOrder
    sponsors?: SortOrder
    agenda?: SortOrder
    speakers?: SortOrder
    tags?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    is_cancelled?: SortOrder
    cancellation_reason?: SortOrder
    created_by_id?: SortOrder
    view_count?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type eventAvgOrderByAggregateInput = {
    max_attendees?: SortOrder
    price?: SortOrder
    created_by_id?: SortOrder
    view_count?: SortOrder
    id?: SortOrder
  }

  export type eventMaxOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    event_type?: SortOrder
    location?: SortOrder
    venue?: SortOrder
    is_virtual?: SortOrder
    virtual_link?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    timezone?: SortOrder
    registration_link?: SortOrder
    registration_deadline?: SortOrder
    max_attendees?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    organizer?: SortOrder
    organizer_email?: SortOrder
    organizer_phone?: SortOrder
    agenda?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    is_cancelled?: SortOrder
    cancellation_reason?: SortOrder
    created_by_id?: SortOrder
    view_count?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type eventMinOrderByAggregateInput = {
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    event_type?: SortOrder
    location?: SortOrder
    venue?: SortOrder
    is_virtual?: SortOrder
    virtual_link?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    timezone?: SortOrder
    registration_link?: SortOrder
    registration_deadline?: SortOrder
    max_attendees?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    organizer?: SortOrder
    organizer_email?: SortOrder
    organizer_phone?: SortOrder
    agenda?: SortOrder
    source?: SortOrder
    source_url?: SortOrder
    is_published?: SortOrder
    is_featured?: SortOrder
    is_cancelled?: SortOrder
    cancellation_reason?: SortOrder
    created_by_id?: SortOrder
    view_count?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type eventSumOrderByAggregateInput = {
    max_attendees?: SortOrder
    price?: SortOrder
    created_by_id?: SortOrder
    view_count?: SortOrder
    id?: SortOrder
  }

  export type EventRelationFilter = {
    is?: eventWhereInput
    isNot?: eventWhereInput
  }

  export type eventregistrationCountOrderByAggregateInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    is_confirmed?: SortOrder
    is_cancelled?: SortOrder
    cancelled_at?: SortOrder
    cancellation_reason?: SortOrder
    attended?: SortOrder
    check_in_time?: SortOrder
    dietary_requirements?: SortOrder
    special_requirements?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type eventregistrationAvgOrderByAggregateInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    id?: SortOrder
  }

  export type eventregistrationMaxOrderByAggregateInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    is_confirmed?: SortOrder
    is_cancelled?: SortOrder
    cancelled_at?: SortOrder
    cancellation_reason?: SortOrder
    attended?: SortOrder
    check_in_time?: SortOrder
    dietary_requirements?: SortOrder
    special_requirements?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type eventregistrationMinOrderByAggregateInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    is_confirmed?: SortOrder
    is_cancelled?: SortOrder
    cancelled_at?: SortOrder
    cancellation_reason?: SortOrder
    attended?: SortOrder
    check_in_time?: SortOrder
    dietary_requirements?: SortOrder
    special_requirements?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type eventregistrationSumOrderByAggregateInput = {
    event_id?: SortOrder
    user_id?: SortOrder
    id?: SortOrder
  }

  export type eventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    details?: SortOrder
    link?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type eventsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    details?: SortOrder
    link?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type eventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    location?: SortOrder
    details?: SortOrder
    link?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type eventsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type methodologiesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    published_date?: SortOrder
    abstract?: SortOrder
    description?: SortOrder
    link?: SortOrder
    source?: SortOrder
    permalink?: SortOrder
    created_at?: SortOrder
    report_url?: SortOrder
  }

  export type methodologiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type methodologiesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    published_date?: SortOrder
    abstract?: SortOrder
    description?: SortOrder
    link?: SortOrder
    source?: SortOrder
    permalink?: SortOrder
    created_at?: SortOrder
    report_url?: SortOrder
  }

  export type methodologiesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    published_date?: SortOrder
    abstract?: SortOrder
    description?: SortOrder
    link?: SortOrder
    source?: SortOrder
    permalink?: SortOrder
    created_at?: SortOrder
    report_url?: SortOrder
  }

  export type methodologiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Newsletter_subscriptionsRelationFilter = {
    is?: newsletter_subscriptionsWhereInput
    isNot?: newsletter_subscriptionsWhereInput
  }

  export type newsletter_logsCountOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sent_at?: SortOrder
    email_to?: SortOrder
    email_subject?: SortOrder
    articles_count?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    articles_included?: SortOrder
    email_content_preview?: SortOrder
  }

  export type newsletter_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    articles_count?: SortOrder
  }

  export type newsletter_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sent_at?: SortOrder
    email_to?: SortOrder
    email_subject?: SortOrder
    articles_count?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    email_content_preview?: SortOrder
  }

  export type newsletter_logsMinOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sent_at?: SortOrder
    email_to?: SortOrder
    email_subject?: SortOrder
    articles_count?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    email_content_preview?: SortOrder
  }

  export type newsletter_logsSumOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    articles_count?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type newsletter_preferencesCountOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    sources?: SortOrder
    regions?: SortOrder
    sectors?: SortOrder
    include_starred_only?: SortOrder
    frequency?: SortOrder
    day_of_week?: SortOrder
    time_of_day?: SortOrder
    timezone?: SortOrder
    max_articles_per_email?: SortOrder
    include_summary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_preferencesAvgOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    day_of_week?: SortOrder
    max_articles_per_email?: SortOrder
  }

  export type newsletter_preferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    include_starred_only?: SortOrder
    frequency?: SortOrder
    day_of_week?: SortOrder
    time_of_day?: SortOrder
    timezone?: SortOrder
    max_articles_per_email?: SortOrder
    include_summary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_preferencesMinOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    include_starred_only?: SortOrder
    frequency?: SortOrder
    day_of_week?: SortOrder
    time_of_day?: SortOrder
    timezone?: SortOrder
    max_articles_per_email?: SortOrder
    include_summary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_preferencesSumOrderByAggregateInput = {
    id?: SortOrder
    subscription_id?: SortOrder
    day_of_week?: SortOrder
    max_articles_per_email?: SortOrder
  }

  export type Newsletter_logsListRelationFilter = {
    every?: newsletter_logsWhereInput
    some?: newsletter_logsWhereInput
    none?: newsletter_logsWhereInput
  }

  export type Newsletter_preferencesListRelationFilter = {
    every?: newsletter_preferencesWhereInput
    some?: newsletter_preferencesWhereInput
    none?: newsletter_preferencesWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type newsletter_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type newsletter_preferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type newsletter_subscriptionsUser_idSubscription_typeCompoundUniqueInput = {
    user_id: number
    subscription_type: string
  }

  export type newsletter_subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_type?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_subscriptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type newsletter_subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_type?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_type?: SortOrder
    is_active?: SortOrder
    email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type newsletter_subscriptionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumpermissiontypeFilter<$PrismaModel = never> = {
    equals?: $Enums.permissiontype | EnumpermissiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumpermissiontypeFilter<$PrismaModel> | $Enums.permissiontype
  }

  export type User_permissionsListRelationFilter = {
    every?: user_permissionsWhereInput
    some?: user_permissionsWhereInput
    none?: user_permissionsWhereInput
  }

  export type user_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumpermissiontypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.permissiontype | EnumpermissiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumpermissiontypeWithAggregatesFilter<$PrismaModel> | $Enums.permissiontype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpermissiontypeFilter<$PrismaModel>
    _max?: NestedEnumpermissiontypeFilter<$PrismaModel>
  }

  export type publicationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    link?: SortOrder
    image_url?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type publicationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type publicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    link?: SortOrder
    image_url?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type publicationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    description?: SortOrder
    link?: SortOrder
    image_url?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type publicationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type refreshtokenCountOrderByAggregateInput = {
    token?: SortOrder
    user_id?: SortOrder
    expires_at?: SortOrder
    revoked?: SortOrder
    revoked_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type refreshtokenAvgOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type refreshtokenMaxOrderByAggregateInput = {
    token?: SortOrder
    user_id?: SortOrder
    expires_at?: SortOrder
    revoked?: SortOrder
    revoked_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type refreshtokenMinOrderByAggregateInput = {
    token?: SortOrder
    user_id?: SortOrder
    expires_at?: SortOrder
    revoked?: SortOrder
    revoked_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type refreshtokenSumOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagCountOrderByAggregateInput = {
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagMaxOrderByAggregateInput = {
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tagMinOrderByAggregateInput = {
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumuserroleFilter<$PrismaModel = never> = {
    equals?: $Enums.userrole | EnumuserroleFieldRefInput<$PrismaModel>
    in?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserroleFilter<$PrismaModel> | $Enums.userrole
  }

  export type ActivitylogListRelationFilter = {
    every?: activitylogWhereInput
    some?: activitylogWhereInput
    none?: activitylogWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: articleWhereInput
    some?: articleWhereInput
    none?: articleWhereInput
  }

  export type EventListRelationFilter = {
    every?: eventWhereInput
    some?: eventWhereInput
    none?: eventWhereInput
  }

  export type RefreshtokenListRelationFilter = {
    every?: refreshtokenWhereInput
    some?: refreshtokenWhereInput
    none?: refreshtokenWhereInput
  }

  export type UsersessionListRelationFilter = {
    every?: usersessionWhereInput
    some?: usersessionWhereInput
    none?: usersessionWhereInput
  }

  export type activitylogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type articleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refreshtokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    email?: SortOrder
    username?: SortOrder
    full_name?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    phone_number?: SortOrder
    last_login_at?: SortOrder
    last_login_ip?: SortOrder
    failed_login_attempts?: SortOrder
    locked_until?: SortOrder
    two_factor_enabled?: SortOrder
    two_factor_secret?: SortOrder
    email_verified_at?: SortOrder
    email_verification_token?: SortOrder
    password_reset_token?: SortOrder
    password_reset_expires?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    failed_login_attempts?: SortOrder
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    email?: SortOrder
    username?: SortOrder
    full_name?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    phone_number?: SortOrder
    last_login_at?: SortOrder
    last_login_ip?: SortOrder
    failed_login_attempts?: SortOrder
    locked_until?: SortOrder
    two_factor_enabled?: SortOrder
    two_factor_secret?: SortOrder
    email_verified_at?: SortOrder
    email_verification_token?: SortOrder
    password_reset_token?: SortOrder
    password_reset_expires?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    email?: SortOrder
    username?: SortOrder
    full_name?: SortOrder
    hashed_password?: SortOrder
    is_active?: SortOrder
    is_verified?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    avatar_url?: SortOrder
    phone_number?: SortOrder
    last_login_at?: SortOrder
    last_login_ip?: SortOrder
    failed_login_attempts?: SortOrder
    locked_until?: SortOrder
    two_factor_enabled?: SortOrder
    two_factor_secret?: SortOrder
    email_verified_at?: SortOrder
    email_verification_token?: SortOrder
    password_reset_token?: SortOrder
    password_reset_expires?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    failed_login_attempts?: SortOrder
    id?: SortOrder
  }

  export type EnumuserroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userrole | EnumuserroleFieldRefInput<$PrismaModel>
    in?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserroleWithAggregatesFilter<$PrismaModel> | $Enums.userrole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserroleFilter<$PrismaModel>
    _max?: NestedEnumuserroleFilter<$PrismaModel>
  }

  export type user_activityCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type user_activityAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    resource_id?: SortOrder
  }

  export type user_activityMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type user_activityMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource_type?: SortOrder
    resource_id?: SortOrder
    details?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type user_activitySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    resource_id?: SortOrder
  }

  export type user_alertsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    sources?: SortOrder
    sectors?: SortOrder
    created_at?: SortOrder
  }

  export type user_alertsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_alertsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    sources?: SortOrder
    sectors?: SortOrder
    created_at?: SortOrder
  }

  export type user_alertsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    sources?: SortOrder
    sectors?: SortOrder
    created_at?: SortOrder
  }

  export type user_alertsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Credit_articlesRelationFilter = {
    is?: credit_articlesWhereInput
    isNot?: credit_articlesWhereInput
  }

  export type user_article_starsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
    starred_at?: SortOrder
  }

  export type user_article_starsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
  }

  export type user_article_starsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
    starred_at?: SortOrder
  }

  export type user_article_starsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
    starred_at?: SortOrder
  }

  export type user_article_starsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    article_id?: SortOrder
  }

  export type user_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    event_id?: SortOrder
    event_title?: SortOrder
    event_date?: SortOrder
    event_link?: SortOrder
    created_at?: SortOrder
  }

  export type user_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
  }

  export type user_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    event_id?: SortOrder
    event_title?: SortOrder
    event_date?: SortOrder
    event_link?: SortOrder
    created_at?: SortOrder
  }

  export type user_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    event_id?: SortOrder
    event_title?: SortOrder
    event_date?: SortOrder
    event_link?: SortOrder
    created_at?: SortOrder
  }

  export type user_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: permissionWhereInput
    isNot?: permissionWhereInput
  }

  export type user_permissionsUser_idPermission_idCompoundUniqueInput = {
    user_id: number
    permission_id: number
  }

  export type user_permissionsCountOrderByAggregateInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type user_permissionsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type user_permissionsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type user_permissionsMinOrderByAggregateInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type user_permissionsSumOrderByAggregateInput = {
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type Activity_logsListRelationFilter = {
    every?: activity_logsWhereInput
    some?: activity_logsWhereInput
    none?: activity_logsWhereInput
  }

  export type Ai_assistant_configListRelationFilter = {
    every?: ai_assistant_configWhereInput
    some?: ai_assistant_configWhereInput
    none?: ai_assistant_configWhereInput
  }

  export type Ai_conversationsListRelationFilter = {
    every?: ai_conversationsWhereInput
    some?: ai_conversationsWhereInput
    none?: ai_conversationsWhereInput
  }

  export type Ai_entity_memoryListRelationFilter = {
    every?: ai_entity_memoryWhereInput
    some?: ai_entity_memoryWhereInput
    none?: ai_entity_memoryWhereInput
  }

  export type Ai_session_memoryListRelationFilter = {
    every?: ai_session_memoryWhereInput
    some?: ai_session_memoryWhereInput
    none?: ai_session_memoryWhereInput
  }

  export type Newsletter_subscriptionsListRelationFilter = {
    every?: newsletter_subscriptionsWhereInput
    some?: newsletter_subscriptionsWhereInput
    none?: newsletter_subscriptionsWhereInput
  }

  export type User_activityListRelationFilter = {
    every?: user_activityWhereInput
    some?: user_activityWhereInput
    none?: user_activityWhereInput
  }

  export type activity_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_assistant_configOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_conversationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_entity_memoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ai_session_memoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type newsletter_subscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_activityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersessionCountOrderByAggregateInput = {
    user_id?: SortOrder
    session_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    last_activity?: SortOrder
    expires_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersessionAvgOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type usersessionMaxOrderByAggregateInput = {
    user_id?: SortOrder
    session_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    last_activity?: SortOrder
    expires_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersessionMinOrderByAggregateInput = {
    user_id?: SortOrder
    session_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    last_activity?: SortOrder
    expires_at?: SortOrder
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersessionSumOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type usersCreateNestedOneWithoutActivity_logsInput = {
    create?: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivity_logsInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneWithoutActivity_logsNestedInput = {
    create?: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutActivity_logsInput
    upsert?: usersUpsertWithoutActivity_logsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutActivity_logsInput, usersUpdateWithoutActivity_logsInput>, usersUncheckedUpdateWithoutActivity_logsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutActivitylogInput = {
    create?: XOR<userCreateWithoutActivitylogInput, userUncheckedCreateWithoutActivitylogInput>
    connectOrCreate?: userCreateOrConnectWithoutActivitylogInput
    connect?: userWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userUpdateOneWithoutActivitylogNestedInput = {
    create?: XOR<userCreateWithoutActivitylogInput, userUncheckedCreateWithoutActivitylogInput>
    connectOrCreate?: userCreateOrConnectWithoutActivitylogInput
    upsert?: userUpsertWithoutActivitylogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutActivitylogInput, userUpdateWithoutActivitylogInput>, userUncheckedUpdateWithoutActivitylogInput>
  }

  export type usersCreateNestedOneWithoutAi_assistant_configInput = {
    create?: XOR<usersCreateWithoutAi_assistant_configInput, usersUncheckedCreateWithoutAi_assistant_configInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_assistant_configInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutAi_assistant_configNestedInput = {
    create?: XOR<usersCreateWithoutAi_assistant_configInput, usersUncheckedCreateWithoutAi_assistant_configInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_assistant_configInput
    upsert?: usersUpsertWithoutAi_assistant_configInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_assistant_configInput, usersUpdateWithoutAi_assistant_configInput>, usersUncheckedUpdateWithoutAi_assistant_configInput>
  }

  export type usersCreateNestedOneWithoutAi_conversationsInput = {
    create?: XOR<usersCreateWithoutAi_conversationsInput, usersUncheckedCreateWithoutAi_conversationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_conversationsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type usersUpdateOneWithoutAi_conversationsNestedInput = {
    create?: XOR<usersCreateWithoutAi_conversationsInput, usersUncheckedCreateWithoutAi_conversationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_conversationsInput
    upsert?: usersUpsertWithoutAi_conversationsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_conversationsInput, usersUpdateWithoutAi_conversationsInput>, usersUncheckedUpdateWithoutAi_conversationsInput>
  }

  export type usersCreateNestedOneWithoutAi_entity_memoryInput = {
    create?: XOR<usersCreateWithoutAi_entity_memoryInput, usersUncheckedCreateWithoutAi_entity_memoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_entity_memoryInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutAi_entity_memoryNestedInput = {
    create?: XOR<usersCreateWithoutAi_entity_memoryInput, usersUncheckedCreateWithoutAi_entity_memoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_entity_memoryInput
    upsert?: usersUpsertWithoutAi_entity_memoryInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_entity_memoryInput, usersUpdateWithoutAi_entity_memoryInput>, usersUncheckedUpdateWithoutAi_entity_memoryInput>
  }

  export type usersCreateNestedOneWithoutAi_session_memoryInput = {
    create?: XOR<usersCreateWithoutAi_session_memoryInput, usersUncheckedCreateWithoutAi_session_memoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_session_memoryInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutAi_session_memoryNestedInput = {
    create?: XOR<usersCreateWithoutAi_session_memoryInput, usersUncheckedCreateWithoutAi_session_memoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutAi_session_memoryInput
    upsert?: usersUpsertWithoutAi_session_memoryInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAi_session_memoryInput, usersUpdateWithoutAi_session_memoryInput>, usersUncheckedUpdateWithoutAi_session_memoryInput>
  }

  export type userCreateNestedOneWithoutArticleInput = {
    create?: XOR<userCreateWithoutArticleInput, userUncheckedCreateWithoutArticleInput>
    connectOrCreate?: userCreateOrConnectWithoutArticleInput
    connect?: userWhereUniqueInput
  }

  export type article_tagsCreateNestedManyWithoutArticleInput = {
    create?: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput> | article_tagsCreateWithoutArticleInput[] | article_tagsUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutArticleInput | article_tagsCreateOrConnectWithoutArticleInput[]
    createMany?: article_tagsCreateManyArticleInputEnvelope
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
  }

  export type articlestarCreateNestedManyWithoutArticleInput = {
    create?: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput> | articlestarCreateWithoutArticleInput[] | articlestarUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutArticleInput | articlestarCreateOrConnectWithoutArticleInput[]
    createMany?: articlestarCreateManyArticleInputEnvelope
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
  }

  export type articleviewCreateNestedManyWithoutArticleInput = {
    create?: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput> | articleviewCreateWithoutArticleInput[] | articleviewUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutArticleInput | articleviewCreateOrConnectWithoutArticleInput[]
    createMany?: articleviewCreateManyArticleInputEnvelope
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
  }

  export type article_tagsUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput> | article_tagsCreateWithoutArticleInput[] | article_tagsUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutArticleInput | article_tagsCreateOrConnectWithoutArticleInput[]
    createMany?: article_tagsCreateManyArticleInputEnvelope
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
  }

  export type articlestarUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput> | articlestarCreateWithoutArticleInput[] | articlestarUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutArticleInput | articlestarCreateOrConnectWithoutArticleInput[]
    createMany?: articlestarCreateManyArticleInputEnvelope
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
  }

  export type articleviewUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput> | articleviewCreateWithoutArticleInput[] | articleviewUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutArticleInput | articleviewCreateOrConnectWithoutArticleInput[]
    createMany?: articleviewCreateManyArticleInputEnvelope
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneWithoutArticleNestedInput = {
    create?: XOR<userCreateWithoutArticleInput, userUncheckedCreateWithoutArticleInput>
    connectOrCreate?: userCreateOrConnectWithoutArticleInput
    upsert?: userUpsertWithoutArticleInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutArticleInput, userUpdateWithoutArticleInput>, userUncheckedUpdateWithoutArticleInput>
  }

  export type article_tagsUpdateManyWithoutArticleNestedInput = {
    create?: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput> | article_tagsCreateWithoutArticleInput[] | article_tagsUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutArticleInput | article_tagsCreateOrConnectWithoutArticleInput[]
    upsert?: article_tagsUpsertWithWhereUniqueWithoutArticleInput | article_tagsUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: article_tagsCreateManyArticleInputEnvelope
    set?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    disconnect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    delete?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    update?: article_tagsUpdateWithWhereUniqueWithoutArticleInput | article_tagsUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: article_tagsUpdateManyWithWhereWithoutArticleInput | article_tagsUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
  }

  export type articlestarUpdateManyWithoutArticleNestedInput = {
    create?: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput> | articlestarCreateWithoutArticleInput[] | articlestarUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutArticleInput | articlestarCreateOrConnectWithoutArticleInput[]
    upsert?: articlestarUpsertWithWhereUniqueWithoutArticleInput | articlestarUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: articlestarCreateManyArticleInputEnvelope
    set?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    disconnect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    delete?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    update?: articlestarUpdateWithWhereUniqueWithoutArticleInput | articlestarUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: articlestarUpdateManyWithWhereWithoutArticleInput | articlestarUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
  }

  export type articleviewUpdateManyWithoutArticleNestedInput = {
    create?: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput> | articleviewCreateWithoutArticleInput[] | articleviewUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutArticleInput | articleviewCreateOrConnectWithoutArticleInput[]
    upsert?: articleviewUpsertWithWhereUniqueWithoutArticleInput | articleviewUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: articleviewCreateManyArticleInputEnvelope
    set?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    disconnect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    delete?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    update?: articleviewUpdateWithWhereUniqueWithoutArticleInput | articleviewUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: articleviewUpdateManyWithWhereWithoutArticleInput | articleviewUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
  }

  export type article_tagsUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput> | article_tagsCreateWithoutArticleInput[] | article_tagsUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutArticleInput | article_tagsCreateOrConnectWithoutArticleInput[]
    upsert?: article_tagsUpsertWithWhereUniqueWithoutArticleInput | article_tagsUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: article_tagsCreateManyArticleInputEnvelope
    set?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    disconnect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    delete?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    update?: article_tagsUpdateWithWhereUniqueWithoutArticleInput | article_tagsUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: article_tagsUpdateManyWithWhereWithoutArticleInput | article_tagsUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
  }

  export type articlestarUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput> | articlestarCreateWithoutArticleInput[] | articlestarUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutArticleInput | articlestarCreateOrConnectWithoutArticleInput[]
    upsert?: articlestarUpsertWithWhereUniqueWithoutArticleInput | articlestarUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: articlestarCreateManyArticleInputEnvelope
    set?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    disconnect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    delete?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    update?: articlestarUpdateWithWhereUniqueWithoutArticleInput | articlestarUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: articlestarUpdateManyWithWhereWithoutArticleInput | articlestarUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
  }

  export type articleviewUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput> | articleviewCreateWithoutArticleInput[] | articleviewUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutArticleInput | articleviewCreateOrConnectWithoutArticleInput[]
    upsert?: articleviewUpsertWithWhereUniqueWithoutArticleInput | articleviewUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: articleviewCreateManyArticleInputEnvelope
    set?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    disconnect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    delete?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    update?: articleviewUpdateWithWhereUniqueWithoutArticleInput | articleviewUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: articleviewUpdateManyWithWhereWithoutArticleInput | articleviewUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
  }

  export type articleCreateNestedOneWithoutArticle_tagsInput = {
    create?: XOR<articleCreateWithoutArticle_tagsInput, articleUncheckedCreateWithoutArticle_tagsInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticle_tagsInput
    connect?: articleWhereUniqueInput
  }

  export type tagCreateNestedOneWithoutArticle_tagsInput = {
    create?: XOR<tagCreateWithoutArticle_tagsInput, tagUncheckedCreateWithoutArticle_tagsInput>
    connectOrCreate?: tagCreateOrConnectWithoutArticle_tagsInput
    connect?: tagWhereUniqueInput
  }

  export type articleUpdateOneRequiredWithoutArticle_tagsNestedInput = {
    create?: XOR<articleCreateWithoutArticle_tagsInput, articleUncheckedCreateWithoutArticle_tagsInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticle_tagsInput
    upsert?: articleUpsertWithoutArticle_tagsInput
    connect?: articleWhereUniqueInput
    update?: XOR<XOR<articleUpdateToOneWithWhereWithoutArticle_tagsInput, articleUpdateWithoutArticle_tagsInput>, articleUncheckedUpdateWithoutArticle_tagsInput>
  }

  export type tagUpdateOneRequiredWithoutArticle_tagsNestedInput = {
    create?: XOR<tagCreateWithoutArticle_tagsInput, tagUncheckedCreateWithoutArticle_tagsInput>
    connectOrCreate?: tagCreateOrConnectWithoutArticle_tagsInput
    upsert?: tagUpsertWithoutArticle_tagsInput
    connect?: tagWhereUniqueInput
    update?: XOR<XOR<tagUpdateToOneWithWhereWithoutArticle_tagsInput, tagUpdateWithoutArticle_tagsInput>, tagUncheckedUpdateWithoutArticle_tagsInput>
  }

  export type articleCreateNestedOneWithoutArticlestarInput = {
    create?: XOR<articleCreateWithoutArticlestarInput, articleUncheckedCreateWithoutArticlestarInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticlestarInput
    connect?: articleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutArticlestarInput = {
    create?: XOR<userCreateWithoutArticlestarInput, userUncheckedCreateWithoutArticlestarInput>
    connectOrCreate?: userCreateOrConnectWithoutArticlestarInput
    connect?: userWhereUniqueInput
  }

  export type articleUpdateOneRequiredWithoutArticlestarNestedInput = {
    create?: XOR<articleCreateWithoutArticlestarInput, articleUncheckedCreateWithoutArticlestarInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticlestarInput
    upsert?: articleUpsertWithoutArticlestarInput
    connect?: articleWhereUniqueInput
    update?: XOR<XOR<articleUpdateToOneWithWhereWithoutArticlestarInput, articleUpdateWithoutArticlestarInput>, articleUncheckedUpdateWithoutArticlestarInput>
  }

  export type userUpdateOneRequiredWithoutArticlestarNestedInput = {
    create?: XOR<userCreateWithoutArticlestarInput, userUncheckedCreateWithoutArticlestarInput>
    connectOrCreate?: userCreateOrConnectWithoutArticlestarInput
    upsert?: userUpsertWithoutArticlestarInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutArticlestarInput, userUpdateWithoutArticlestarInput>, userUncheckedUpdateWithoutArticlestarInput>
  }

  export type articleCreateNestedOneWithoutArticleviewInput = {
    create?: XOR<articleCreateWithoutArticleviewInput, articleUncheckedCreateWithoutArticleviewInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticleviewInput
    connect?: articleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutArticleviewInput = {
    create?: XOR<userCreateWithoutArticleviewInput, userUncheckedCreateWithoutArticleviewInput>
    connectOrCreate?: userCreateOrConnectWithoutArticleviewInput
    connect?: userWhereUniqueInput
  }

  export type articleUpdateOneRequiredWithoutArticleviewNestedInput = {
    create?: XOR<articleCreateWithoutArticleviewInput, articleUncheckedCreateWithoutArticleviewInput>
    connectOrCreate?: articleCreateOrConnectWithoutArticleviewInput
    upsert?: articleUpsertWithoutArticleviewInput
    connect?: articleWhereUniqueInput
    update?: XOR<XOR<articleUpdateToOneWithWhereWithoutArticleviewInput, articleUpdateWithoutArticleviewInput>, articleUncheckedUpdateWithoutArticleviewInput>
  }

  export type userUpdateOneWithoutArticleviewNestedInput = {
    create?: XOR<userCreateWithoutArticleviewInput, userUncheckedCreateWithoutArticleviewInput>
    connectOrCreate?: userCreateOrConnectWithoutArticleviewInput
    upsert?: userUpsertWithoutArticleviewInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutArticleviewInput, userUpdateWithoutArticleviewInput>, userUncheckedUpdateWithoutArticleviewInput>
  }

  export type user_article_starsCreateNestedManyWithoutCredit_articlesInput = {
    create?: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput> | user_article_starsCreateWithoutCredit_articlesInput[] | user_article_starsUncheckedCreateWithoutCredit_articlesInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutCredit_articlesInput | user_article_starsCreateOrConnectWithoutCredit_articlesInput[]
    createMany?: user_article_starsCreateManyCredit_articlesInputEnvelope
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
  }

  export type user_article_starsUncheckedCreateNestedManyWithoutCredit_articlesInput = {
    create?: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput> | user_article_starsCreateWithoutCredit_articlesInput[] | user_article_starsUncheckedCreateWithoutCredit_articlesInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutCredit_articlesInput | user_article_starsCreateOrConnectWithoutCredit_articlesInput[]
    createMany?: user_article_starsCreateManyCredit_articlesInputEnvelope
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type user_article_starsUpdateManyWithoutCredit_articlesNestedInput = {
    create?: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput> | user_article_starsCreateWithoutCredit_articlesInput[] | user_article_starsUncheckedCreateWithoutCredit_articlesInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutCredit_articlesInput | user_article_starsCreateOrConnectWithoutCredit_articlesInput[]
    upsert?: user_article_starsUpsertWithWhereUniqueWithoutCredit_articlesInput | user_article_starsUpsertWithWhereUniqueWithoutCredit_articlesInput[]
    createMany?: user_article_starsCreateManyCredit_articlesInputEnvelope
    set?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    disconnect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    delete?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    update?: user_article_starsUpdateWithWhereUniqueWithoutCredit_articlesInput | user_article_starsUpdateWithWhereUniqueWithoutCredit_articlesInput[]
    updateMany?: user_article_starsUpdateManyWithWhereWithoutCredit_articlesInput | user_article_starsUpdateManyWithWhereWithoutCredit_articlesInput[]
    deleteMany?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
  }

  export type user_article_starsUncheckedUpdateManyWithoutCredit_articlesNestedInput = {
    create?: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput> | user_article_starsCreateWithoutCredit_articlesInput[] | user_article_starsUncheckedCreateWithoutCredit_articlesInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutCredit_articlesInput | user_article_starsCreateOrConnectWithoutCredit_articlesInput[]
    upsert?: user_article_starsUpsertWithWhereUniqueWithoutCredit_articlesInput | user_article_starsUpsertWithWhereUniqueWithoutCredit_articlesInput[]
    createMany?: user_article_starsCreateManyCredit_articlesInputEnvelope
    set?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    disconnect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    delete?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    update?: user_article_starsUpdateWithWhereUniqueWithoutCredit_articlesInput | user_article_starsUpdateWithWhereUniqueWithoutCredit_articlesInput[]
    updateMany?: user_article_starsUpdateManyWithWhereWithoutCredit_articlesInput | user_article_starsUpdateManyWithWhereWithoutCredit_articlesInput[]
    deleteMany?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutEventInput = {
    create?: XOR<userCreateWithoutEventInput, userUncheckedCreateWithoutEventInput>
    connectOrCreate?: userCreateOrConnectWithoutEventInput
    connect?: userWhereUniqueInput
  }

  export type eventregistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput> | eventregistrationCreateWithoutEventInput[] | eventregistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutEventInput | eventregistrationCreateOrConnectWithoutEventInput[]
    createMany?: eventregistrationCreateManyEventInputEnvelope
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
  }

  export type eventregistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput> | eventregistrationCreateWithoutEventInput[] | eventregistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutEventInput | eventregistrationCreateOrConnectWithoutEventInput[]
    createMany?: eventregistrationCreateManyEventInputEnvelope
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
  }

  export type userUpdateOneWithoutEventNestedInput = {
    create?: XOR<userCreateWithoutEventInput, userUncheckedCreateWithoutEventInput>
    connectOrCreate?: userCreateOrConnectWithoutEventInput
    upsert?: userUpsertWithoutEventInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEventInput, userUpdateWithoutEventInput>, userUncheckedUpdateWithoutEventInput>
  }

  export type eventregistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput> | eventregistrationCreateWithoutEventInput[] | eventregistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutEventInput | eventregistrationCreateOrConnectWithoutEventInput[]
    upsert?: eventregistrationUpsertWithWhereUniqueWithoutEventInput | eventregistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: eventregistrationCreateManyEventInputEnvelope
    set?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    disconnect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    delete?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    update?: eventregistrationUpdateWithWhereUniqueWithoutEventInput | eventregistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: eventregistrationUpdateManyWithWhereWithoutEventInput | eventregistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
  }

  export type eventregistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput> | eventregistrationCreateWithoutEventInput[] | eventregistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutEventInput | eventregistrationCreateOrConnectWithoutEventInput[]
    upsert?: eventregistrationUpsertWithWhereUniqueWithoutEventInput | eventregistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: eventregistrationCreateManyEventInputEnvelope
    set?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    disconnect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    delete?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    update?: eventregistrationUpdateWithWhereUniqueWithoutEventInput | eventregistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: eventregistrationUpdateManyWithWhereWithoutEventInput | eventregistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
  }

  export type eventCreateNestedOneWithoutEventregistrationInput = {
    create?: XOR<eventCreateWithoutEventregistrationInput, eventUncheckedCreateWithoutEventregistrationInput>
    connectOrCreate?: eventCreateOrConnectWithoutEventregistrationInput
    connect?: eventWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEventregistrationInput = {
    create?: XOR<userCreateWithoutEventregistrationInput, userUncheckedCreateWithoutEventregistrationInput>
    connectOrCreate?: userCreateOrConnectWithoutEventregistrationInput
    connect?: userWhereUniqueInput
  }

  export type eventUpdateOneRequiredWithoutEventregistrationNestedInput = {
    create?: XOR<eventCreateWithoutEventregistrationInput, eventUncheckedCreateWithoutEventregistrationInput>
    connectOrCreate?: eventCreateOrConnectWithoutEventregistrationInput
    upsert?: eventUpsertWithoutEventregistrationInput
    connect?: eventWhereUniqueInput
    update?: XOR<XOR<eventUpdateToOneWithWhereWithoutEventregistrationInput, eventUpdateWithoutEventregistrationInput>, eventUncheckedUpdateWithoutEventregistrationInput>
  }

  export type userUpdateOneRequiredWithoutEventregistrationNestedInput = {
    create?: XOR<userCreateWithoutEventregistrationInput, userUncheckedCreateWithoutEventregistrationInput>
    connectOrCreate?: userCreateOrConnectWithoutEventregistrationInput
    upsert?: userUpsertWithoutEventregistrationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEventregistrationInput, userUpdateWithoutEventregistrationInput>, userUncheckedUpdateWithoutEventregistrationInput>
  }

  export type newsletter_subscriptionsCreateNestedOneWithoutNewsletter_logsInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_logsInput>
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutNewsletter_logsInput
    connect?: newsletter_subscriptionsWhereUniqueInput
  }

  export type newsletter_subscriptionsUpdateOneRequiredWithoutNewsletter_logsNestedInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_logsInput>
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutNewsletter_logsInput
    upsert?: newsletter_subscriptionsUpsertWithoutNewsletter_logsInput
    connect?: newsletter_subscriptionsWhereUniqueInput
    update?: XOR<XOR<newsletter_subscriptionsUpdateToOneWithWhereWithoutNewsletter_logsInput, newsletter_subscriptionsUpdateWithoutNewsletter_logsInput>, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_logsInput>
  }

  export type newsletter_preferencesCreatesourcesInput = {
    set: string[]
  }

  export type newsletter_preferencesCreateregionsInput = {
    set: string[]
  }

  export type newsletter_preferencesCreatesectorsInput = {
    set: string[]
  }

  export type newsletter_subscriptionsCreateNestedOneWithoutNewsletter_preferencesInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_preferencesInput>
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutNewsletter_preferencesInput
    connect?: newsletter_subscriptionsWhereUniqueInput
  }

  export type newsletter_preferencesUpdatesourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type newsletter_preferencesUpdateregionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type newsletter_preferencesUpdatesectorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type newsletter_subscriptionsUpdateOneRequiredWithoutNewsletter_preferencesNestedInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_preferencesInput>
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutNewsletter_preferencesInput
    upsert?: newsletter_subscriptionsUpsertWithoutNewsletter_preferencesInput
    connect?: newsletter_subscriptionsWhereUniqueInput
    update?: XOR<XOR<newsletter_subscriptionsUpdateToOneWithWhereWithoutNewsletter_preferencesInput, newsletter_subscriptionsUpdateWithoutNewsletter_preferencesInput>, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_preferencesInput>
  }

  export type newsletter_logsCreateNestedManyWithoutNewsletter_subscriptionsInput = {
    create?: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_logsCreateWithoutNewsletter_subscriptionsInput[] | newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_logsCreateManyNewsletter_subscriptionsInputEnvelope
    connect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
  }

  export type newsletter_preferencesCreateNestedManyWithoutNewsletter_subscriptionsInput = {
    create?: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput[] | newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_preferencesCreateManyNewsletter_subscriptionsInputEnvelope
    connect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutNewsletter_subscriptionsInput = {
    create?: XOR<usersCreateWithoutNewsletter_subscriptionsInput, usersUncheckedCreateWithoutNewsletter_subscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNewsletter_subscriptionsInput
    connect?: usersWhereUniqueInput
  }

  export type newsletter_logsUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput = {
    create?: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_logsCreateWithoutNewsletter_subscriptionsInput[] | newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_logsCreateManyNewsletter_subscriptionsInputEnvelope
    connect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
  }

  export type newsletter_preferencesUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput = {
    create?: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput[] | newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_preferencesCreateManyNewsletter_subscriptionsInputEnvelope
    connect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
  }

  export type newsletter_logsUpdateManyWithoutNewsletter_subscriptionsNestedInput = {
    create?: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_logsCreateWithoutNewsletter_subscriptionsInput[] | newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    upsert?: newsletter_logsUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_logsUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_logsCreateManyNewsletter_subscriptionsInputEnvelope
    set?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    disconnect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    delete?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    connect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    update?: newsletter_logsUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_logsUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    updateMany?: newsletter_logsUpdateManyWithWhereWithoutNewsletter_subscriptionsInput | newsletter_logsUpdateManyWithWhereWithoutNewsletter_subscriptionsInput[]
    deleteMany?: newsletter_logsScalarWhereInput | newsletter_logsScalarWhereInput[]
  }

  export type newsletter_preferencesUpdateManyWithoutNewsletter_subscriptionsNestedInput = {
    create?: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput[] | newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    upsert?: newsletter_preferencesUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_preferencesCreateManyNewsletter_subscriptionsInputEnvelope
    set?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    disconnect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    delete?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    connect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    update?: newsletter_preferencesUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    updateMany?: newsletter_preferencesUpdateManyWithWhereWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpdateManyWithWhereWithoutNewsletter_subscriptionsInput[]
    deleteMany?: newsletter_preferencesScalarWhereInput | newsletter_preferencesScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutNewsletter_subscriptionsNestedInput = {
    create?: XOR<usersCreateWithoutNewsletter_subscriptionsInput, usersUncheckedCreateWithoutNewsletter_subscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNewsletter_subscriptionsInput
    upsert?: usersUpsertWithoutNewsletter_subscriptionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNewsletter_subscriptionsInput, usersUpdateWithoutNewsletter_subscriptionsInput>, usersUncheckedUpdateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput = {
    create?: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_logsCreateWithoutNewsletter_subscriptionsInput[] | newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    upsert?: newsletter_logsUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_logsUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_logsCreateManyNewsletter_subscriptionsInputEnvelope
    set?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    disconnect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    delete?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    connect?: newsletter_logsWhereUniqueInput | newsletter_logsWhereUniqueInput[]
    update?: newsletter_logsUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_logsUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    updateMany?: newsletter_logsUpdateManyWithWhereWithoutNewsletter_subscriptionsInput | newsletter_logsUpdateManyWithWhereWithoutNewsletter_subscriptionsInput[]
    deleteMany?: newsletter_logsScalarWhereInput | newsletter_logsScalarWhereInput[]
  }

  export type newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput = {
    create?: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput> | newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput[] | newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput[]
    connectOrCreate?: newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput | newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput[]
    upsert?: newsletter_preferencesUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    createMany?: newsletter_preferencesCreateManyNewsletter_subscriptionsInputEnvelope
    set?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    disconnect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    delete?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    connect?: newsletter_preferencesWhereUniqueInput | newsletter_preferencesWhereUniqueInput[]
    update?: newsletter_preferencesUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput[]
    updateMany?: newsletter_preferencesUpdateManyWithWhereWithoutNewsletter_subscriptionsInput | newsletter_preferencesUpdateManyWithWhereWithoutNewsletter_subscriptionsInput[]
    deleteMany?: newsletter_preferencesScalarWhereInput | newsletter_preferencesScalarWhereInput[]
  }

  export type user_permissionsCreateNestedManyWithoutPermissionInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput> | user_permissionsCreateWithoutPermissionInput[] | user_permissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionInput | user_permissionsCreateOrConnectWithoutPermissionInput[]
    createMany?: user_permissionsCreateManyPermissionInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type user_permissionsUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput> | user_permissionsCreateWithoutPermissionInput[] | user_permissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionInput | user_permissionsCreateOrConnectWithoutPermissionInput[]
    createMany?: user_permissionsCreateManyPermissionInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type EnumpermissiontypeFieldUpdateOperationsInput = {
    set?: $Enums.permissiontype
  }

  export type user_permissionsUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput> | user_permissionsCreateWithoutPermissionInput[] | user_permissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionInput | user_permissionsCreateOrConnectWithoutPermissionInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutPermissionInput | user_permissionsUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: user_permissionsCreateManyPermissionInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutPermissionInput | user_permissionsUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutPermissionInput | user_permissionsUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type user_permissionsUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput> | user_permissionsCreateWithoutPermissionInput[] | user_permissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutPermissionInput | user_permissionsCreateOrConnectWithoutPermissionInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutPermissionInput | user_permissionsUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: user_permissionsCreateManyPermissionInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutPermissionInput | user_permissionsUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutPermissionInput | user_permissionsUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutRefreshtokenInput = {
    create?: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokenInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRefreshtokenNestedInput = {
    create?: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokenInput
    upsert?: userUpsertWithoutRefreshtokenInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRefreshtokenInput, userUpdateWithoutRefreshtokenInput>, userUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type article_tagsCreateNestedManyWithoutTagInput = {
    create?: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput> | article_tagsCreateWithoutTagInput[] | article_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutTagInput | article_tagsCreateOrConnectWithoutTagInput[]
    createMany?: article_tagsCreateManyTagInputEnvelope
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
  }

  export type article_tagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput> | article_tagsCreateWithoutTagInput[] | article_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutTagInput | article_tagsCreateOrConnectWithoutTagInput[]
    createMany?: article_tagsCreateManyTagInputEnvelope
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
  }

  export type article_tagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput> | article_tagsCreateWithoutTagInput[] | article_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutTagInput | article_tagsCreateOrConnectWithoutTagInput[]
    upsert?: article_tagsUpsertWithWhereUniqueWithoutTagInput | article_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: article_tagsCreateManyTagInputEnvelope
    set?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    disconnect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    delete?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    update?: article_tagsUpdateWithWhereUniqueWithoutTagInput | article_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: article_tagsUpdateManyWithWhereWithoutTagInput | article_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
  }

  export type article_tagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput> | article_tagsCreateWithoutTagInput[] | article_tagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: article_tagsCreateOrConnectWithoutTagInput | article_tagsCreateOrConnectWithoutTagInput[]
    upsert?: article_tagsUpsertWithWhereUniqueWithoutTagInput | article_tagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: article_tagsCreateManyTagInputEnvelope
    set?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    disconnect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    delete?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    connect?: article_tagsWhereUniqueInput | article_tagsWhereUniqueInput[]
    update?: article_tagsUpdateWithWhereUniqueWithoutTagInput | article_tagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: article_tagsUpdateManyWithWhereWithoutTagInput | article_tagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
  }

  export type activitylogCreateNestedManyWithoutUserInput = {
    create?: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput> | activitylogCreateWithoutUserInput[] | activitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutUserInput | activitylogCreateOrConnectWithoutUserInput[]
    createMany?: activitylogCreateManyUserInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type articleCreateNestedManyWithoutUserInput = {
    create?: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput> | articleCreateWithoutUserInput[] | articleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleCreateOrConnectWithoutUserInput | articleCreateOrConnectWithoutUserInput[]
    createMany?: articleCreateManyUserInputEnvelope
    connect?: articleWhereUniqueInput | articleWhereUniqueInput[]
  }

  export type articlestarCreateNestedManyWithoutUserInput = {
    create?: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput> | articlestarCreateWithoutUserInput[] | articlestarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutUserInput | articlestarCreateOrConnectWithoutUserInput[]
    createMany?: articlestarCreateManyUserInputEnvelope
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
  }

  export type articleviewCreateNestedManyWithoutUserInput = {
    create?: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput> | articleviewCreateWithoutUserInput[] | articleviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutUserInput | articleviewCreateOrConnectWithoutUserInput[]
    createMany?: articleviewCreateManyUserInputEnvelope
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
  }

  export type eventCreateNestedManyWithoutUserInput = {
    create?: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput> | eventCreateWithoutUserInput[] | eventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUserInput | eventCreateOrConnectWithoutUserInput[]
    createMany?: eventCreateManyUserInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type eventregistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput> | eventregistrationCreateWithoutUserInput[] | eventregistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutUserInput | eventregistrationCreateOrConnectWithoutUserInput[]
    createMany?: eventregistrationCreateManyUserInputEnvelope
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
  }

  export type refreshtokenCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type user_permissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput> | user_permissionsCreateWithoutUserInput[] | user_permissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUserInput | user_permissionsCreateOrConnectWithoutUserInput[]
    createMany?: user_permissionsCreateManyUserInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type usersessionCreateNestedManyWithoutUserInput = {
    create?: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput> | usersessionCreateWithoutUserInput[] | usersessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usersessionCreateOrConnectWithoutUserInput | usersessionCreateOrConnectWithoutUserInput[]
    createMany?: usersessionCreateManyUserInputEnvelope
    connect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
  }

  export type activitylogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput> | activitylogCreateWithoutUserInput[] | activitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutUserInput | activitylogCreateOrConnectWithoutUserInput[]
    createMany?: activitylogCreateManyUserInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type articleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput> | articleCreateWithoutUserInput[] | articleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleCreateOrConnectWithoutUserInput | articleCreateOrConnectWithoutUserInput[]
    createMany?: articleCreateManyUserInputEnvelope
    connect?: articleWhereUniqueInput | articleWhereUniqueInput[]
  }

  export type articlestarUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput> | articlestarCreateWithoutUserInput[] | articlestarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutUserInput | articlestarCreateOrConnectWithoutUserInput[]
    createMany?: articlestarCreateManyUserInputEnvelope
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
  }

  export type articleviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput> | articleviewCreateWithoutUserInput[] | articleviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutUserInput | articleviewCreateOrConnectWithoutUserInput[]
    createMany?: articleviewCreateManyUserInputEnvelope
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
  }

  export type eventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput> | eventCreateWithoutUserInput[] | eventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUserInput | eventCreateOrConnectWithoutUserInput[]
    createMany?: eventCreateManyUserInputEnvelope
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
  }

  export type eventregistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput> | eventregistrationCreateWithoutUserInput[] | eventregistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutUserInput | eventregistrationCreateOrConnectWithoutUserInput[]
    createMany?: eventregistrationCreateManyUserInputEnvelope
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
  }

  export type refreshtokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type user_permissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput> | user_permissionsCreateWithoutUserInput[] | user_permissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUserInput | user_permissionsCreateOrConnectWithoutUserInput[]
    createMany?: user_permissionsCreateManyUserInputEnvelope
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
  }

  export type usersessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput> | usersessionCreateWithoutUserInput[] | usersessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usersessionCreateOrConnectWithoutUserInput | usersessionCreateOrConnectWithoutUserInput[]
    createMany?: usersessionCreateManyUserInputEnvelope
    connect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
  }

  export type EnumuserroleFieldUpdateOperationsInput = {
    set?: $Enums.userrole
  }

  export type activitylogUpdateManyWithoutUserNestedInput = {
    create?: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput> | activitylogCreateWithoutUserInput[] | activitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutUserInput | activitylogCreateOrConnectWithoutUserInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutUserInput | activitylogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activitylogCreateManyUserInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutUserInput | activitylogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutUserInput | activitylogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type articleUpdateManyWithoutUserNestedInput = {
    create?: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput> | articleCreateWithoutUserInput[] | articleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleCreateOrConnectWithoutUserInput | articleCreateOrConnectWithoutUserInput[]
    upsert?: articleUpsertWithWhereUniqueWithoutUserInput | articleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articleCreateManyUserInputEnvelope
    set?: articleWhereUniqueInput | articleWhereUniqueInput[]
    disconnect?: articleWhereUniqueInput | articleWhereUniqueInput[]
    delete?: articleWhereUniqueInput | articleWhereUniqueInput[]
    connect?: articleWhereUniqueInput | articleWhereUniqueInput[]
    update?: articleUpdateWithWhereUniqueWithoutUserInput | articleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articleUpdateManyWithWhereWithoutUserInput | articleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articleScalarWhereInput | articleScalarWhereInput[]
  }

  export type articlestarUpdateManyWithoutUserNestedInput = {
    create?: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput> | articlestarCreateWithoutUserInput[] | articlestarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutUserInput | articlestarCreateOrConnectWithoutUserInput[]
    upsert?: articlestarUpsertWithWhereUniqueWithoutUserInput | articlestarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articlestarCreateManyUserInputEnvelope
    set?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    disconnect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    delete?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    update?: articlestarUpdateWithWhereUniqueWithoutUserInput | articlestarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articlestarUpdateManyWithWhereWithoutUserInput | articlestarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
  }

  export type articleviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput> | articleviewCreateWithoutUserInput[] | articleviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutUserInput | articleviewCreateOrConnectWithoutUserInput[]
    upsert?: articleviewUpsertWithWhereUniqueWithoutUserInput | articleviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articleviewCreateManyUserInputEnvelope
    set?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    disconnect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    delete?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    update?: articleviewUpdateWithWhereUniqueWithoutUserInput | articleviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articleviewUpdateManyWithWhereWithoutUserInput | articleviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
  }

  export type eventUpdateManyWithoutUserNestedInput = {
    create?: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput> | eventCreateWithoutUserInput[] | eventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUserInput | eventCreateOrConnectWithoutUserInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutUserInput | eventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: eventCreateManyUserInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutUserInput | eventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: eventUpdateManyWithWhereWithoutUserInput | eventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type eventregistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput> | eventregistrationCreateWithoutUserInput[] | eventregistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutUserInput | eventregistrationCreateOrConnectWithoutUserInput[]
    upsert?: eventregistrationUpsertWithWhereUniqueWithoutUserInput | eventregistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: eventregistrationCreateManyUserInputEnvelope
    set?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    disconnect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    delete?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    update?: eventregistrationUpdateWithWhereUniqueWithoutUserInput | eventregistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: eventregistrationUpdateManyWithWhereWithoutUserInput | eventregistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
  }

  export type refreshtokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type user_permissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput> | user_permissionsCreateWithoutUserInput[] | user_permissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUserInput | user_permissionsCreateOrConnectWithoutUserInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutUserInput | user_permissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_permissionsCreateManyUserInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutUserInput | user_permissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutUserInput | user_permissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type usersessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput> | usersessionCreateWithoutUserInput[] | usersessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usersessionCreateOrConnectWithoutUserInput | usersessionCreateOrConnectWithoutUserInput[]
    upsert?: usersessionUpsertWithWhereUniqueWithoutUserInput | usersessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: usersessionCreateManyUserInputEnvelope
    set?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    disconnect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    delete?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    connect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    update?: usersessionUpdateWithWhereUniqueWithoutUserInput | usersessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: usersessionUpdateManyWithWhereWithoutUserInput | usersessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: usersessionScalarWhereInput | usersessionScalarWhereInput[]
  }

  export type activitylogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput> | activitylogCreateWithoutUserInput[] | activitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutUserInput | activitylogCreateOrConnectWithoutUserInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutUserInput | activitylogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: activitylogCreateManyUserInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutUserInput | activitylogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutUserInput | activitylogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type articleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput> | articleCreateWithoutUserInput[] | articleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleCreateOrConnectWithoutUserInput | articleCreateOrConnectWithoutUserInput[]
    upsert?: articleUpsertWithWhereUniqueWithoutUserInput | articleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articleCreateManyUserInputEnvelope
    set?: articleWhereUniqueInput | articleWhereUniqueInput[]
    disconnect?: articleWhereUniqueInput | articleWhereUniqueInput[]
    delete?: articleWhereUniqueInput | articleWhereUniqueInput[]
    connect?: articleWhereUniqueInput | articleWhereUniqueInput[]
    update?: articleUpdateWithWhereUniqueWithoutUserInput | articleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articleUpdateManyWithWhereWithoutUserInput | articleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articleScalarWhereInput | articleScalarWhereInput[]
  }

  export type articlestarUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput> | articlestarCreateWithoutUserInput[] | articlestarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articlestarCreateOrConnectWithoutUserInput | articlestarCreateOrConnectWithoutUserInput[]
    upsert?: articlestarUpsertWithWhereUniqueWithoutUserInput | articlestarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articlestarCreateManyUserInputEnvelope
    set?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    disconnect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    delete?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    connect?: articlestarWhereUniqueInput | articlestarWhereUniqueInput[]
    update?: articlestarUpdateWithWhereUniqueWithoutUserInput | articlestarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articlestarUpdateManyWithWhereWithoutUserInput | articlestarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
  }

  export type articleviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput> | articleviewCreateWithoutUserInput[] | articleviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: articleviewCreateOrConnectWithoutUserInput | articleviewCreateOrConnectWithoutUserInput[]
    upsert?: articleviewUpsertWithWhereUniqueWithoutUserInput | articleviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: articleviewCreateManyUserInputEnvelope
    set?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    disconnect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    delete?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    connect?: articleviewWhereUniqueInput | articleviewWhereUniqueInput[]
    update?: articleviewUpdateWithWhereUniqueWithoutUserInput | articleviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: articleviewUpdateManyWithWhereWithoutUserInput | articleviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
  }

  export type eventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput> | eventCreateWithoutUserInput[] | eventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventCreateOrConnectWithoutUserInput | eventCreateOrConnectWithoutUserInput[]
    upsert?: eventUpsertWithWhereUniqueWithoutUserInput | eventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: eventCreateManyUserInputEnvelope
    set?: eventWhereUniqueInput | eventWhereUniqueInput[]
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[]
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[]
    update?: eventUpdateWithWhereUniqueWithoutUserInput | eventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: eventUpdateManyWithWhereWithoutUserInput | eventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[]
  }

  export type eventregistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput> | eventregistrationCreateWithoutUserInput[] | eventregistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: eventregistrationCreateOrConnectWithoutUserInput | eventregistrationCreateOrConnectWithoutUserInput[]
    upsert?: eventregistrationUpsertWithWhereUniqueWithoutUserInput | eventregistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: eventregistrationCreateManyUserInputEnvelope
    set?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    disconnect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    delete?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    connect?: eventregistrationWhereUniqueInput | eventregistrationWhereUniqueInput[]
    update?: eventregistrationUpdateWithWhereUniqueWithoutUserInput | eventregistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: eventregistrationUpdateManyWithWhereWithoutUserInput | eventregistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type user_permissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput> | user_permissionsCreateWithoutUserInput[] | user_permissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_permissionsCreateOrConnectWithoutUserInput | user_permissionsCreateOrConnectWithoutUserInput[]
    upsert?: user_permissionsUpsertWithWhereUniqueWithoutUserInput | user_permissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_permissionsCreateManyUserInputEnvelope
    set?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    disconnect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    delete?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    connect?: user_permissionsWhereUniqueInput | user_permissionsWhereUniqueInput[]
    update?: user_permissionsUpdateWithWhereUniqueWithoutUserInput | user_permissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_permissionsUpdateManyWithWhereWithoutUserInput | user_permissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
  }

  export type usersessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput> | usersessionCreateWithoutUserInput[] | usersessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: usersessionCreateOrConnectWithoutUserInput | usersessionCreateOrConnectWithoutUserInput[]
    upsert?: usersessionUpsertWithWhereUniqueWithoutUserInput | usersessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: usersessionCreateManyUserInputEnvelope
    set?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    disconnect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    delete?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    connect?: usersessionWhereUniqueInput | usersessionWhereUniqueInput[]
    update?: usersessionUpdateWithWhereUniqueWithoutUserInput | usersessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: usersessionUpdateManyWithWhereWithoutUserInput | usersessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: usersessionScalarWhereInput | usersessionScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_activityInput = {
    create?: XOR<usersCreateWithoutUser_activityInput, usersUncheckedCreateWithoutUser_activityInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_activityInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_activityNestedInput = {
    create?: XOR<usersCreateWithoutUser_activityInput, usersUncheckedCreateWithoutUser_activityInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_activityInput
    upsert?: usersUpsertWithoutUser_activityInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_activityInput, usersUpdateWithoutUser_activityInput>, usersUncheckedUpdateWithoutUser_activityInput>
  }

  export type credit_articlesCreateNestedOneWithoutUser_article_starsInput = {
    create?: XOR<credit_articlesCreateWithoutUser_article_starsInput, credit_articlesUncheckedCreateWithoutUser_article_starsInput>
    connectOrCreate?: credit_articlesCreateOrConnectWithoutUser_article_starsInput
    connect?: credit_articlesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_article_starsInput = {
    create?: XOR<usersCreateWithoutUser_article_starsInput, usersUncheckedCreateWithoutUser_article_starsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_article_starsInput
    connect?: usersWhereUniqueInput
  }

  export type credit_articlesUpdateOneRequiredWithoutUser_article_starsNestedInput = {
    create?: XOR<credit_articlesCreateWithoutUser_article_starsInput, credit_articlesUncheckedCreateWithoutUser_article_starsInput>
    connectOrCreate?: credit_articlesCreateOrConnectWithoutUser_article_starsInput
    upsert?: credit_articlesUpsertWithoutUser_article_starsInput
    connect?: credit_articlesWhereUniqueInput
    update?: XOR<XOR<credit_articlesUpdateToOneWithWhereWithoutUser_article_starsInput, credit_articlesUpdateWithoutUser_article_starsInput>, credit_articlesUncheckedUpdateWithoutUser_article_starsInput>
  }

  export type usersUpdateOneRequiredWithoutUser_article_starsNestedInput = {
    create?: XOR<usersCreateWithoutUser_article_starsInput, usersUncheckedCreateWithoutUser_article_starsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_article_starsInput
    upsert?: usersUpsertWithoutUser_article_starsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_article_starsInput, usersUpdateWithoutUser_article_starsInput>, usersUncheckedUpdateWithoutUser_article_starsInput>
  }

  export type permissionCreateNestedOneWithoutUser_permissionsInput = {
    create?: XOR<permissionCreateWithoutUser_permissionsInput, permissionUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutUser_permissionsInput
    connect?: permissionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUser_permissionsInput = {
    create?: XOR<userCreateWithoutUser_permissionsInput, userUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_permissionsInput
    connect?: userWhereUniqueInput
  }

  export type permissionUpdateOneRequiredWithoutUser_permissionsNestedInput = {
    create?: XOR<permissionCreateWithoutUser_permissionsInput, permissionUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutUser_permissionsInput
    upsert?: permissionUpsertWithoutUser_permissionsInput
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutUser_permissionsInput, permissionUpdateWithoutUser_permissionsInput>, permissionUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type userUpdateOneRequiredWithoutUser_permissionsNestedInput = {
    create?: XOR<userCreateWithoutUser_permissionsInput, userUncheckedCreateWithoutUser_permissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_permissionsInput
    upsert?: userUpsertWithoutUser_permissionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUser_permissionsInput, userUpdateWithoutUser_permissionsInput>, userUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type activity_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput> | activity_logsCreateWithoutUsersInput[] | activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: activity_logsCreateOrConnectWithoutUsersInput | activity_logsCreateOrConnectWithoutUsersInput[]
    createMany?: activity_logsCreateManyUsersInputEnvelope
    connect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
  }

  export type ai_assistant_configCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput> | ai_assistant_configCreateWithoutUsersInput[] | ai_assistant_configUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_assistant_configCreateOrConnectWithoutUsersInput | ai_assistant_configCreateOrConnectWithoutUsersInput[]
    createMany?: ai_assistant_configCreateManyUsersInputEnvelope
    connect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
  }

  export type ai_conversationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput> | ai_conversationsCreateWithoutUsersInput[] | ai_conversationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_conversationsCreateOrConnectWithoutUsersInput | ai_conversationsCreateOrConnectWithoutUsersInput[]
    createMany?: ai_conversationsCreateManyUsersInputEnvelope
    connect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
  }

  export type ai_entity_memoryCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput> | ai_entity_memoryCreateWithoutUsersInput[] | ai_entity_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_entity_memoryCreateOrConnectWithoutUsersInput | ai_entity_memoryCreateOrConnectWithoutUsersInput[]
    createMany?: ai_entity_memoryCreateManyUsersInputEnvelope
    connect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
  }

  export type ai_session_memoryCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput> | ai_session_memoryCreateWithoutUsersInput[] | ai_session_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_session_memoryCreateOrConnectWithoutUsersInput | ai_session_memoryCreateOrConnectWithoutUsersInput[]
    createMany?: ai_session_memoryCreateManyUsersInputEnvelope
    connect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
  }

  export type newsletter_subscriptionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput> | newsletter_subscriptionsCreateWithoutUsersInput[] | newsletter_subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutUsersInput | newsletter_subscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: newsletter_subscriptionsCreateManyUsersInputEnvelope
    connect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
  }

  export type user_activityCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput> | user_activityCreateWithoutUsersInput[] | user_activityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activityCreateOrConnectWithoutUsersInput | user_activityCreateOrConnectWithoutUsersInput[]
    createMany?: user_activityCreateManyUsersInputEnvelope
    connect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
  }

  export type user_article_starsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput> | user_article_starsCreateWithoutUsersInput[] | user_article_starsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutUsersInput | user_article_starsCreateOrConnectWithoutUsersInput[]
    createMany?: user_article_starsCreateManyUsersInputEnvelope
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
  }

  export type activity_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput> | activity_logsCreateWithoutUsersInput[] | activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: activity_logsCreateOrConnectWithoutUsersInput | activity_logsCreateOrConnectWithoutUsersInput[]
    createMany?: activity_logsCreateManyUsersInputEnvelope
    connect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
  }

  export type ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput> | ai_assistant_configCreateWithoutUsersInput[] | ai_assistant_configUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_assistant_configCreateOrConnectWithoutUsersInput | ai_assistant_configCreateOrConnectWithoutUsersInput[]
    createMany?: ai_assistant_configCreateManyUsersInputEnvelope
    connect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
  }

  export type ai_conversationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput> | ai_conversationsCreateWithoutUsersInput[] | ai_conversationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_conversationsCreateOrConnectWithoutUsersInput | ai_conversationsCreateOrConnectWithoutUsersInput[]
    createMany?: ai_conversationsCreateManyUsersInputEnvelope
    connect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
  }

  export type ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput> | ai_entity_memoryCreateWithoutUsersInput[] | ai_entity_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_entity_memoryCreateOrConnectWithoutUsersInput | ai_entity_memoryCreateOrConnectWithoutUsersInput[]
    createMany?: ai_entity_memoryCreateManyUsersInputEnvelope
    connect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
  }

  export type ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput> | ai_session_memoryCreateWithoutUsersInput[] | ai_session_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_session_memoryCreateOrConnectWithoutUsersInput | ai_session_memoryCreateOrConnectWithoutUsersInput[]
    createMany?: ai_session_memoryCreateManyUsersInputEnvelope
    connect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
  }

  export type newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput> | newsletter_subscriptionsCreateWithoutUsersInput[] | newsletter_subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutUsersInput | newsletter_subscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: newsletter_subscriptionsCreateManyUsersInputEnvelope
    connect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
  }

  export type user_activityUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput> | user_activityCreateWithoutUsersInput[] | user_activityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activityCreateOrConnectWithoutUsersInput | user_activityCreateOrConnectWithoutUsersInput[]
    createMany?: user_activityCreateManyUsersInputEnvelope
    connect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
  }

  export type user_article_starsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput> | user_article_starsCreateWithoutUsersInput[] | user_article_starsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutUsersInput | user_article_starsCreateOrConnectWithoutUsersInput[]
    createMany?: user_article_starsCreateManyUsersInputEnvelope
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
  }

  export type activity_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput> | activity_logsCreateWithoutUsersInput[] | activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: activity_logsCreateOrConnectWithoutUsersInput | activity_logsCreateOrConnectWithoutUsersInput[]
    upsert?: activity_logsUpsertWithWhereUniqueWithoutUsersInput | activity_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: activity_logsCreateManyUsersInputEnvelope
    set?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    disconnect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    delete?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    connect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    update?: activity_logsUpdateWithWhereUniqueWithoutUsersInput | activity_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: activity_logsUpdateManyWithWhereWithoutUsersInput | activity_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: activity_logsScalarWhereInput | activity_logsScalarWhereInput[]
  }

  export type ai_assistant_configUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput> | ai_assistant_configCreateWithoutUsersInput[] | ai_assistant_configUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_assistant_configCreateOrConnectWithoutUsersInput | ai_assistant_configCreateOrConnectWithoutUsersInput[]
    upsert?: ai_assistant_configUpsertWithWhereUniqueWithoutUsersInput | ai_assistant_configUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_assistant_configCreateManyUsersInputEnvelope
    set?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    disconnect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    delete?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    connect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    update?: ai_assistant_configUpdateWithWhereUniqueWithoutUsersInput | ai_assistant_configUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_assistant_configUpdateManyWithWhereWithoutUsersInput | ai_assistant_configUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_assistant_configScalarWhereInput | ai_assistant_configScalarWhereInput[]
  }

  export type ai_conversationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput> | ai_conversationsCreateWithoutUsersInput[] | ai_conversationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_conversationsCreateOrConnectWithoutUsersInput | ai_conversationsCreateOrConnectWithoutUsersInput[]
    upsert?: ai_conversationsUpsertWithWhereUniqueWithoutUsersInput | ai_conversationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_conversationsCreateManyUsersInputEnvelope
    set?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    disconnect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    delete?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    connect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    update?: ai_conversationsUpdateWithWhereUniqueWithoutUsersInput | ai_conversationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_conversationsUpdateManyWithWhereWithoutUsersInput | ai_conversationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_conversationsScalarWhereInput | ai_conversationsScalarWhereInput[]
  }

  export type ai_entity_memoryUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput> | ai_entity_memoryCreateWithoutUsersInput[] | ai_entity_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_entity_memoryCreateOrConnectWithoutUsersInput | ai_entity_memoryCreateOrConnectWithoutUsersInput[]
    upsert?: ai_entity_memoryUpsertWithWhereUniqueWithoutUsersInput | ai_entity_memoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_entity_memoryCreateManyUsersInputEnvelope
    set?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    disconnect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    delete?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    connect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    update?: ai_entity_memoryUpdateWithWhereUniqueWithoutUsersInput | ai_entity_memoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_entity_memoryUpdateManyWithWhereWithoutUsersInput | ai_entity_memoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_entity_memoryScalarWhereInput | ai_entity_memoryScalarWhereInput[]
  }

  export type ai_session_memoryUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput> | ai_session_memoryCreateWithoutUsersInput[] | ai_session_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_session_memoryCreateOrConnectWithoutUsersInput | ai_session_memoryCreateOrConnectWithoutUsersInput[]
    upsert?: ai_session_memoryUpsertWithWhereUniqueWithoutUsersInput | ai_session_memoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_session_memoryCreateManyUsersInputEnvelope
    set?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    disconnect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    delete?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    connect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    update?: ai_session_memoryUpdateWithWhereUniqueWithoutUsersInput | ai_session_memoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_session_memoryUpdateManyWithWhereWithoutUsersInput | ai_session_memoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_session_memoryScalarWhereInput | ai_session_memoryScalarWhereInput[]
  }

  export type newsletter_subscriptionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput> | newsletter_subscriptionsCreateWithoutUsersInput[] | newsletter_subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutUsersInput | newsletter_subscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: newsletter_subscriptionsUpsertWithWhereUniqueWithoutUsersInput | newsletter_subscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: newsletter_subscriptionsCreateManyUsersInputEnvelope
    set?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    disconnect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    delete?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    connect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    update?: newsletter_subscriptionsUpdateWithWhereUniqueWithoutUsersInput | newsletter_subscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: newsletter_subscriptionsUpdateManyWithWhereWithoutUsersInput | newsletter_subscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: newsletter_subscriptionsScalarWhereInput | newsletter_subscriptionsScalarWhereInput[]
  }

  export type user_activityUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput> | user_activityCreateWithoutUsersInput[] | user_activityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activityCreateOrConnectWithoutUsersInput | user_activityCreateOrConnectWithoutUsersInput[]
    upsert?: user_activityUpsertWithWhereUniqueWithoutUsersInput | user_activityUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_activityCreateManyUsersInputEnvelope
    set?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    disconnect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    delete?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    connect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    update?: user_activityUpdateWithWhereUniqueWithoutUsersInput | user_activityUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_activityUpdateManyWithWhereWithoutUsersInput | user_activityUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_activityScalarWhereInput | user_activityScalarWhereInput[]
  }

  export type user_article_starsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput> | user_article_starsCreateWithoutUsersInput[] | user_article_starsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutUsersInput | user_article_starsCreateOrConnectWithoutUsersInput[]
    upsert?: user_article_starsUpsertWithWhereUniqueWithoutUsersInput | user_article_starsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_article_starsCreateManyUsersInputEnvelope
    set?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    disconnect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    delete?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    update?: user_article_starsUpdateWithWhereUniqueWithoutUsersInput | user_article_starsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_article_starsUpdateManyWithWhereWithoutUsersInput | user_article_starsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
  }

  export type activity_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput> | activity_logsCreateWithoutUsersInput[] | activity_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: activity_logsCreateOrConnectWithoutUsersInput | activity_logsCreateOrConnectWithoutUsersInput[]
    upsert?: activity_logsUpsertWithWhereUniqueWithoutUsersInput | activity_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: activity_logsCreateManyUsersInputEnvelope
    set?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    disconnect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    delete?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    connect?: activity_logsWhereUniqueInput | activity_logsWhereUniqueInput[]
    update?: activity_logsUpdateWithWhereUniqueWithoutUsersInput | activity_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: activity_logsUpdateManyWithWhereWithoutUsersInput | activity_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: activity_logsScalarWhereInput | activity_logsScalarWhereInput[]
  }

  export type ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput> | ai_assistant_configCreateWithoutUsersInput[] | ai_assistant_configUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_assistant_configCreateOrConnectWithoutUsersInput | ai_assistant_configCreateOrConnectWithoutUsersInput[]
    upsert?: ai_assistant_configUpsertWithWhereUniqueWithoutUsersInput | ai_assistant_configUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_assistant_configCreateManyUsersInputEnvelope
    set?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    disconnect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    delete?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    connect?: ai_assistant_configWhereUniqueInput | ai_assistant_configWhereUniqueInput[]
    update?: ai_assistant_configUpdateWithWhereUniqueWithoutUsersInput | ai_assistant_configUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_assistant_configUpdateManyWithWhereWithoutUsersInput | ai_assistant_configUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_assistant_configScalarWhereInput | ai_assistant_configScalarWhereInput[]
  }

  export type ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput> | ai_conversationsCreateWithoutUsersInput[] | ai_conversationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_conversationsCreateOrConnectWithoutUsersInput | ai_conversationsCreateOrConnectWithoutUsersInput[]
    upsert?: ai_conversationsUpsertWithWhereUniqueWithoutUsersInput | ai_conversationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_conversationsCreateManyUsersInputEnvelope
    set?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    disconnect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    delete?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    connect?: ai_conversationsWhereUniqueInput | ai_conversationsWhereUniqueInput[]
    update?: ai_conversationsUpdateWithWhereUniqueWithoutUsersInput | ai_conversationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_conversationsUpdateManyWithWhereWithoutUsersInput | ai_conversationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_conversationsScalarWhereInput | ai_conversationsScalarWhereInput[]
  }

  export type ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput> | ai_entity_memoryCreateWithoutUsersInput[] | ai_entity_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_entity_memoryCreateOrConnectWithoutUsersInput | ai_entity_memoryCreateOrConnectWithoutUsersInput[]
    upsert?: ai_entity_memoryUpsertWithWhereUniqueWithoutUsersInput | ai_entity_memoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_entity_memoryCreateManyUsersInputEnvelope
    set?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    disconnect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    delete?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    connect?: ai_entity_memoryWhereUniqueInput | ai_entity_memoryWhereUniqueInput[]
    update?: ai_entity_memoryUpdateWithWhereUniqueWithoutUsersInput | ai_entity_memoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_entity_memoryUpdateManyWithWhereWithoutUsersInput | ai_entity_memoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_entity_memoryScalarWhereInput | ai_entity_memoryScalarWhereInput[]
  }

  export type ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput> | ai_session_memoryCreateWithoutUsersInput[] | ai_session_memoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ai_session_memoryCreateOrConnectWithoutUsersInput | ai_session_memoryCreateOrConnectWithoutUsersInput[]
    upsert?: ai_session_memoryUpsertWithWhereUniqueWithoutUsersInput | ai_session_memoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ai_session_memoryCreateManyUsersInputEnvelope
    set?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    disconnect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    delete?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    connect?: ai_session_memoryWhereUniqueInput | ai_session_memoryWhereUniqueInput[]
    update?: ai_session_memoryUpdateWithWhereUniqueWithoutUsersInput | ai_session_memoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ai_session_memoryUpdateManyWithWhereWithoutUsersInput | ai_session_memoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ai_session_memoryScalarWhereInput | ai_session_memoryScalarWhereInput[]
  }

  export type newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput> | newsletter_subscriptionsCreateWithoutUsersInput[] | newsletter_subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: newsletter_subscriptionsCreateOrConnectWithoutUsersInput | newsletter_subscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: newsletter_subscriptionsUpsertWithWhereUniqueWithoutUsersInput | newsletter_subscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: newsletter_subscriptionsCreateManyUsersInputEnvelope
    set?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    disconnect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    delete?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    connect?: newsletter_subscriptionsWhereUniqueInput | newsletter_subscriptionsWhereUniqueInput[]
    update?: newsletter_subscriptionsUpdateWithWhereUniqueWithoutUsersInput | newsletter_subscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: newsletter_subscriptionsUpdateManyWithWhereWithoutUsersInput | newsletter_subscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: newsletter_subscriptionsScalarWhereInput | newsletter_subscriptionsScalarWhereInput[]
  }

  export type user_activityUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput> | user_activityCreateWithoutUsersInput[] | user_activityUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_activityCreateOrConnectWithoutUsersInput | user_activityCreateOrConnectWithoutUsersInput[]
    upsert?: user_activityUpsertWithWhereUniqueWithoutUsersInput | user_activityUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_activityCreateManyUsersInputEnvelope
    set?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    disconnect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    delete?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    connect?: user_activityWhereUniqueInput | user_activityWhereUniqueInput[]
    update?: user_activityUpdateWithWhereUniqueWithoutUsersInput | user_activityUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_activityUpdateManyWithWhereWithoutUsersInput | user_activityUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_activityScalarWhereInput | user_activityScalarWhereInput[]
  }

  export type user_article_starsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput> | user_article_starsCreateWithoutUsersInput[] | user_article_starsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_article_starsCreateOrConnectWithoutUsersInput | user_article_starsCreateOrConnectWithoutUsersInput[]
    upsert?: user_article_starsUpsertWithWhereUniqueWithoutUsersInput | user_article_starsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_article_starsCreateManyUsersInputEnvelope
    set?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    disconnect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    delete?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    connect?: user_article_starsWhereUniqueInput | user_article_starsWhereUniqueInput[]
    update?: user_article_starsUpdateWithWhereUniqueWithoutUsersInput | user_article_starsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_article_starsUpdateManyWithWhereWithoutUsersInput | user_article_starsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutUsersessionInput = {
    create?: XOR<userCreateWithoutUsersessionInput, userUncheckedCreateWithoutUsersessionInput>
    connectOrCreate?: userCreateOrConnectWithoutUsersessionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUsersessionNestedInput = {
    create?: XOR<userCreateWithoutUsersessionInput, userUncheckedCreateWithoutUsersessionInput>
    connectOrCreate?: userCreateOrConnectWithoutUsersessionInput
    upsert?: userUpsertWithoutUsersessionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUsersessionInput, userUpdateWithoutUsersessionInput>, userUncheckedUpdateWithoutUsersessionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumpermissiontypeFilter<$PrismaModel = never> = {
    equals?: $Enums.permissiontype | EnumpermissiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumpermissiontypeFilter<$PrismaModel> | $Enums.permissiontype
  }

  export type NestedEnumpermissiontypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.permissiontype | EnumpermissiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.permissiontype[] | ListEnumpermissiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumpermissiontypeWithAggregatesFilter<$PrismaModel> | $Enums.permissiontype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpermissiontypeFilter<$PrismaModel>
    _max?: NestedEnumpermissiontypeFilter<$PrismaModel>
  }

  export type NestedEnumuserroleFilter<$PrismaModel = never> = {
    equals?: $Enums.userrole | EnumuserroleFieldRefInput<$PrismaModel>
    in?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserroleFilter<$PrismaModel> | $Enums.userrole
  }

  export type NestedEnumuserroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userrole | EnumuserroleFieldRefInput<$PrismaModel>
    in?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.userrole[] | ListEnumuserroleFieldRefInput<$PrismaModel>
    not?: NestedEnumuserroleWithAggregatesFilter<$PrismaModel> | $Enums.userrole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserroleFilter<$PrismaModel>
    _max?: NestedEnumuserroleFilter<$PrismaModel>
  }

  export type usersCreateWithoutActivity_logsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutActivity_logsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutActivity_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
  }

  export type usersUpsertWithoutActivity_logsInput = {
    update: XOR<usersUpdateWithoutActivity_logsInput, usersUncheckedUpdateWithoutActivity_logsInput>
    create: XOR<usersCreateWithoutActivity_logsInput, usersUncheckedCreateWithoutActivity_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutActivity_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutActivity_logsInput, usersUncheckedUpdateWithoutActivity_logsInput>
  }

  export type usersUpdateWithoutActivity_logsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutActivity_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type userCreateWithoutActivitylogInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutActivitylogInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutActivitylogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutActivitylogInput, userUncheckedCreateWithoutActivitylogInput>
  }

  export type userUpsertWithoutActivitylogInput = {
    update: XOR<userUpdateWithoutActivitylogInput, userUncheckedUpdateWithoutActivitylogInput>
    create: XOR<userCreateWithoutActivitylogInput, userUncheckedCreateWithoutActivitylogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutActivitylogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutActivitylogInput, userUncheckedUpdateWithoutActivitylogInput>
  }

  export type userUpdateWithoutActivitylogInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutActivitylogInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAi_assistant_configInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAi_assistant_configInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAi_assistant_configInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_assistant_configInput, usersUncheckedCreateWithoutAi_assistant_configInput>
  }

  export type usersUpsertWithoutAi_assistant_configInput = {
    update: XOR<usersUpdateWithoutAi_assistant_configInput, usersUncheckedUpdateWithoutAi_assistant_configInput>
    create: XOR<usersCreateWithoutAi_assistant_configInput, usersUncheckedCreateWithoutAi_assistant_configInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_assistant_configInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_assistant_configInput, usersUncheckedUpdateWithoutAi_assistant_configInput>
  }

  export type usersUpdateWithoutAi_assistant_configInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_assistant_configInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutAi_conversationsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAi_conversationsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAi_conversationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_conversationsInput, usersUncheckedCreateWithoutAi_conversationsInput>
  }

  export type usersUpsertWithoutAi_conversationsInput = {
    update: XOR<usersUpdateWithoutAi_conversationsInput, usersUncheckedUpdateWithoutAi_conversationsInput>
    create: XOR<usersCreateWithoutAi_conversationsInput, usersUncheckedCreateWithoutAi_conversationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_conversationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_conversationsInput, usersUncheckedUpdateWithoutAi_conversationsInput>
  }

  export type usersUpdateWithoutAi_conversationsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutAi_entity_memoryInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAi_entity_memoryInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAi_entity_memoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_entity_memoryInput, usersUncheckedCreateWithoutAi_entity_memoryInput>
  }

  export type usersUpsertWithoutAi_entity_memoryInput = {
    update: XOR<usersUpdateWithoutAi_entity_memoryInput, usersUncheckedUpdateWithoutAi_entity_memoryInput>
    create: XOR<usersCreateWithoutAi_entity_memoryInput, usersUncheckedCreateWithoutAi_entity_memoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_entity_memoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_entity_memoryInput, usersUncheckedUpdateWithoutAi_entity_memoryInput>
  }

  export type usersUpdateWithoutAi_entity_memoryInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_entity_memoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutAi_session_memoryInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAi_session_memoryInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAi_session_memoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAi_session_memoryInput, usersUncheckedCreateWithoutAi_session_memoryInput>
  }

  export type usersUpsertWithoutAi_session_memoryInput = {
    update: XOR<usersUpdateWithoutAi_session_memoryInput, usersUncheckedUpdateWithoutAi_session_memoryInput>
    create: XOR<usersCreateWithoutAi_session_memoryInput, usersUncheckedCreateWithoutAi_session_memoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAi_session_memoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAi_session_memoryInput, usersUncheckedUpdateWithoutAi_session_memoryInput>
  }

  export type usersUpdateWithoutAi_session_memoryInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAi_session_memoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type userCreateWithoutArticleInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutArticleInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutArticleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutArticleInput, userUncheckedCreateWithoutArticleInput>
  }

  export type article_tagsCreateWithoutArticleInput = {
    tag: tagCreateNestedOneWithoutArticle_tagsInput
  }

  export type article_tagsUncheckedCreateWithoutArticleInput = {
    tag_id: number
  }

  export type article_tagsCreateOrConnectWithoutArticleInput = {
    where: article_tagsWhereUniqueInput
    create: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput>
  }

  export type article_tagsCreateManyArticleInputEnvelope = {
    data: article_tagsCreateManyArticleInput | article_tagsCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type articlestarCreateWithoutArticleInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutArticlestarInput
  }

  export type articlestarUncheckedCreateWithoutArticleInput = {
    user_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articlestarCreateOrConnectWithoutArticleInput = {
    where: articlestarWhereUniqueInput
    create: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput>
  }

  export type articlestarCreateManyArticleInputEnvelope = {
    data: articlestarCreateManyArticleInput | articlestarCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type articleviewCreateWithoutArticleInput = {
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: userCreateNestedOneWithoutArticleviewInput
  }

  export type articleviewUncheckedCreateWithoutArticleInput = {
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewCreateOrConnectWithoutArticleInput = {
    where: articleviewWhereUniqueInput
    create: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput>
  }

  export type articleviewCreateManyArticleInputEnvelope = {
    data: articleviewCreateManyArticleInput | articleviewCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutArticleInput = {
    update: XOR<userUpdateWithoutArticleInput, userUncheckedUpdateWithoutArticleInput>
    create: XOR<userCreateWithoutArticleInput, userUncheckedCreateWithoutArticleInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutArticleInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutArticleInput, userUncheckedUpdateWithoutArticleInput>
  }

  export type userUpdateWithoutArticleInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutArticleInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type article_tagsUpsertWithWhereUniqueWithoutArticleInput = {
    where: article_tagsWhereUniqueInput
    update: XOR<article_tagsUpdateWithoutArticleInput, article_tagsUncheckedUpdateWithoutArticleInput>
    create: XOR<article_tagsCreateWithoutArticleInput, article_tagsUncheckedCreateWithoutArticleInput>
  }

  export type article_tagsUpdateWithWhereUniqueWithoutArticleInput = {
    where: article_tagsWhereUniqueInput
    data: XOR<article_tagsUpdateWithoutArticleInput, article_tagsUncheckedUpdateWithoutArticleInput>
  }

  export type article_tagsUpdateManyWithWhereWithoutArticleInput = {
    where: article_tagsScalarWhereInput
    data: XOR<article_tagsUpdateManyMutationInput, article_tagsUncheckedUpdateManyWithoutArticleInput>
  }

  export type article_tagsScalarWhereInput = {
    AND?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
    OR?: article_tagsScalarWhereInput[]
    NOT?: article_tagsScalarWhereInput | article_tagsScalarWhereInput[]
    article_id?: IntFilter<"article_tags"> | number
    tag_id?: IntFilter<"article_tags"> | number
  }

  export type articlestarUpsertWithWhereUniqueWithoutArticleInput = {
    where: articlestarWhereUniqueInput
    update: XOR<articlestarUpdateWithoutArticleInput, articlestarUncheckedUpdateWithoutArticleInput>
    create: XOR<articlestarCreateWithoutArticleInput, articlestarUncheckedCreateWithoutArticleInput>
  }

  export type articlestarUpdateWithWhereUniqueWithoutArticleInput = {
    where: articlestarWhereUniqueInput
    data: XOR<articlestarUpdateWithoutArticleInput, articlestarUncheckedUpdateWithoutArticleInput>
  }

  export type articlestarUpdateManyWithWhereWithoutArticleInput = {
    where: articlestarScalarWhereInput
    data: XOR<articlestarUpdateManyMutationInput, articlestarUncheckedUpdateManyWithoutArticleInput>
  }

  export type articlestarScalarWhereInput = {
    AND?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
    OR?: articlestarScalarWhereInput[]
    NOT?: articlestarScalarWhereInput | articlestarScalarWhereInput[]
    user_id?: IntFilter<"articlestar"> | number
    article_id?: IntFilter<"articlestar"> | number
    id?: IntFilter<"articlestar"> | number
    created_at?: DateTimeFilter<"articlestar"> | Date | string
    updated_at?: DateTimeFilter<"articlestar"> | Date | string
  }

  export type articleviewUpsertWithWhereUniqueWithoutArticleInput = {
    where: articleviewWhereUniqueInput
    update: XOR<articleviewUpdateWithoutArticleInput, articleviewUncheckedUpdateWithoutArticleInput>
    create: XOR<articleviewCreateWithoutArticleInput, articleviewUncheckedCreateWithoutArticleInput>
  }

  export type articleviewUpdateWithWhereUniqueWithoutArticleInput = {
    where: articleviewWhereUniqueInput
    data: XOR<articleviewUpdateWithoutArticleInput, articleviewUncheckedUpdateWithoutArticleInput>
  }

  export type articleviewUpdateManyWithWhereWithoutArticleInput = {
    where: articleviewScalarWhereInput
    data: XOR<articleviewUpdateManyMutationInput, articleviewUncheckedUpdateManyWithoutArticleInput>
  }

  export type articleviewScalarWhereInput = {
    AND?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
    OR?: articleviewScalarWhereInput[]
    NOT?: articleviewScalarWhereInput | articleviewScalarWhereInput[]
    article_id?: IntFilter<"articleview"> | number
    user_id?: IntNullableFilter<"articleview"> | number | null
    ip_address?: StringNullableFilter<"articleview"> | string | null
    user_agent?: StringNullableFilter<"articleview"> | string | null
    referrer?: StringNullableFilter<"articleview"> | string | null
    view_duration?: IntNullableFilter<"articleview"> | number | null
    id?: IntFilter<"articleview"> | number
    created_at?: DateTimeFilter<"articleview"> | Date | string
    updated_at?: DateTimeFilter<"articleview"> | Date | string
  }

  export type articleCreateWithoutArticle_tagsInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutArticleInput
    articlestar?: articlestarCreateNestedManyWithoutArticleInput
    articleview?: articleviewCreateNestedManyWithoutArticleInput
  }

  export type articleUncheckedCreateWithoutArticle_tagsInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_id?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    articlestar?: articlestarUncheckedCreateNestedManyWithoutArticleInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutArticleInput
  }

  export type articleCreateOrConnectWithoutArticle_tagsInput = {
    where: articleWhereUniqueInput
    create: XOR<articleCreateWithoutArticle_tagsInput, articleUncheckedCreateWithoutArticle_tagsInput>
  }

  export type tagCreateWithoutArticle_tagsInput = {
    name: string
    slug: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tagUncheckedCreateWithoutArticle_tagsInput = {
    name: string
    slug: string
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tagCreateOrConnectWithoutArticle_tagsInput = {
    where: tagWhereUniqueInput
    create: XOR<tagCreateWithoutArticle_tagsInput, tagUncheckedCreateWithoutArticle_tagsInput>
  }

  export type articleUpsertWithoutArticle_tagsInput = {
    update: XOR<articleUpdateWithoutArticle_tagsInput, articleUncheckedUpdateWithoutArticle_tagsInput>
    create: XOR<articleCreateWithoutArticle_tagsInput, articleUncheckedCreateWithoutArticle_tagsInput>
    where?: articleWhereInput
  }

  export type articleUpdateToOneWithWhereWithoutArticle_tagsInput = {
    where?: articleWhereInput
    data: XOR<articleUpdateWithoutArticle_tagsInput, articleUncheckedUpdateWithoutArticle_tagsInput>
  }

  export type articleUpdateWithoutArticle_tagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutArticleNestedInput
    articlestar?: articlestarUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateWithoutArticle_tagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlestar?: articlestarUncheckedUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type tagUpsertWithoutArticle_tagsInput = {
    update: XOR<tagUpdateWithoutArticle_tagsInput, tagUncheckedUpdateWithoutArticle_tagsInput>
    create: XOR<tagCreateWithoutArticle_tagsInput, tagUncheckedCreateWithoutArticle_tagsInput>
    where?: tagWhereInput
  }

  export type tagUpdateToOneWithWhereWithoutArticle_tagsInput = {
    where?: tagWhereInput
    data: XOR<tagUpdateWithoutArticle_tagsInput, tagUncheckedUpdateWithoutArticle_tagsInput>
  }

  export type tagUpdateWithoutArticle_tagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagUncheckedUpdateWithoutArticle_tagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleCreateWithoutArticlestarInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutArticleInput
    article_tags?: article_tagsCreateNestedManyWithoutArticleInput
    articleview?: articleviewCreateNestedManyWithoutArticleInput
  }

  export type articleUncheckedCreateWithoutArticlestarInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_id?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article_tags?: article_tagsUncheckedCreateNestedManyWithoutArticleInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutArticleInput
  }

  export type articleCreateOrConnectWithoutArticlestarInput = {
    where: articleWhereUniqueInput
    create: XOR<articleCreateWithoutArticlestarInput, articleUncheckedCreateWithoutArticlestarInput>
  }

  export type userCreateWithoutArticlestarInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutArticlestarInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutArticlestarInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutArticlestarInput, userUncheckedCreateWithoutArticlestarInput>
  }

  export type articleUpsertWithoutArticlestarInput = {
    update: XOR<articleUpdateWithoutArticlestarInput, articleUncheckedUpdateWithoutArticlestarInput>
    create: XOR<articleCreateWithoutArticlestarInput, articleUncheckedCreateWithoutArticlestarInput>
    where?: articleWhereInput
  }

  export type articleUpdateToOneWithWhereWithoutArticlestarInput = {
    where?: articleWhereInput
    data: XOR<articleUpdateWithoutArticlestarInput, articleUncheckedUpdateWithoutArticlestarInput>
  }

  export type articleUpdateWithoutArticlestarInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutArticleNestedInput
    article_tags?: article_tagsUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateWithoutArticlestarInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article_tags?: article_tagsUncheckedUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type userUpsertWithoutArticlestarInput = {
    update: XOR<userUpdateWithoutArticlestarInput, userUncheckedUpdateWithoutArticlestarInput>
    create: XOR<userCreateWithoutArticlestarInput, userUncheckedCreateWithoutArticlestarInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutArticlestarInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutArticlestarInput, userUncheckedUpdateWithoutArticlestarInput>
  }

  export type userUpdateWithoutArticlestarInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutArticlestarInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type articleCreateWithoutArticleviewInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutArticleInput
    article_tags?: article_tagsCreateNestedManyWithoutArticleInput
    articlestar?: articlestarCreateNestedManyWithoutArticleInput
  }

  export type articleUncheckedCreateWithoutArticleviewInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_id?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article_tags?: article_tagsUncheckedCreateNestedManyWithoutArticleInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutArticleInput
  }

  export type articleCreateOrConnectWithoutArticleviewInput = {
    where: articleWhereUniqueInput
    create: XOR<articleCreateWithoutArticleviewInput, articleUncheckedCreateWithoutArticleviewInput>
  }

  export type userCreateWithoutArticleviewInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutArticleviewInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutArticleviewInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutArticleviewInput, userUncheckedCreateWithoutArticleviewInput>
  }

  export type articleUpsertWithoutArticleviewInput = {
    update: XOR<articleUpdateWithoutArticleviewInput, articleUncheckedUpdateWithoutArticleviewInput>
    create: XOR<articleCreateWithoutArticleviewInput, articleUncheckedCreateWithoutArticleviewInput>
    where?: articleWhereInput
  }

  export type articleUpdateToOneWithWhereWithoutArticleviewInput = {
    where?: articleWhereInput
    data: XOR<articleUpdateWithoutArticleviewInput, articleUncheckedUpdateWithoutArticleviewInput>
  }

  export type articleUpdateWithoutArticleviewInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutArticleNestedInput
    article_tags?: article_tagsUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateWithoutArticleviewInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article_tags?: article_tagsUncheckedUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type userUpsertWithoutArticleviewInput = {
    update: XOR<userUpdateWithoutArticleviewInput, userUncheckedUpdateWithoutArticleviewInput>
    create: XOR<userCreateWithoutArticleviewInput, userUncheckedCreateWithoutArticleviewInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutArticleviewInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutArticleviewInput, userUncheckedUpdateWithoutArticleviewInput>
  }

  export type userUpdateWithoutArticleviewInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutArticleviewInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type user_article_starsCreateWithoutCredit_articlesInput = {
    starred_at?: Date | string
    users: usersCreateNestedOneWithoutUser_article_starsInput
  }

  export type user_article_starsUncheckedCreateWithoutCredit_articlesInput = {
    id?: number
    user_id: number
    starred_at?: Date | string
  }

  export type user_article_starsCreateOrConnectWithoutCredit_articlesInput = {
    where: user_article_starsWhereUniqueInput
    create: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput>
  }

  export type user_article_starsCreateManyCredit_articlesInputEnvelope = {
    data: user_article_starsCreateManyCredit_articlesInput | user_article_starsCreateManyCredit_articlesInput[]
    skipDuplicates?: boolean
  }

  export type user_article_starsUpsertWithWhereUniqueWithoutCredit_articlesInput = {
    where: user_article_starsWhereUniqueInput
    update: XOR<user_article_starsUpdateWithoutCredit_articlesInput, user_article_starsUncheckedUpdateWithoutCredit_articlesInput>
    create: XOR<user_article_starsCreateWithoutCredit_articlesInput, user_article_starsUncheckedCreateWithoutCredit_articlesInput>
  }

  export type user_article_starsUpdateWithWhereUniqueWithoutCredit_articlesInput = {
    where: user_article_starsWhereUniqueInput
    data: XOR<user_article_starsUpdateWithoutCredit_articlesInput, user_article_starsUncheckedUpdateWithoutCredit_articlesInput>
  }

  export type user_article_starsUpdateManyWithWhereWithoutCredit_articlesInput = {
    where: user_article_starsScalarWhereInput
    data: XOR<user_article_starsUpdateManyMutationInput, user_article_starsUncheckedUpdateManyWithoutCredit_articlesInput>
  }

  export type user_article_starsScalarWhereInput = {
    AND?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
    OR?: user_article_starsScalarWhereInput[]
    NOT?: user_article_starsScalarWhereInput | user_article_starsScalarWhereInput[]
    id?: IntFilter<"user_article_stars"> | number
    user_id?: IntFilter<"user_article_stars"> | number
    article_id?: IntFilter<"user_article_stars"> | number
    starred_at?: DateTimeFilter<"user_article_stars"> | Date | string
  }

  export type userCreateWithoutEventInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEventInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEventInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEventInput, userUncheckedCreateWithoutEventInput>
  }

  export type eventregistrationCreateWithoutEventInput = {
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutEventregistrationInput
  }

  export type eventregistrationUncheckedCreateWithoutEventInput = {
    user_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventregistrationCreateOrConnectWithoutEventInput = {
    where: eventregistrationWhereUniqueInput
    create: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput>
  }

  export type eventregistrationCreateManyEventInputEnvelope = {
    data: eventregistrationCreateManyEventInput | eventregistrationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutEventInput = {
    update: XOR<userUpdateWithoutEventInput, userUncheckedUpdateWithoutEventInput>
    create: XOR<userCreateWithoutEventInput, userUncheckedCreateWithoutEventInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEventInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEventInput, userUncheckedUpdateWithoutEventInput>
  }

  export type userUpdateWithoutEventInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEventInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type eventregistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: eventregistrationWhereUniqueInput
    update: XOR<eventregistrationUpdateWithoutEventInput, eventregistrationUncheckedUpdateWithoutEventInput>
    create: XOR<eventregistrationCreateWithoutEventInput, eventregistrationUncheckedCreateWithoutEventInput>
  }

  export type eventregistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: eventregistrationWhereUniqueInput
    data: XOR<eventregistrationUpdateWithoutEventInput, eventregistrationUncheckedUpdateWithoutEventInput>
  }

  export type eventregistrationUpdateManyWithWhereWithoutEventInput = {
    where: eventregistrationScalarWhereInput
    data: XOR<eventregistrationUpdateManyMutationInput, eventregistrationUncheckedUpdateManyWithoutEventInput>
  }

  export type eventregistrationScalarWhereInput = {
    AND?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
    OR?: eventregistrationScalarWhereInput[]
    NOT?: eventregistrationScalarWhereInput | eventregistrationScalarWhereInput[]
    event_id?: IntFilter<"eventregistration"> | number
    user_id?: IntFilter<"eventregistration"> | number
    registered_at?: DateTimeFilter<"eventregistration"> | Date | string
    is_confirmed?: BoolFilter<"eventregistration"> | boolean
    is_cancelled?: BoolFilter<"eventregistration"> | boolean
    cancelled_at?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    cancellation_reason?: StringNullableFilter<"eventregistration"> | string | null
    attended?: BoolFilter<"eventregistration"> | boolean
    check_in_time?: DateTimeNullableFilter<"eventregistration"> | Date | string | null
    dietary_requirements?: StringNullableFilter<"eventregistration"> | string | null
    special_requirements?: StringNullableFilter<"eventregistration"> | string | null
    id?: IntFilter<"eventregistration"> | number
    created_at?: DateTimeFilter<"eventregistration"> | Date | string
    updated_at?: DateTimeFilter<"eventregistration"> | Date | string
  }

  export type eventCreateWithoutEventregistrationInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    view_count: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user?: userCreateNestedOneWithoutEventInput
  }

  export type eventUncheckedCreateWithoutEventregistrationInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    created_by_id?: number | null
    view_count: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type eventCreateOrConnectWithoutEventregistrationInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutEventregistrationInput, eventUncheckedCreateWithoutEventregistrationInput>
  }

  export type userCreateWithoutEventregistrationInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEventregistrationInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEventregistrationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEventregistrationInput, userUncheckedCreateWithoutEventregistrationInput>
  }

  export type eventUpsertWithoutEventregistrationInput = {
    update: XOR<eventUpdateWithoutEventregistrationInput, eventUncheckedUpdateWithoutEventregistrationInput>
    create: XOR<eventCreateWithoutEventregistrationInput, eventUncheckedCreateWithoutEventregistrationInput>
    where?: eventWhereInput
  }

  export type eventUpdateToOneWithWhereWithoutEventregistrationInput = {
    where?: eventWhereInput
    data: XOR<eventUpdateWithoutEventregistrationInput, eventUncheckedUpdateWithoutEventregistrationInput>
  }

  export type eventUpdateWithoutEventregistrationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutEventNestedInput
  }

  export type eventUncheckedUpdateWithoutEventregistrationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    view_count?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutEventregistrationInput = {
    update: XOR<userUpdateWithoutEventregistrationInput, userUncheckedUpdateWithoutEventregistrationInput>
    create: XOR<userCreateWithoutEventregistrationInput, userUncheckedCreateWithoutEventregistrationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEventregistrationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEventregistrationInput, userUncheckedUpdateWithoutEventregistrationInput>
  }

  export type userUpdateWithoutEventregistrationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEventregistrationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type newsletter_subscriptionsCreateWithoutNewsletter_logsInput = {
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_preferences?: newsletter_preferencesCreateNestedManyWithoutNewsletter_subscriptionsInput
    users: usersCreateNestedOneWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsUncheckedCreateWithoutNewsletter_logsInput = {
    id?: number
    user_id: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_preferences?: newsletter_preferencesUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsCreateOrConnectWithoutNewsletter_logsInput = {
    where: newsletter_subscriptionsWhereUniqueInput
    create: XOR<newsletter_subscriptionsCreateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_logsInput>
  }

  export type newsletter_subscriptionsUpsertWithoutNewsletter_logsInput = {
    update: XOR<newsletter_subscriptionsUpdateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_logsInput>
    create: XOR<newsletter_subscriptionsCreateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_logsInput>
    where?: newsletter_subscriptionsWhereInput
  }

  export type newsletter_subscriptionsUpdateToOneWithWhereWithoutNewsletter_logsInput = {
    where?: newsletter_subscriptionsWhereInput
    data: XOR<newsletter_subscriptionsUpdateWithoutNewsletter_logsInput, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_logsInput>
  }

  export type newsletter_subscriptionsUpdateWithoutNewsletter_logsInput = {
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_preferences?: newsletter_preferencesUpdateManyWithoutNewsletter_subscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_logsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_preferences?: newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsCreateWithoutNewsletter_preferencesInput = {
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsCreateNestedManyWithoutNewsletter_subscriptionsInput
    users: usersCreateNestedOneWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsUncheckedCreateWithoutNewsletter_preferencesInput = {
    id?: number
    user_id: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsCreateOrConnectWithoutNewsletter_preferencesInput = {
    where: newsletter_subscriptionsWhereUniqueInput
    create: XOR<newsletter_subscriptionsCreateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_preferencesInput>
  }

  export type newsletter_subscriptionsUpsertWithoutNewsletter_preferencesInput = {
    update: XOR<newsletter_subscriptionsUpdateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_preferencesInput>
    create: XOR<newsletter_subscriptionsCreateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedCreateWithoutNewsletter_preferencesInput>
    where?: newsletter_subscriptionsWhereInput
  }

  export type newsletter_subscriptionsUpdateToOneWithWhereWithoutNewsletter_preferencesInput = {
    where?: newsletter_subscriptionsWhereInput
    data: XOR<newsletter_subscriptionsUpdateWithoutNewsletter_preferencesInput, newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_preferencesInput>
  }

  export type newsletter_subscriptionsUpdateWithoutNewsletter_preferencesInput = {
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUpdateManyWithoutNewsletter_subscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsUncheckedUpdateWithoutNewsletter_preferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_logsCreateWithoutNewsletter_subscriptionsInput = {
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
  }

  export type newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput = {
    id?: number
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
  }

  export type newsletter_logsCreateOrConnectWithoutNewsletter_subscriptionsInput = {
    where: newsletter_logsWhereUniqueInput
    create: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsCreateManyNewsletter_subscriptionsInputEnvelope = {
    data: newsletter_logsCreateManyNewsletter_subscriptionsInput | newsletter_logsCreateManyNewsletter_subscriptionsInput[]
    skipDuplicates?: boolean
  }

  export type newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput = {
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput = {
    id?: number
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_preferencesCreateOrConnectWithoutNewsletter_subscriptionsInput = {
    where: newsletter_preferencesWhereUniqueInput
    create: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_preferencesCreateManyNewsletter_subscriptionsInputEnvelope = {
    data: newsletter_preferencesCreateManyNewsletter_subscriptionsInput | newsletter_preferencesCreateManyNewsletter_subscriptionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutNewsletter_subscriptionsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNewsletter_subscriptionsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNewsletter_subscriptionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNewsletter_subscriptionsInput, usersUncheckedCreateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput = {
    where: newsletter_logsWhereUniqueInput
    update: XOR<newsletter_logsUpdateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedUpdateWithoutNewsletter_subscriptionsInput>
    create: XOR<newsletter_logsCreateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedCreateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput = {
    where: newsletter_logsWhereUniqueInput
    data: XOR<newsletter_logsUpdateWithoutNewsletter_subscriptionsInput, newsletter_logsUncheckedUpdateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsUpdateManyWithWhereWithoutNewsletter_subscriptionsInput = {
    where: newsletter_logsScalarWhereInput
    data: XOR<newsletter_logsUpdateManyMutationInput, newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_logsScalarWhereInput = {
    AND?: newsletter_logsScalarWhereInput | newsletter_logsScalarWhereInput[]
    OR?: newsletter_logsScalarWhereInput[]
    NOT?: newsletter_logsScalarWhereInput | newsletter_logsScalarWhereInput[]
    id?: IntFilter<"newsletter_logs"> | number
    subscription_id?: IntFilter<"newsletter_logs"> | number
    sent_at?: DateTimeNullableFilter<"newsletter_logs"> | Date | string | null
    email_to?: StringFilter<"newsletter_logs"> | string
    email_subject?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_count?: IntNullableFilter<"newsletter_logs"> | number | null
    success?: BoolNullableFilter<"newsletter_logs"> | boolean | null
    error_message?: StringNullableFilter<"newsletter_logs"> | string | null
    articles_included?: JsonNullableFilter<"newsletter_logs">
    email_content_preview?: StringNullableFilter<"newsletter_logs"> | string | null
  }

  export type newsletter_preferencesUpsertWithWhereUniqueWithoutNewsletter_subscriptionsInput = {
    where: newsletter_preferencesWhereUniqueInput
    update: XOR<newsletter_preferencesUpdateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedUpdateWithoutNewsletter_subscriptionsInput>
    create: XOR<newsletter_preferencesCreateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedCreateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_preferencesUpdateWithWhereUniqueWithoutNewsletter_subscriptionsInput = {
    where: newsletter_preferencesWhereUniqueInput
    data: XOR<newsletter_preferencesUpdateWithoutNewsletter_subscriptionsInput, newsletter_preferencesUncheckedUpdateWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_preferencesUpdateManyWithWhereWithoutNewsletter_subscriptionsInput = {
    where: newsletter_preferencesScalarWhereInput
    data: XOR<newsletter_preferencesUpdateManyMutationInput, newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsInput>
  }

  export type newsletter_preferencesScalarWhereInput = {
    AND?: newsletter_preferencesScalarWhereInput | newsletter_preferencesScalarWhereInput[]
    OR?: newsletter_preferencesScalarWhereInput[]
    NOT?: newsletter_preferencesScalarWhereInput | newsletter_preferencesScalarWhereInput[]
    id?: IntFilter<"newsletter_preferences"> | number
    subscription_id?: IntFilter<"newsletter_preferences"> | number
    sources?: StringNullableListFilter<"newsletter_preferences">
    regions?: StringNullableListFilter<"newsletter_preferences">
    sectors?: StringNullableListFilter<"newsletter_preferences">
    include_starred_only?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    frequency?: StringFilter<"newsletter_preferences"> | string
    day_of_week?: IntNullableFilter<"newsletter_preferences"> | number | null
    time_of_day?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    timezone?: StringNullableFilter<"newsletter_preferences"> | string | null
    max_articles_per_email?: IntNullableFilter<"newsletter_preferences"> | number | null
    include_summary?: BoolNullableFilter<"newsletter_preferences"> | boolean | null
    created_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_preferences"> | Date | string | null
  }

  export type usersUpsertWithoutNewsletter_subscriptionsInput = {
    update: XOR<usersUpdateWithoutNewsletter_subscriptionsInput, usersUncheckedUpdateWithoutNewsletter_subscriptionsInput>
    create: XOR<usersCreateWithoutNewsletter_subscriptionsInput, usersUncheckedCreateWithoutNewsletter_subscriptionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNewsletter_subscriptionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNewsletter_subscriptionsInput, usersUncheckedUpdateWithoutNewsletter_subscriptionsInput>
  }

  export type usersUpdateWithoutNewsletter_subscriptionsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNewsletter_subscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type user_permissionsCreateWithoutPermissionInput = {
    user: userCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateWithoutPermissionInput = {
    user_id: number
  }

  export type user_permissionsCreateOrConnectWithoutPermissionInput = {
    where: user_permissionsWhereUniqueInput
    create: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput>
  }

  export type user_permissionsCreateManyPermissionInputEnvelope = {
    data: user_permissionsCreateManyPermissionInput | user_permissionsCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type user_permissionsUpsertWithWhereUniqueWithoutPermissionInput = {
    where: user_permissionsWhereUniqueInput
    update: XOR<user_permissionsUpdateWithoutPermissionInput, user_permissionsUncheckedUpdateWithoutPermissionInput>
    create: XOR<user_permissionsCreateWithoutPermissionInput, user_permissionsUncheckedCreateWithoutPermissionInput>
  }

  export type user_permissionsUpdateWithWhereUniqueWithoutPermissionInput = {
    where: user_permissionsWhereUniqueInput
    data: XOR<user_permissionsUpdateWithoutPermissionInput, user_permissionsUncheckedUpdateWithoutPermissionInput>
  }

  export type user_permissionsUpdateManyWithWhereWithoutPermissionInput = {
    where: user_permissionsScalarWhereInput
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyWithoutPermissionInput>
  }

  export type user_permissionsScalarWhereInput = {
    AND?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
    OR?: user_permissionsScalarWhereInput[]
    NOT?: user_permissionsScalarWhereInput | user_permissionsScalarWhereInput[]
    user_id?: IntFilter<"user_permissions"> | number
    permission_id?: IntFilter<"user_permissions"> | number
  }

  export type userCreateWithoutRefreshtokenInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRefreshtokenInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRefreshtokenInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
  }

  export type userUpsertWithoutRefreshtokenInput = {
    update: XOR<userUpdateWithoutRefreshtokenInput, userUncheckedUpdateWithoutRefreshtokenInput>
    create: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRefreshtokenInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRefreshtokenInput, userUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type userUpdateWithoutRefreshtokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRefreshtokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type article_tagsCreateWithoutTagInput = {
    article: articleCreateNestedOneWithoutArticle_tagsInput
  }

  export type article_tagsUncheckedCreateWithoutTagInput = {
    article_id: number
  }

  export type article_tagsCreateOrConnectWithoutTagInput = {
    where: article_tagsWhereUniqueInput
    create: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput>
  }

  export type article_tagsCreateManyTagInputEnvelope = {
    data: article_tagsCreateManyTagInput | article_tagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type article_tagsUpsertWithWhereUniqueWithoutTagInput = {
    where: article_tagsWhereUniqueInput
    update: XOR<article_tagsUpdateWithoutTagInput, article_tagsUncheckedUpdateWithoutTagInput>
    create: XOR<article_tagsCreateWithoutTagInput, article_tagsUncheckedCreateWithoutTagInput>
  }

  export type article_tagsUpdateWithWhereUniqueWithoutTagInput = {
    where: article_tagsWhereUniqueInput
    data: XOR<article_tagsUpdateWithoutTagInput, article_tagsUncheckedUpdateWithoutTagInput>
  }

  export type article_tagsUpdateManyWithWhereWithoutTagInput = {
    where: article_tagsScalarWhereInput
    data: XOR<article_tagsUpdateManyMutationInput, article_tagsUncheckedUpdateManyWithoutTagInput>
  }

  export type activitylogCreateWithoutUserInput = {
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activitylogUncheckedCreateWithoutUserInput = {
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activitylogCreateOrConnectWithoutUserInput = {
    where: activitylogWhereUniqueInput
    create: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput>
  }

  export type activitylogCreateManyUserInputEnvelope = {
    data: activitylogCreateManyUserInput | activitylogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type articleCreateWithoutUserInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article_tags?: article_tagsCreateNestedManyWithoutArticleInput
    articlestar?: articlestarCreateNestedManyWithoutArticleInput
    articleview?: articleviewCreateNestedManyWithoutArticleInput
  }

  export type articleUncheckedCreateWithoutUserInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    article_tags?: article_tagsUncheckedCreateNestedManyWithoutArticleInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutArticleInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutArticleInput
  }

  export type articleCreateOrConnectWithoutUserInput = {
    where: articleWhereUniqueInput
    create: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput>
  }

  export type articleCreateManyUserInputEnvelope = {
    data: articleCreateManyUserInput | articleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type articlestarCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    article: articleCreateNestedOneWithoutArticlestarInput
  }

  export type articlestarUncheckedCreateWithoutUserInput = {
    article_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articlestarCreateOrConnectWithoutUserInput = {
    where: articlestarWhereUniqueInput
    create: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput>
  }

  export type articlestarCreateManyUserInputEnvelope = {
    data: articlestarCreateManyUserInput | articlestarCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type articleviewCreateWithoutUserInput = {
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    article: articleCreateNestedOneWithoutArticleviewInput
  }

  export type articleviewUncheckedCreateWithoutUserInput = {
    article_id: number
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewCreateOrConnectWithoutUserInput = {
    where: articleviewWhereUniqueInput
    create: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput>
  }

  export type articleviewCreateManyUserInputEnvelope = {
    data: articleviewCreateManyUserInput | articleviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type eventCreateWithoutUserInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    view_count: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    eventregistration?: eventregistrationCreateNestedManyWithoutEventInput
  }

  export type eventUncheckedCreateWithoutUserInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    view_count: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type eventCreateOrConnectWithoutUserInput = {
    where: eventWhereUniqueInput
    create: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput>
  }

  export type eventCreateManyUserInputEnvelope = {
    data: eventCreateManyUserInput | eventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type eventregistrationCreateWithoutUserInput = {
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    event: eventCreateNestedOneWithoutEventregistrationInput
  }

  export type eventregistrationUncheckedCreateWithoutUserInput = {
    event_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventregistrationCreateOrConnectWithoutUserInput = {
    where: eventregistrationWhereUniqueInput
    create: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput>
  }

  export type eventregistrationCreateManyUserInputEnvelope = {
    data: eventregistrationCreateManyUserInput | eventregistrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type refreshtokenCreateWithoutUserInput = {
    token: string
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type refreshtokenUncheckedCreateWithoutUserInput = {
    token: string
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type refreshtokenCreateOrConnectWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenCreateManyUserInputEnvelope = {
    data: refreshtokenCreateManyUserInput | refreshtokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_permissionsCreateWithoutUserInput = {
    permission: permissionCreateNestedOneWithoutUser_permissionsInput
  }

  export type user_permissionsUncheckedCreateWithoutUserInput = {
    permission_id: number
  }

  export type user_permissionsCreateOrConnectWithoutUserInput = {
    where: user_permissionsWhereUniqueInput
    create: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput>
  }

  export type user_permissionsCreateManyUserInputEnvelope = {
    data: user_permissionsCreateManyUserInput | user_permissionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type usersessionCreateWithoutUserInput = {
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersessionUncheckedCreateWithoutUserInput = {
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersessionCreateOrConnectWithoutUserInput = {
    where: usersessionWhereUniqueInput
    create: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput>
  }

  export type usersessionCreateManyUserInputEnvelope = {
    data: usersessionCreateManyUserInput | usersessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type activitylogUpsertWithWhereUniqueWithoutUserInput = {
    where: activitylogWhereUniqueInput
    update: XOR<activitylogUpdateWithoutUserInput, activitylogUncheckedUpdateWithoutUserInput>
    create: XOR<activitylogCreateWithoutUserInput, activitylogUncheckedCreateWithoutUserInput>
  }

  export type activitylogUpdateWithWhereUniqueWithoutUserInput = {
    where: activitylogWhereUniqueInput
    data: XOR<activitylogUpdateWithoutUserInput, activitylogUncheckedUpdateWithoutUserInput>
  }

  export type activitylogUpdateManyWithWhereWithoutUserInput = {
    where: activitylogScalarWhereInput
    data: XOR<activitylogUpdateManyMutationInput, activitylogUncheckedUpdateManyWithoutUserInput>
  }

  export type activitylogScalarWhereInput = {
    AND?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
    OR?: activitylogScalarWhereInput[]
    NOT?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
    user_id?: IntNullableFilter<"activitylog"> | number | null
    action?: StringFilter<"activitylog"> | string
    resource?: StringNullableFilter<"activitylog"> | string | null
    resource_id?: StringNullableFilter<"activitylog"> | string | null
    details?: StringNullableFilter<"activitylog"> | string | null
    ip_address?: StringNullableFilter<"activitylog"> | string | null
    user_agent?: StringNullableFilter<"activitylog"> | string | null
    status?: StringFilter<"activitylog"> | string
    error?: StringNullableFilter<"activitylog"> | string | null
    request_id?: StringNullableFilter<"activitylog"> | string | null
    id?: IntFilter<"activitylog"> | number
    created_at?: DateTimeFilter<"activitylog"> | Date | string
    updated_at?: DateTimeFilter<"activitylog"> | Date | string
  }

  export type articleUpsertWithWhereUniqueWithoutUserInput = {
    where: articleWhereUniqueInput
    update: XOR<articleUpdateWithoutUserInput, articleUncheckedUpdateWithoutUserInput>
    create: XOR<articleCreateWithoutUserInput, articleUncheckedCreateWithoutUserInput>
  }

  export type articleUpdateWithWhereUniqueWithoutUserInput = {
    where: articleWhereUniqueInput
    data: XOR<articleUpdateWithoutUserInput, articleUncheckedUpdateWithoutUserInput>
  }

  export type articleUpdateManyWithWhereWithoutUserInput = {
    where: articleScalarWhereInput
    data: XOR<articleUpdateManyMutationInput, articleUncheckedUpdateManyWithoutUserInput>
  }

  export type articleScalarWhereInput = {
    AND?: articleScalarWhereInput | articleScalarWhereInput[]
    OR?: articleScalarWhereInput[]
    NOT?: articleScalarWhereInput | articleScalarWhereInput[]
    title?: StringFilter<"article"> | string
    slug?: StringFilter<"article"> | string
    summary?: StringNullableFilter<"article"> | string | null
    content?: StringNullableFilter<"article"> | string | null
    source?: StringNullableFilter<"article"> | string | null
    source_url?: StringNullableFilter<"article"> | string | null
    published_at?: DateTimeNullableFilter<"article"> | Date | string | null
    category?: StringNullableFilter<"article"> | string | null
    region?: StringNullableFilter<"article"> | string | null
    sector?: StringNullableFilter<"article"> | string | null
    keywords?: JsonNullableFilter<"article">
    sentiment_score?: FloatNullableFilter<"article"> | number | null
    relevance_score?: FloatNullableFilter<"article"> | number | null
    author_id?: IntNullableFilter<"article"> | number | null
    author_name?: StringNullableFilter<"article"> | string | null
    is_published?: BoolFilter<"article"> | boolean
    is_featured?: BoolFilter<"article"> | boolean
    view_count?: IntFilter<"article"> | number
    unique_viewers?: IntFilter<"article"> | number
    ai_summary?: StringNullableFilter<"article"> | string | null
    ai_summary_provider?: StringNullableFilter<"article"> | string | null
    ai_summary_generated_at?: DateTimeNullableFilter<"article"> | Date | string | null
    id?: IntFilter<"article"> | number
    created_at?: DateTimeFilter<"article"> | Date | string
    updated_at?: DateTimeFilter<"article"> | Date | string
    is_deleted?: BoolFilter<"article"> | boolean
    deleted_at?: DateTimeNullableFilter<"article"> | Date | string | null
  }

  export type articlestarUpsertWithWhereUniqueWithoutUserInput = {
    where: articlestarWhereUniqueInput
    update: XOR<articlestarUpdateWithoutUserInput, articlestarUncheckedUpdateWithoutUserInput>
    create: XOR<articlestarCreateWithoutUserInput, articlestarUncheckedCreateWithoutUserInput>
  }

  export type articlestarUpdateWithWhereUniqueWithoutUserInput = {
    where: articlestarWhereUniqueInput
    data: XOR<articlestarUpdateWithoutUserInput, articlestarUncheckedUpdateWithoutUserInput>
  }

  export type articlestarUpdateManyWithWhereWithoutUserInput = {
    where: articlestarScalarWhereInput
    data: XOR<articlestarUpdateManyMutationInput, articlestarUncheckedUpdateManyWithoutUserInput>
  }

  export type articleviewUpsertWithWhereUniqueWithoutUserInput = {
    where: articleviewWhereUniqueInput
    update: XOR<articleviewUpdateWithoutUserInput, articleviewUncheckedUpdateWithoutUserInput>
    create: XOR<articleviewCreateWithoutUserInput, articleviewUncheckedCreateWithoutUserInput>
  }

  export type articleviewUpdateWithWhereUniqueWithoutUserInput = {
    where: articleviewWhereUniqueInput
    data: XOR<articleviewUpdateWithoutUserInput, articleviewUncheckedUpdateWithoutUserInput>
  }

  export type articleviewUpdateManyWithWhereWithoutUserInput = {
    where: articleviewScalarWhereInput
    data: XOR<articleviewUpdateManyMutationInput, articleviewUncheckedUpdateManyWithoutUserInput>
  }

  export type eventUpsertWithWhereUniqueWithoutUserInput = {
    where: eventWhereUniqueInput
    update: XOR<eventUpdateWithoutUserInput, eventUncheckedUpdateWithoutUserInput>
    create: XOR<eventCreateWithoutUserInput, eventUncheckedCreateWithoutUserInput>
  }

  export type eventUpdateWithWhereUniqueWithoutUserInput = {
    where: eventWhereUniqueInput
    data: XOR<eventUpdateWithoutUserInput, eventUncheckedUpdateWithoutUserInput>
  }

  export type eventUpdateManyWithWhereWithoutUserInput = {
    where: eventScalarWhereInput
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyWithoutUserInput>
  }

  export type eventScalarWhereInput = {
    AND?: eventScalarWhereInput | eventScalarWhereInput[]
    OR?: eventScalarWhereInput[]
    NOT?: eventScalarWhereInput | eventScalarWhereInput[]
    title?: StringFilter<"event"> | string
    slug?: StringFilter<"event"> | string
    description?: StringNullableFilter<"event"> | string | null
    event_type?: StringNullableFilter<"event"> | string | null
    location?: StringNullableFilter<"event"> | string | null
    venue?: StringNullableFilter<"event"> | string | null
    is_virtual?: BoolFilter<"event"> | boolean
    virtual_link?: StringNullableFilter<"event"> | string | null
    start_date?: DateTimeFilter<"event"> | Date | string
    end_date?: DateTimeNullableFilter<"event"> | Date | string | null
    timezone?: StringNullableFilter<"event"> | string | null
    registration_link?: StringNullableFilter<"event"> | string | null
    registration_deadline?: DateTimeNullableFilter<"event"> | Date | string | null
    max_attendees?: IntNullableFilter<"event"> | number | null
    price?: FloatNullableFilter<"event"> | number | null
    currency?: StringNullableFilter<"event"> | string | null
    organizer?: StringNullableFilter<"event"> | string | null
    organizer_email?: StringNullableFilter<"event"> | string | null
    organizer_phone?: StringNullableFilter<"event"> | string | null
    sponsors?: JsonNullableFilter<"event">
    agenda?: StringNullableFilter<"event"> | string | null
    speakers?: JsonNullableFilter<"event">
    tags?: JsonNullableFilter<"event">
    source?: StringNullableFilter<"event"> | string | null
    source_url?: StringNullableFilter<"event"> | string | null
    is_published?: BoolFilter<"event"> | boolean
    is_featured?: BoolFilter<"event"> | boolean
    is_cancelled?: BoolFilter<"event"> | boolean
    cancellation_reason?: StringNullableFilter<"event"> | string | null
    created_by_id?: IntNullableFilter<"event"> | number | null
    view_count?: IntFilter<"event"> | number
    id?: IntFilter<"event"> | number
    created_at?: DateTimeFilter<"event"> | Date | string
    updated_at?: DateTimeFilter<"event"> | Date | string
    is_deleted?: BoolFilter<"event"> | boolean
    deleted_at?: DateTimeNullableFilter<"event"> | Date | string | null
  }

  export type eventregistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: eventregistrationWhereUniqueInput
    update: XOR<eventregistrationUpdateWithoutUserInput, eventregistrationUncheckedUpdateWithoutUserInput>
    create: XOR<eventregistrationCreateWithoutUserInput, eventregistrationUncheckedCreateWithoutUserInput>
  }

  export type eventregistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: eventregistrationWhereUniqueInput
    data: XOR<eventregistrationUpdateWithoutUserInput, eventregistrationUncheckedUpdateWithoutUserInput>
  }

  export type eventregistrationUpdateManyWithWhereWithoutUserInput = {
    where: eventregistrationScalarWhereInput
    data: XOR<eventregistrationUpdateManyMutationInput, eventregistrationUncheckedUpdateManyWithoutUserInput>
  }

  export type refreshtokenUpsertWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    update: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenUpdateWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    data: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
  }

  export type refreshtokenUpdateManyWithWhereWithoutUserInput = {
    where: refreshtokenScalarWhereInput
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyWithoutUserInput>
  }

  export type refreshtokenScalarWhereInput = {
    AND?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    OR?: refreshtokenScalarWhereInput[]
    NOT?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    token?: StringFilter<"refreshtoken"> | string
    user_id?: IntFilter<"refreshtoken"> | number
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    revoked?: BoolFilter<"refreshtoken"> | boolean
    revoked_at?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    id?: IntFilter<"refreshtoken"> | number
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    updated_at?: DateTimeFilter<"refreshtoken"> | Date | string
  }

  export type user_permissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: user_permissionsWhereUniqueInput
    update: XOR<user_permissionsUpdateWithoutUserInput, user_permissionsUncheckedUpdateWithoutUserInput>
    create: XOR<user_permissionsCreateWithoutUserInput, user_permissionsUncheckedCreateWithoutUserInput>
  }

  export type user_permissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: user_permissionsWhereUniqueInput
    data: XOR<user_permissionsUpdateWithoutUserInput, user_permissionsUncheckedUpdateWithoutUserInput>
  }

  export type user_permissionsUpdateManyWithWhereWithoutUserInput = {
    where: user_permissionsScalarWhereInput
    data: XOR<user_permissionsUpdateManyMutationInput, user_permissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type usersessionUpsertWithWhereUniqueWithoutUserInput = {
    where: usersessionWhereUniqueInput
    update: XOR<usersessionUpdateWithoutUserInput, usersessionUncheckedUpdateWithoutUserInput>
    create: XOR<usersessionCreateWithoutUserInput, usersessionUncheckedCreateWithoutUserInput>
  }

  export type usersessionUpdateWithWhereUniqueWithoutUserInput = {
    where: usersessionWhereUniqueInput
    data: XOR<usersessionUpdateWithoutUserInput, usersessionUncheckedUpdateWithoutUserInput>
  }

  export type usersessionUpdateManyWithWhereWithoutUserInput = {
    where: usersessionScalarWhereInput
    data: XOR<usersessionUpdateManyMutationInput, usersessionUncheckedUpdateManyWithoutUserInput>
  }

  export type usersessionScalarWhereInput = {
    AND?: usersessionScalarWhereInput | usersessionScalarWhereInput[]
    OR?: usersessionScalarWhereInput[]
    NOT?: usersessionScalarWhereInput | usersessionScalarWhereInput[]
    user_id?: IntFilter<"usersession"> | number
    session_id?: StringFilter<"usersession"> | string
    ip_address?: StringNullableFilter<"usersession"> | string | null
    user_agent?: StringNullableFilter<"usersession"> | string | null
    last_activity?: DateTimeFilter<"usersession"> | Date | string
    expires_at?: DateTimeFilter<"usersession"> | Date | string
    id?: IntFilter<"usersession"> | number
    created_at?: DateTimeFilter<"usersession"> | Date | string
    updated_at?: DateTimeFilter<"usersession"> | Date | string
  }

  export type usersCreateWithoutUser_activityInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_activityInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_article_stars?: user_article_starsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_activityInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_activityInput, usersUncheckedCreateWithoutUser_activityInput>
  }

  export type usersUpsertWithoutUser_activityInput = {
    update: XOR<usersUpdateWithoutUser_activityInput, usersUncheckedUpdateWithoutUser_activityInput>
    create: XOR<usersCreateWithoutUser_activityInput, usersUncheckedCreateWithoutUser_activityInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_activityInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_activityInput, usersUncheckedUpdateWithoutUser_activityInput>
  }

  export type usersUpdateWithoutUser_activityInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_activityInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_article_stars?: user_article_starsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type credit_articlesCreateWithoutUser_article_starsInput = {
    title?: string | null
    date?: Date | string | null
    content?: string | null
    link?: string | null
    source?: string | null
    matched_keywords?: string | null
    region?: string | null
    sector?: string | null
    starred?: boolean | null
    starred_at?: Date | string | null
    summary?: string | null
    url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type credit_articlesUncheckedCreateWithoutUser_article_starsInput = {
    id?: number
    title?: string | null
    date?: Date | string | null
    content?: string | null
    link?: string | null
    source?: string | null
    matched_keywords?: string | null
    region?: string | null
    sector?: string | null
    starred?: boolean | null
    starred_at?: Date | string | null
    summary?: string | null
    url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type credit_articlesCreateOrConnectWithoutUser_article_starsInput = {
    where: credit_articlesWhereUniqueInput
    create: XOR<credit_articlesCreateWithoutUser_article_starsInput, credit_articlesUncheckedCreateWithoutUser_article_starsInput>
  }

  export type usersCreateWithoutUser_article_starsInput = {
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsCreateNestedManyWithoutUsersInput
    user_activity?: user_activityCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_article_starsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password_hash: string
    role: string
    is_active: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    activity_logs?: activity_logsUncheckedCreateNestedManyWithoutUsersInput
    ai_assistant_config?: ai_assistant_configUncheckedCreateNestedManyWithoutUsersInput
    ai_conversations?: ai_conversationsUncheckedCreateNestedManyWithoutUsersInput
    ai_entity_memory?: ai_entity_memoryUncheckedCreateNestedManyWithoutUsersInput
    ai_session_memory?: ai_session_memoryUncheckedCreateNestedManyWithoutUsersInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    user_activity?: user_activityUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_article_starsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_article_starsInput, usersUncheckedCreateWithoutUser_article_starsInput>
  }

  export type credit_articlesUpsertWithoutUser_article_starsInput = {
    update: XOR<credit_articlesUpdateWithoutUser_article_starsInput, credit_articlesUncheckedUpdateWithoutUser_article_starsInput>
    create: XOR<credit_articlesCreateWithoutUser_article_starsInput, credit_articlesUncheckedCreateWithoutUser_article_starsInput>
    where?: credit_articlesWhereInput
  }

  export type credit_articlesUpdateToOneWithWhereWithoutUser_article_starsInput = {
    where?: credit_articlesWhereInput
    data: XOR<credit_articlesUpdateWithoutUser_article_starsInput, credit_articlesUncheckedUpdateWithoutUser_article_starsInput>
  }

  export type credit_articlesUpdateWithoutUser_article_starsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type credit_articlesUncheckedUpdateWithoutUser_article_starsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    matched_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    starred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    starred_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutUser_article_starsInput = {
    update: XOR<usersUpdateWithoutUser_article_starsInput, usersUncheckedUpdateWithoutUser_article_starsInput>
    create: XOR<usersCreateWithoutUser_article_starsInput, usersUncheckedCreateWithoutUser_article_starsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_article_starsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_article_starsInput, usersUncheckedUpdateWithoutUser_article_starsInput>
  }

  export type usersUpdateWithoutUser_article_starsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_article_starsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity_logs?: activity_logsUncheckedUpdateManyWithoutUsersNestedInput
    ai_assistant_config?: ai_assistant_configUncheckedUpdateManyWithoutUsersNestedInput
    ai_conversations?: ai_conversationsUncheckedUpdateManyWithoutUsersNestedInput
    ai_entity_memory?: ai_entity_memoryUncheckedUpdateManyWithoutUsersNestedInput
    ai_session_memory?: ai_session_memoryUncheckedUpdateManyWithoutUsersNestedInput
    newsletter_subscriptions?: newsletter_subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    user_activity?: user_activityUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type permissionCreateWithoutUser_permissionsInput = {
    name: $Enums.permissiontype
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type permissionUncheckedCreateWithoutUser_permissionsInput = {
    name: $Enums.permissiontype
    description?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type permissionCreateOrConnectWithoutUser_permissionsInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutUser_permissionsInput, permissionUncheckedCreateWithoutUser_permissionsInput>
  }

  export type userCreateWithoutUser_permissionsInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    usersession?: usersessionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_permissionsInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    usersession?: usersessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_permissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_permissionsInput, userUncheckedCreateWithoutUser_permissionsInput>
  }

  export type permissionUpsertWithoutUser_permissionsInput = {
    update: XOR<permissionUpdateWithoutUser_permissionsInput, permissionUncheckedUpdateWithoutUser_permissionsInput>
    create: XOR<permissionCreateWithoutUser_permissionsInput, permissionUncheckedCreateWithoutUser_permissionsInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutUser_permissionsInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutUser_permissionsInput, permissionUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type permissionUpdateWithoutUser_permissionsInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissionUncheckedUpdateWithoutUser_permissionsInput = {
    name?: EnumpermissiontypeFieldUpdateOperationsInput | $Enums.permissiontype
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutUser_permissionsInput = {
    update: XOR<userUpdateWithoutUser_permissionsInput, userUncheckedUpdateWithoutUser_permissionsInput>
    create: XOR<userCreateWithoutUser_permissionsInput, userUncheckedCreateWithoutUser_permissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUser_permissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUser_permissionsInput, userUncheckedUpdateWithoutUser_permissionsInput>
  }

  export type userUpdateWithoutUser_permissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    usersession?: usersessionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_permissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    usersession?: usersessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type activity_logsCreateWithoutUsersInput = {
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
  }

  export type activity_logsUncheckedCreateWithoutUsersInput = {
    id?: number
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
  }

  export type activity_logsCreateOrConnectWithoutUsersInput = {
    where: activity_logsWhereUniqueInput
    create: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput>
  }

  export type activity_logsCreateManyUsersInputEnvelope = {
    data: activity_logsCreateManyUsersInput | activity_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ai_assistant_configCreateWithoutUsersInput = {
    config_key: string
    config_value: string
    updated_at?: Date | string | null
  }

  export type ai_assistant_configUncheckedCreateWithoutUsersInput = {
    id?: number
    config_key: string
    config_value: string
    updated_at?: Date | string | null
  }

  export type ai_assistant_configCreateOrConnectWithoutUsersInput = {
    where: ai_assistant_configWhereUniqueInput
    create: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput>
  }

  export type ai_assistant_configCreateManyUsersInputEnvelope = {
    data: ai_assistant_configCreateManyUsersInput | ai_assistant_configCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ai_conversationsCreateWithoutUsersInput = {
    session_id: string
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_conversationsUncheckedCreateWithoutUsersInput = {
    id?: number
    session_id: string
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_conversationsCreateOrConnectWithoutUsersInput = {
    where: ai_conversationsWhereUniqueInput
    create: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput>
  }

  export type ai_conversationsCreateManyUsersInputEnvelope = {
    data: ai_conversationsCreateManyUsersInput | ai_conversationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ai_entity_memoryCreateWithoutUsersInput = {
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_entity_memoryUncheckedCreateWithoutUsersInput = {
    id?: number
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_entity_memoryCreateOrConnectWithoutUsersInput = {
    where: ai_entity_memoryWhereUniqueInput
    create: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput>
  }

  export type ai_entity_memoryCreateManyUsersInputEnvelope = {
    data: ai_entity_memoryCreateManyUsersInput | ai_entity_memoryCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ai_session_memoryCreateWithoutUsersInput = {
    session_id: string
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type ai_session_memoryUncheckedCreateWithoutUsersInput = {
    id?: number
    session_id: string
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type ai_session_memoryCreateOrConnectWithoutUsersInput = {
    where: ai_session_memoryWhereUniqueInput
    create: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput>
  }

  export type ai_session_memoryCreateManyUsersInputEnvelope = {
    data: ai_session_memoryCreateManyUsersInput | ai_session_memoryCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type newsletter_subscriptionsCreateWithoutUsersInput = {
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsCreateNestedManyWithoutNewsletter_subscriptionsInput
    newsletter_preferences?: newsletter_preferencesCreateNestedManyWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsUncheckedCreateWithoutUsersInput = {
    id?: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    newsletter_logs?: newsletter_logsUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
    newsletter_preferences?: newsletter_preferencesUncheckedCreateNestedManyWithoutNewsletter_subscriptionsInput
  }

  export type newsletter_subscriptionsCreateOrConnectWithoutUsersInput = {
    where: newsletter_subscriptionsWhereUniqueInput
    create: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type newsletter_subscriptionsCreateManyUsersInputEnvelope = {
    data: newsletter_subscriptionsCreateManyUsersInput | newsletter_subscriptionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_activityCreateWithoutUsersInput = {
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
  }

  export type user_activityUncheckedCreateWithoutUsersInput = {
    id?: number
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
  }

  export type user_activityCreateOrConnectWithoutUsersInput = {
    where: user_activityWhereUniqueInput
    create: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput>
  }

  export type user_activityCreateManyUsersInputEnvelope = {
    data: user_activityCreateManyUsersInput | user_activityCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_article_starsCreateWithoutUsersInput = {
    starred_at?: Date | string
    credit_articles: credit_articlesCreateNestedOneWithoutUser_article_starsInput
  }

  export type user_article_starsUncheckedCreateWithoutUsersInput = {
    id?: number
    article_id: number
    starred_at?: Date | string
  }

  export type user_article_starsCreateOrConnectWithoutUsersInput = {
    where: user_article_starsWhereUniqueInput
    create: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput>
  }

  export type user_article_starsCreateManyUsersInputEnvelope = {
    data: user_article_starsCreateManyUsersInput | user_article_starsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type activity_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: activity_logsWhereUniqueInput
    update: XOR<activity_logsUpdateWithoutUsersInput, activity_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<activity_logsCreateWithoutUsersInput, activity_logsUncheckedCreateWithoutUsersInput>
  }

  export type activity_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: activity_logsWhereUniqueInput
    data: XOR<activity_logsUpdateWithoutUsersInput, activity_logsUncheckedUpdateWithoutUsersInput>
  }

  export type activity_logsUpdateManyWithWhereWithoutUsersInput = {
    where: activity_logsScalarWhereInput
    data: XOR<activity_logsUpdateManyMutationInput, activity_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type activity_logsScalarWhereInput = {
    AND?: activity_logsScalarWhereInput | activity_logsScalarWhereInput[]
    OR?: activity_logsScalarWhereInput[]
    NOT?: activity_logsScalarWhereInput | activity_logsScalarWhereInput[]
    id?: IntFilter<"activity_logs"> | number
    user_id?: IntNullableFilter<"activity_logs"> | number | null
    action?: StringFilter<"activity_logs"> | string
    details?: StringNullableFilter<"activity_logs"> | string | null
    ip_address?: StringNullableFilter<"activity_logs"> | string | null
    timestamp?: DateTimeNullableFilter<"activity_logs"> | Date | string | null
  }

  export type ai_assistant_configUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_assistant_configWhereUniqueInput
    update: XOR<ai_assistant_configUpdateWithoutUsersInput, ai_assistant_configUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_assistant_configCreateWithoutUsersInput, ai_assistant_configUncheckedCreateWithoutUsersInput>
  }

  export type ai_assistant_configUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_assistant_configWhereUniqueInput
    data: XOR<ai_assistant_configUpdateWithoutUsersInput, ai_assistant_configUncheckedUpdateWithoutUsersInput>
  }

  export type ai_assistant_configUpdateManyWithWhereWithoutUsersInput = {
    where: ai_assistant_configScalarWhereInput
    data: XOR<ai_assistant_configUpdateManyMutationInput, ai_assistant_configUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_assistant_configScalarWhereInput = {
    AND?: ai_assistant_configScalarWhereInput | ai_assistant_configScalarWhereInput[]
    OR?: ai_assistant_configScalarWhereInput[]
    NOT?: ai_assistant_configScalarWhereInput | ai_assistant_configScalarWhereInput[]
    id?: IntFilter<"ai_assistant_config"> | number
    user_id?: IntNullableFilter<"ai_assistant_config"> | number | null
    config_key?: StringFilter<"ai_assistant_config"> | string
    config_value?: StringFilter<"ai_assistant_config"> | string
    updated_at?: DateTimeNullableFilter<"ai_assistant_config"> | Date | string | null
  }

  export type ai_conversationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_conversationsWhereUniqueInput
    update: XOR<ai_conversationsUpdateWithoutUsersInput, ai_conversationsUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_conversationsCreateWithoutUsersInput, ai_conversationsUncheckedCreateWithoutUsersInput>
  }

  export type ai_conversationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_conversationsWhereUniqueInput
    data: XOR<ai_conversationsUpdateWithoutUsersInput, ai_conversationsUncheckedUpdateWithoutUsersInput>
  }

  export type ai_conversationsUpdateManyWithWhereWithoutUsersInput = {
    where: ai_conversationsScalarWhereInput
    data: XOR<ai_conversationsUpdateManyMutationInput, ai_conversationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_conversationsScalarWhereInput = {
    AND?: ai_conversationsScalarWhereInput | ai_conversationsScalarWhereInput[]
    OR?: ai_conversationsScalarWhereInput[]
    NOT?: ai_conversationsScalarWhereInput | ai_conversationsScalarWhereInput[]
    id?: IntFilter<"ai_conversations"> | number
    session_id?: StringFilter<"ai_conversations"> | string
    user_id?: IntNullableFilter<"ai_conversations"> | number | null
    title?: StringNullableFilter<"ai_conversations"> | string | null
    summary?: StringNullableFilter<"ai_conversations"> | string | null
    total_messages?: IntNullableFilter<"ai_conversations"> | number | null
    tokens_used?: IntNullableFilter<"ai_conversations"> | number | null
    cost_usd?: DecimalNullableFilter<"ai_conversations"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"ai_conversations"> | string | null
    created_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_conversations"> | Date | string | null
  }

  export type ai_entity_memoryUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_entity_memoryWhereUniqueInput
    update: XOR<ai_entity_memoryUpdateWithoutUsersInput, ai_entity_memoryUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_entity_memoryCreateWithoutUsersInput, ai_entity_memoryUncheckedCreateWithoutUsersInput>
  }

  export type ai_entity_memoryUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_entity_memoryWhereUniqueInput
    data: XOR<ai_entity_memoryUpdateWithoutUsersInput, ai_entity_memoryUncheckedUpdateWithoutUsersInput>
  }

  export type ai_entity_memoryUpdateManyWithWhereWithoutUsersInput = {
    where: ai_entity_memoryScalarWhereInput
    data: XOR<ai_entity_memoryUpdateManyMutationInput, ai_entity_memoryUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_entity_memoryScalarWhereInput = {
    AND?: ai_entity_memoryScalarWhereInput | ai_entity_memoryScalarWhereInput[]
    OR?: ai_entity_memoryScalarWhereInput[]
    NOT?: ai_entity_memoryScalarWhereInput | ai_entity_memoryScalarWhereInput[]
    id?: IntFilter<"ai_entity_memory"> | number
    user_id?: IntNullableFilter<"ai_entity_memory"> | number | null
    entity_type?: StringFilter<"ai_entity_memory"> | string
    entity_key?: StringFilter<"ai_entity_memory"> | string
    entity_data?: JsonFilter<"ai_entity_memory">
    confidence_score?: DecimalNullableFilter<"ai_entity_memory"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ai_entity_memory"> | Date | string | null
  }

  export type ai_session_memoryUpsertWithWhereUniqueWithoutUsersInput = {
    where: ai_session_memoryWhereUniqueInput
    update: XOR<ai_session_memoryUpdateWithoutUsersInput, ai_session_memoryUncheckedUpdateWithoutUsersInput>
    create: XOR<ai_session_memoryCreateWithoutUsersInput, ai_session_memoryUncheckedCreateWithoutUsersInput>
  }

  export type ai_session_memoryUpdateWithWhereUniqueWithoutUsersInput = {
    where: ai_session_memoryWhereUniqueInput
    data: XOR<ai_session_memoryUpdateWithoutUsersInput, ai_session_memoryUncheckedUpdateWithoutUsersInput>
  }

  export type ai_session_memoryUpdateManyWithWhereWithoutUsersInput = {
    where: ai_session_memoryScalarWhereInput
    data: XOR<ai_session_memoryUpdateManyMutationInput, ai_session_memoryUncheckedUpdateManyWithoutUsersInput>
  }

  export type ai_session_memoryScalarWhereInput = {
    AND?: ai_session_memoryScalarWhereInput | ai_session_memoryScalarWhereInput[]
    OR?: ai_session_memoryScalarWhereInput[]
    NOT?: ai_session_memoryScalarWhereInput | ai_session_memoryScalarWhereInput[]
    id?: IntFilter<"ai_session_memory"> | number
    session_id?: StringFilter<"ai_session_memory"> | string
    user_id?: IntNullableFilter<"ai_session_memory"> | number | null
    message_index?: IntFilter<"ai_session_memory"> | number
    role?: StringFilter<"ai_session_memory"> | string
    content?: StringFilter<"ai_session_memory"> | string
    metadata?: JsonNullableFilter<"ai_session_memory">
    created_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"ai_session_memory"> | Date | string | null
  }

  export type newsletter_subscriptionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: newsletter_subscriptionsWhereUniqueInput
    update: XOR<newsletter_subscriptionsUpdateWithoutUsersInput, newsletter_subscriptionsUncheckedUpdateWithoutUsersInput>
    create: XOR<newsletter_subscriptionsCreateWithoutUsersInput, newsletter_subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type newsletter_subscriptionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: newsletter_subscriptionsWhereUniqueInput
    data: XOR<newsletter_subscriptionsUpdateWithoutUsersInput, newsletter_subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type newsletter_subscriptionsUpdateManyWithWhereWithoutUsersInput = {
    where: newsletter_subscriptionsScalarWhereInput
    data: XOR<newsletter_subscriptionsUpdateManyMutationInput, newsletter_subscriptionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type newsletter_subscriptionsScalarWhereInput = {
    AND?: newsletter_subscriptionsScalarWhereInput | newsletter_subscriptionsScalarWhereInput[]
    OR?: newsletter_subscriptionsScalarWhereInput[]
    NOT?: newsletter_subscriptionsScalarWhereInput | newsletter_subscriptionsScalarWhereInput[]
    id?: IntFilter<"newsletter_subscriptions"> | number
    user_id?: IntFilter<"newsletter_subscriptions"> | number
    subscription_type?: StringFilter<"newsletter_subscriptions"> | string
    is_active?: BoolNullableFilter<"newsletter_subscriptions"> | boolean | null
    email?: StringNullableFilter<"newsletter_subscriptions"> | string | null
    created_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"newsletter_subscriptions"> | Date | string | null
  }

  export type user_activityUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_activityWhereUniqueInput
    update: XOR<user_activityUpdateWithoutUsersInput, user_activityUncheckedUpdateWithoutUsersInput>
    create: XOR<user_activityCreateWithoutUsersInput, user_activityUncheckedCreateWithoutUsersInput>
  }

  export type user_activityUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_activityWhereUniqueInput
    data: XOR<user_activityUpdateWithoutUsersInput, user_activityUncheckedUpdateWithoutUsersInput>
  }

  export type user_activityUpdateManyWithWhereWithoutUsersInput = {
    where: user_activityScalarWhereInput
    data: XOR<user_activityUpdateManyMutationInput, user_activityUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_activityScalarWhereInput = {
    AND?: user_activityScalarWhereInput | user_activityScalarWhereInput[]
    OR?: user_activityScalarWhereInput[]
    NOT?: user_activityScalarWhereInput | user_activityScalarWhereInput[]
    id?: IntFilter<"user_activity"> | number
    user_id?: IntFilter<"user_activity"> | number
    action?: StringFilter<"user_activity"> | string
    resource_type?: StringNullableFilter<"user_activity"> | string | null
    resource_id?: IntNullableFilter<"user_activity"> | number | null
    details?: StringNullableFilter<"user_activity"> | string | null
    ip_address?: StringNullableFilter<"user_activity"> | string | null
    user_agent?: StringNullableFilter<"user_activity"> | string | null
    timestamp?: DateTimeNullableFilter<"user_activity"> | Date | string | null
    created_at?: DateTimeNullableFilter<"user_activity"> | Date | string | null
  }

  export type user_article_starsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_article_starsWhereUniqueInput
    update: XOR<user_article_starsUpdateWithoutUsersInput, user_article_starsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_article_starsCreateWithoutUsersInput, user_article_starsUncheckedCreateWithoutUsersInput>
  }

  export type user_article_starsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_article_starsWhereUniqueInput
    data: XOR<user_article_starsUpdateWithoutUsersInput, user_article_starsUncheckedUpdateWithoutUsersInput>
  }

  export type user_article_starsUpdateManyWithWhereWithoutUsersInput = {
    where: user_article_starsScalarWhereInput
    data: XOR<user_article_starsUpdateManyMutationInput, user_article_starsUncheckedUpdateManyWithoutUsersInput>
  }

  export type userCreateWithoutUsersessionInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogCreateNestedManyWithoutUserInput
    article?: articleCreateNestedManyWithoutUserInput
    articlestar?: articlestarCreateNestedManyWithoutUserInput
    articleview?: articleviewCreateNestedManyWithoutUserInput
    event?: eventCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUsersessionInput = {
    email: string
    username?: string | null
    full_name?: string | null
    hashed_password: string
    is_active: boolean
    is_verified: boolean
    role: $Enums.userrole
    bio?: string | null
    avatar_url?: string | null
    phone_number?: string | null
    last_login_at?: Date | string | null
    last_login_ip?: string | null
    failed_login_attempts: number
    locked_until?: Date | string | null
    two_factor_enabled: boolean
    two_factor_secret?: string | null
    email_verified_at?: Date | string | null
    email_verification_token?: string | null
    password_reset_token?: string | null
    password_reset_expires?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    activitylog?: activitylogUncheckedCreateNestedManyWithoutUserInput
    article?: articleUncheckedCreateNestedManyWithoutUserInput
    articlestar?: articlestarUncheckedCreateNestedManyWithoutUserInput
    articleview?: articleviewUncheckedCreateNestedManyWithoutUserInput
    event?: eventUncheckedCreateNestedManyWithoutUserInput
    eventregistration?: eventregistrationUncheckedCreateNestedManyWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    user_permissions?: user_permissionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUsersessionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUsersessionInput, userUncheckedCreateWithoutUsersessionInput>
  }

  export type userUpsertWithoutUsersessionInput = {
    update: XOR<userUpdateWithoutUsersessionInput, userUncheckedUpdateWithoutUsersessionInput>
    create: XOR<userCreateWithoutUsersessionInput, userUncheckedCreateWithoutUsersessionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUsersessionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUsersessionInput, userUncheckedUpdateWithoutUsersessionInput>
  }

  export type userUpdateWithoutUsersessionInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUpdateManyWithoutUserNestedInput
    article?: articleUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUpdateManyWithoutUserNestedInput
    articleview?: articleviewUpdateManyWithoutUserNestedInput
    event?: eventUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUsersessionInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    hashed_password?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumuserroleFieldUpdateOperationsInput | $Enums.userrole
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_login_ip?: NullableStringFieldUpdateOperationsInput | string | null
    failed_login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_verification_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    password_reset_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: activitylogUncheckedUpdateManyWithoutUserNestedInput
    article?: articleUncheckedUpdateManyWithoutUserNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutUserNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutUserNestedInput
    event?: eventUncheckedUpdateManyWithoutUserNestedInput
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    user_permissions?: user_permissionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type article_tagsCreateManyArticleInput = {
    tag_id: number
  }

  export type articlestarCreateManyArticleInput = {
    user_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewCreateManyArticleInput = {
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type article_tagsUpdateWithoutArticleInput = {
    tag?: tagUpdateOneRequiredWithoutArticle_tagsNestedInput
  }

  export type article_tagsUncheckedUpdateWithoutArticleInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type article_tagsUncheckedUpdateManyWithoutArticleInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
  }

  export type articlestarUpdateWithoutArticleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutArticlestarNestedInput
  }

  export type articlestarUncheckedUpdateWithoutArticleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlestarUncheckedUpdateManyWithoutArticleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewUpdateWithoutArticleInput = {
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutArticleviewNestedInput
  }

  export type articleviewUncheckedUpdateWithoutArticleInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewUncheckedUpdateManyWithoutArticleInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_article_starsCreateManyCredit_articlesInput = {
    id?: number
    user_id: number
    starred_at?: Date | string
  }

  export type user_article_starsUpdateWithoutCredit_articlesInput = {
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_article_starsNestedInput
  }

  export type user_article_starsUncheckedUpdateWithoutCredit_articlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_article_starsUncheckedUpdateManyWithoutCredit_articlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventregistrationCreateManyEventInput = {
    user_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventregistrationUpdateWithoutEventInput = {
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutEventregistrationNestedInput
  }

  export type eventregistrationUncheckedUpdateWithoutEventInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventregistrationUncheckedUpdateManyWithoutEventInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type newsletter_logsCreateManyNewsletter_subscriptionsInput = {
    id?: number
    sent_at?: Date | string | null
    email_to: string
    email_subject?: string | null
    articles_count?: number | null
    success?: boolean | null
    error_message?: string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: string | null
  }

  export type newsletter_preferencesCreateManyNewsletter_subscriptionsInput = {
    id?: number
    sources?: newsletter_preferencesCreatesourcesInput | string[]
    regions?: newsletter_preferencesCreateregionsInput | string[]
    sectors?: newsletter_preferencesCreatesectorsInput | string[]
    include_starred_only?: boolean | null
    frequency?: string
    day_of_week?: number | null
    time_of_day?: Date | string | null
    timezone?: string | null
    max_articles_per_email?: number | null
    include_summary?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type newsletter_logsUpdateWithoutNewsletter_subscriptionsInput = {
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_logsUncheckedUpdateWithoutNewsletter_subscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email_to?: StringFieldUpdateOperationsInput | string
    email_subject?: NullableStringFieldUpdateOperationsInput | string | null
    articles_count?: NullableIntFieldUpdateOperationsInput | number | null
    success?: NullableBoolFieldUpdateOperationsInput | boolean | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    articles_included?: NullableJsonNullValueInput | InputJsonValue
    email_content_preview?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsletter_preferencesUpdateWithoutNewsletter_subscriptionsInput = {
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_preferencesUncheckedUpdateWithoutNewsletter_subscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sources?: newsletter_preferencesUpdatesourcesInput | string[]
    regions?: newsletter_preferencesUpdateregionsInput | string[]
    sectors?: newsletter_preferencesUpdatesectorsInput | string[]
    include_starred_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    frequency?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    time_of_day?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    max_articles_per_email?: NullableIntFieldUpdateOperationsInput | number | null
    include_summary?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_permissionsCreateManyPermissionInput = {
    user_id: number
  }

  export type user_permissionsUpdateWithoutPermissionInput = {
    user?: userUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateWithoutPermissionInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_permissionsUncheckedUpdateManyWithoutPermissionInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type article_tagsCreateManyTagInput = {
    article_id: number
  }

  export type article_tagsUpdateWithoutTagInput = {
    article?: articleUpdateOneRequiredWithoutArticle_tagsNestedInput
  }

  export type article_tagsUncheckedUpdateWithoutTagInput = {
    article_id?: IntFieldUpdateOperationsInput | number
  }

  export type article_tagsUncheckedUpdateManyWithoutTagInput = {
    article_id?: IntFieldUpdateOperationsInput | number
  }

  export type activitylogCreateManyUserInput = {
    action: string
    resource?: string | null
    resource_id?: string | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status: string
    error?: string | null
    request_id?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleCreateManyUserInput = {
    title: string
    slug: string
    summary?: string | null
    content?: string | null
    source?: string | null
    source_url?: string | null
    published_at?: Date | string | null
    category?: string | null
    region?: string | null
    sector?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: number | null
    relevance_score?: number | null
    author_name?: string | null
    is_published: boolean
    is_featured: boolean
    view_count: number
    unique_viewers: number
    ai_summary?: string | null
    ai_summary_provider?: string | null
    ai_summary_generated_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type articlestarCreateManyUserInput = {
    article_id: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type articleviewCreateManyUserInput = {
    article_id: number
    ip_address?: string | null
    user_agent?: string | null
    referrer?: string | null
    view_duration?: number | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type eventCreateManyUserInput = {
    title: string
    slug: string
    description?: string | null
    event_type?: string | null
    location?: string | null
    venue?: string | null
    is_virtual: boolean
    virtual_link?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    timezone?: string | null
    registration_link?: string | null
    registration_deadline?: Date | string | null
    max_attendees?: number | null
    price?: number | null
    currency?: string | null
    organizer?: string | null
    organizer_email?: string | null
    organizer_phone?: string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: string | null
    source_url?: string | null
    is_published: boolean
    is_featured: boolean
    is_cancelled: boolean
    cancellation_reason?: string | null
    view_count: number
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
  }

  export type eventregistrationCreateManyUserInput = {
    event_id: number
    registered_at: Date | string
    is_confirmed: boolean
    is_cancelled: boolean
    cancelled_at?: Date | string | null
    cancellation_reason?: string | null
    attended: boolean
    check_in_time?: Date | string | null
    dietary_requirements?: string | null
    special_requirements?: string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type refreshtokenCreateManyUserInput = {
    token: string
    expires_at: Date | string
    revoked: boolean
    revoked_at?: Date | string | null
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_permissionsCreateManyUserInput = {
    permission_id: number
  }

  export type usersessionCreateManyUserInput = {
    session_id: string
    ip_address?: string | null
    user_agent?: string | null
    last_activity: Date | string
    expires_at: Date | string
    id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activitylogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateManyWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    request_id?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article_tags?: article_tagsUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article_tags?: article_tagsUncheckedUpdateManyWithoutArticleNestedInput
    articlestar?: articlestarUncheckedUpdateManyWithoutArticleNestedInput
    articleview?: articleviewUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type articleUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    sentiment_score?: NullableFloatFieldUpdateOperationsInput | number | null
    relevance_score?: NullableFloatFieldUpdateOperationsInput | number | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    view_count?: IntFieldUpdateOperationsInput | number
    unique_viewers?: IntFieldUpdateOperationsInput | number
    ai_summary?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_provider?: NullableStringFieldUpdateOperationsInput | string | null
    ai_summary_generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type articlestarUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: articleUpdateOneRequiredWithoutArticlestarNestedInput
  }

  export type articlestarUncheckedUpdateWithoutUserInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articlestarUncheckedUpdateManyWithoutUserInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewUpdateWithoutUserInput = {
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: articleUpdateOneRequiredWithoutArticleviewNestedInput
  }

  export type articleviewUncheckedUpdateWithoutUserInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type articleviewUncheckedUpdateManyWithoutUserInput = {
    article_id?: IntFieldUpdateOperationsInput | number
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    view_duration?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventregistration?: eventregistrationUpdateManyWithoutEventNestedInput
  }

  export type eventUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventregistration?: eventregistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type eventUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    is_virtual?: BoolFieldUpdateOperationsInput | boolean
    virtual_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    registration_link?: NullableStringFieldUpdateOperationsInput | string | null
    registration_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    max_attendees?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    organizer?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_email?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    sponsors?: NullableJsonNullValueInput | InputJsonValue
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: NullableJsonNullValueInput | InputJsonValue
    tags?: NullableJsonNullValueInput | InputJsonValue
    source?: NullableStringFieldUpdateOperationsInput | string | null
    source_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_published?: BoolFieldUpdateOperationsInput | boolean
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    view_count?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventregistrationUpdateWithoutUserInput = {
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: eventUpdateOneRequiredWithoutEventregistrationNestedInput
  }

  export type eventregistrationUncheckedUpdateWithoutUserInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventregistrationUncheckedUpdateManyWithoutUserInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    registered_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    is_cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    attended?: BoolFieldUpdateOperationsInput | boolean
    check_in_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dietary_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    special_requirements?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_permissionsUpdateWithoutUserInput = {
    permission?: permissionUpdateOneRequiredWithoutUser_permissionsNestedInput
  }

  export type user_permissionsUncheckedUpdateWithoutUserInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_permissionsUncheckedUpdateManyWithoutUserInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersessionUpdateWithoutUserInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersessionUncheckedUpdateWithoutUserInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersessionUncheckedUpdateManyWithoutUserInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    last_activity?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activity_logsCreateManyUsersInput = {
    id?: number
    action: string
    details?: string | null
    ip_address?: string | null
    timestamp?: Date | string | null
  }

  export type ai_assistant_configCreateManyUsersInput = {
    id?: number
    config_key: string
    config_value: string
    updated_at?: Date | string | null
  }

  export type ai_conversationsCreateManyUsersInput = {
    id?: number
    session_id: string
    title?: string | null
    summary?: string | null
    total_messages?: number | null
    tokens_used?: number | null
    cost_usd?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_entity_memoryCreateManyUsersInput = {
    id?: number
    entity_type: string
    entity_key: string
    entity_data: JsonNullValueInput | InputJsonValue
    confidence_score?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ai_session_memoryCreateManyUsersInput = {
    id?: number
    session_id: string
    message_index: number
    role: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type newsletter_subscriptionsCreateManyUsersInput = {
    id?: number
    subscription_type: string
    is_active?: boolean | null
    email?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type user_activityCreateManyUsersInput = {
    id?: number
    action: string
    resource_type?: string | null
    resource_id?: number | null
    details?: string | null
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string | null
    created_at?: Date | string | null
  }

  export type user_article_starsCreateManyUsersInput = {
    id?: number
    article_id: number
    starred_at?: Date | string
  }

  export type activity_logsUpdateWithoutUsersInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type activity_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_assistant_configUpdateWithoutUsersInput = {
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_assistant_configUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_assistant_configUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    config_key?: StringFieldUpdateOperationsInput | string
    config_value?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsUpdateWithoutUsersInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_conversationsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    total_messages?: NullableIntFieldUpdateOperationsInput | number | null
    tokens_used?: NullableIntFieldUpdateOperationsInput | number | null
    cost_usd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryUpdateWithoutUsersInput = {
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_entity_memoryUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_key?: StringFieldUpdateOperationsInput | string
    entity_data?: JsonNullValueInput | InputJsonValue
    confidence_score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryUpdateWithoutUsersInput = {
    session_id?: StringFieldUpdateOperationsInput | string
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ai_session_memoryUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: StringFieldUpdateOperationsInput | string
    message_index?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsletter_subscriptionsUpdateWithoutUsersInput = {
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUpdateManyWithoutNewsletter_subscriptionsNestedInput
    newsletter_preferences?: newsletter_preferencesUpdateManyWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newsletter_logs?: newsletter_logsUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
    newsletter_preferences?: newsletter_preferencesUncheckedUpdateManyWithoutNewsletter_subscriptionsNestedInput
  }

  export type newsletter_subscriptionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscription_type?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityUpdateWithoutUsersInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_activityUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource_type?: NullableStringFieldUpdateOperationsInput | string | null
    resource_id?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_article_starsUpdateWithoutUsersInput = {
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
    credit_articles?: credit_articlesUpdateOneRequiredWithoutUser_article_starsNestedInput
  }

  export type user_article_starsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_article_starsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    article_id?: IntFieldUpdateOperationsInput | number
    starred_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ArticleCountOutputTypeDefaultArgs instead
     */
    export type ArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Credit_articlesCountOutputTypeDefaultArgs instead
     */
    export type Credit_articlesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Credit_articlesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Newsletter_subscriptionsCountOutputTypeDefaultArgs instead
     */
    export type Newsletter_subscriptionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Newsletter_subscriptionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use activity_logsDefaultArgs instead
     */
    export type activity_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = activity_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use activitylogDefaultArgs instead
     */
    export type activitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = activitylogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ai_assistant_configDefaultArgs instead
     */
    export type ai_assistant_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ai_assistant_configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ai_conversationsDefaultArgs instead
     */
    export type ai_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ai_conversationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ai_entity_memoryDefaultArgs instead
     */
    export type ai_entity_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ai_entity_memoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ai_knowledge_baseDefaultArgs instead
     */
    export type ai_knowledge_baseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ai_knowledge_baseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ai_session_memoryDefaultArgs instead
     */
    export type ai_session_memoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ai_session_memoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use articleDefaultArgs instead
     */
    export type articleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = articleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use article_tagsDefaultArgs instead
     */
    export type article_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = article_tagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use articlestarDefaultArgs instead
     */
    export type articlestarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = articlestarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use articleviewDefaultArgs instead
     */
    export type articleviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = articleviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use credit_articlesDefaultArgs instead
     */
    export type credit_articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = credit_articlesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use email_alertsDefaultArgs instead
     */
    export type email_alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = email_alertsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventDefaultArgs instead
     */
    export type eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventregistrationDefaultArgs instead
     */
    export type eventregistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventregistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventsDefaultArgs instead
     */
    export type eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use methodologiesDefaultArgs instead
     */
    export type methodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = methodologiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use newsletter_logsDefaultArgs instead
     */
    export type newsletter_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = newsletter_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use newsletter_preferencesDefaultArgs instead
     */
    export type newsletter_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = newsletter_preferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use newsletter_subscriptionsDefaultArgs instead
     */
    export type newsletter_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = newsletter_subscriptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissionDefaultArgs instead
     */
    export type permissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use publicationsDefaultArgs instead
     */
    export type publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = publicationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use refreshtokenDefaultArgs instead
     */
    export type refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = refreshtokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tagDefaultArgs instead
     */
    export type tagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_activityDefaultArgs instead
     */
    export type user_activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_activityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_alertsDefaultArgs instead
     */
    export type user_alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_alertsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_article_starsDefaultArgs instead
     */
    export type user_article_starsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_article_starsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_eventsDefaultArgs instead
     */
    export type user_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_permissionsDefaultArgs instead
     */
    export type user_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_permissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersessionDefaultArgs instead
     */
    export type usersessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersessionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}